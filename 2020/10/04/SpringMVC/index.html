<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SpringMVC入门 | 十二点前要睡觉</title><meta name="keywords" content="Spring,java,SpringMVC"><meta name="author" content="leobro,zhangakenug@qq.com"><meta name="copyright" content="leobro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="什么是MVC框架MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是在WEB模型中一种很流行的框架，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，是为了简化开发，增强开发人员间的配合，减少出错，MVC是一种分层工作的方法。 model 模型：一个或多个bean，">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMVC入门">
<meta property="og:url" content="http://example.com/2020/10/04/SpringMVC/index.html">
<meta property="og:site_name" content="十二点前要睡觉">
<meta property="og:description" content="什么是MVC框架MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是在WEB模型中一种很流行的框架，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，是为了简化开发，增强开发人员间的配合，减少出错，MVC是一种分层工作的方法。 model 模型：一个或多个bean，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WechatIMG68.jpeg">
<meta property="article:published_time" content="2020-10-04T03:24:25.000Z">
<meta property="article:modified_time" content="2020-10-19T03:53:23.010Z">
<meta property="article:author" content="leobro">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="java">
<meta property="article:tag" content="SpringMVC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WechatIMG68.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/10/04/SpringMVC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-19 11:53:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/WechatIMG68.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVC%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">什么是MVC框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC"><span class="toc-number">2.</span> <span class="toc-text">什么是SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.1.</span> <span class="toc-text">SpringMVC的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DispatcherServlet%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">DispatcherServlet接口：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerMapping%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">HandlerMapping接口：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Controller%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">2.1.3.</span> <span class="toc-text">Controller接口：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewResolver%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">2.1.4.</span> <span class="toc-text">ViewResolver接口：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">SpringMVC的运行过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E5%85%A5%E9%97%A8%E4%B9%8BHelloWorld"><span class="toc-number">3.</span> <span class="toc-text">SpringMVC入门之HelloWorld</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Controller%E6%B3%A8%E8%A7%A3%E5%92%8C-RequestMapping%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">@Controller注解和@RequestMapping注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller"><span class="toc-number">4.1.</span> <span class="toc-text">@Controller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestMapping"><span class="toc-number">4.2.</span> <span class="toc-text">@RequestMapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.1.</span> <span class="toc-text">方法级别注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BA%A7%E5%88%AB%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.2.</span> <span class="toc-text">类级别注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">接收请求参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8A%8A%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E5%86%99%E5%9C%A8%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%B8%AD"><span class="toc-number">4.3.1.</span> <span class="toc-text">直接把表单数据写在参数列表中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpServletRequest%E8%8E%B7%E5%BE%97%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">HttpServletRequest获得参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BD%93Bean%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.3.</span> <span class="toc-text">通过实体Bean接收请求参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequestParam"><span class="toc-number">4.3.4.</span> <span class="toc-text">@RequestParam</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ModelAttribute"><span class="toc-number">4.3.5.</span> <span class="toc-text">@ModelAttribute</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Service%E5%92%8C-AutoWired"><span class="toc-number">5.</span> <span class="toc-text">@Service和@AutoWired</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.</span> <span class="toc-text">转发和重定向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E4%B8%8EJSON%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="toc-number">7.</span> <span class="toc-text">SpringMVC与JSON的数据交互</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jackson"><span class="toc-number">7.1.</span> <span class="toc-text">jackson</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastjson"><span class="toc-number">7.2.</span> <span class="toc-text">fastjson</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax-json%E4%B8%8EMVC%E4%BA%A4%E4%BA%92%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.3.</span> <span class="toc-text">ajax json与MVC交互实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">拦截器的配置与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">拦截器的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A%E7%94%A8%E6%88%B7%E7%9A%84%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81"><span class="toc-number">8.3.</span> <span class="toc-text">拦截器实例：用户的登录权限验证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">验证器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Validator%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.1.</span> <span class="toc-text">Validator接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ValidationUtils%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">ValidationUtils类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">9.3.</span> <span class="toc-text">验证器实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RESTful%E9%A3%8E%E6%A0%BC"><span class="toc-number">10.</span> <span class="toc-text">RESTful风格</span></a></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">十二点前要睡觉</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">SpringMVC入门</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-10-04T03:24:25.000Z" title="undefined 2020-10-04 11:24:25">2020-10-04</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="什么是MVC框架"><a href="#什么是MVC框架" class="headerlink" title="什么是MVC框架"></a><strong>什么是MVC框架</strong></h1><p>MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是在WEB模型中一种很流行的框架，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，是为了简化开发，增强开发人员间的配合，减少出错，MVC是一种分层工作的方法。</p>
<p>model 模型：一个或多个bean，负责存储数据和处理业务逻辑<br>view 视图：一个或多个jsp文件，负责显示信息<br>controller 控制器：一个或多个servlet，负责处理与用户间的交互</p>
<hr>
<h1 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a><strong>什么是SpringMVC</strong></h1><p>SpringMVC是Spring的一个子框架，拥有Spring的特性</p>
<h2 id="SpringMVC的组成"><a href="#SpringMVC的组成" class="headerlink" title="SpringMVC的组成"></a><strong>SpringMVC的组成</strong></h2><p>Spring MVC主要由 DispatcherServlet(前端控制器)、HandlerMapping(处理器映射)、Controller(处理器)、ViewResolver(视图解析器)、View(视图) 组成</p>
<ul>
<li><h3 id="DispatcherServlet接口："><a href="#DispatcherServlet接口：" class="headerlink" title="DispatcherServlet接口："></a>DispatcherServlet接口：</h3></li>
</ul>
<p>(Servlet)</p>
<p>DispatcherServlet是SpringMVC的核心，DispatcherServlet接口是前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping类定位到具体的Controller</p>
<ul>
<li><h3 id="HandlerMapping接口："><a href="#HandlerMapping接口：" class="headerlink" title="HandlerMapping接口："></a>HandlerMapping接口：</h3></li>
</ul>
<p>(Servlet-Mapping)</p>
<p>DispatcherServlet通过HandlerMapping定位具体的Controller，将客户端请求交给Controller</p>
<ul>
<li><h3 id="Controller接口："><a href="#Controller接口：" class="headerlink" title="Controller接口："></a>Controller接口：</h3></li>
</ul>
<p>(Servlet)</p>
<p>Controller将处理客户端发来的请求，一旦Controller处理完用户请求，将返回ModelAndView对象给 DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。</p>
<ul>
<li><h3 id="ViewResolver接口："><a href="#ViewResolver接口：" class="headerlink" title="ViewResolver接口："></a>ViewResolver接口：</h3></li>
</ul>
<p>Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</p>
<h2 id="SpringMVC的运行过程"><a href="#SpringMVC的运行过程" class="headerlink" title="SpringMVC的运行过程"></a>SpringMVC的运行过程</h2><p><img src="/2020/10/04/SpringMVC/SpringMVC.png"></p>
<p>SpringMVC的运行过程为：</p>
<p>客户端提交请求给DispatcherServlet，DispatcherServlet寻找一个或多个的处理器映射HandlerMapping，找到与请求相应的Controller，然后将请求交给Controller，Controller处理完毕请求之后返回ModelAndView对象给Dispatcher，Dispatcher通过ViewResolver找到ModelAndView中指定的视图后，将视图返回给客户端</p>
<hr>
<h1 id="SpringMVC入门之HelloWorld"><a href="#SpringMVC入门之HelloWorld" class="headerlink" title="SpringMVC入门之HelloWorld"></a><strong>SpringMVC入门之HelloWorld</strong></h1><p>在springmvc.controller包下创建HelloWorldController类，继承Controller接口：</p>
<p><strong>注：要选择org.springframework.web.servlet接口下的Controller子接口</strong></p>
<pre><code>package springmvc.controller;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

public class HelloWorldController implements Controller &#123;
    @Override
    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;
        ModelAndView mav = new ModelAndView();
        mav.addObject(&quot;message&quot;,&quot;helloworld!&quot;);
        mav.setViewName(&quot;/WEB-INF/helloWorld.jsp&quot;);
        return mav;
    &#125;
&#125;</code></pre>
<p>其中的helloWorld.jsp文件后面会创建</p>
<p>配置dispatcher-servlet.xml文件，为前端处理器添加处理器映射：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;
&lt;beans&gt;
    &lt;bean id=&quot;simpleUrlHandlerMapping&quot;
          class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
        &lt;property name=&quot;mappings&quot;&gt;
            &lt;props&gt;
&lt;!--                这里HelloWorldController使用的是后边bean的id--&gt;
                &lt;prop key=&quot;/index&quot;&gt;HelloWorldController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;HelloWorldController&quot; class=&quot;springmvc.controller.HelloWorldController&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>配置web.xml文件：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee
http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;
    &lt;servlet&gt;

&lt;!--        会自动使用这个name到WEB-INF中找***-servlet.xml 的文件，所以xml文件名为dispatcher-servlet.xml，而这里的servlet-name为dispatcher--&gt;

        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.springframework.web.servlet.DispatcherServlet
        &lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;!--这里将url设置为/，处理所有的url        --&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
<p>修改index.jsp文件：</p>
<pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;h1&gt;welcome to login&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>在WEB-INF下添加helloWorld.jsp文件：</p>
<pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%--绑定处理器中添加的值--%&gt;

    &lt;h1&gt;$&#123;message&#125;&lt;/h1&gt;    
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>项目的文件目录如下：</p>
<p><img src="/2020/10/04/SpringMVC/content.jpg" alt="content"></p>
<p>postman访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a><br><img src="/2020/10/04/SpringMVC/8080.jpg" alt="8080"></p>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:8080/index">http://localhost:8080/index</a><br><img src="/2020/10/04/SpringMVC/index.jpg" alt="index"></p>
<p>SpringMVC中的数据绑定，只要在控制器中对数据模型进行相应的处理，如上面例子的</p>
<pre><code>mav.addObject(&quot;message&quot;,&quot;helloworld!&quot;); </code></pre>
<p>或者Model类型对象的 addAttribute()方法处理数据，然后在相应的view层使用${}显示数据即可。</p>
<p>如果在Dispatcher中配置视图解析器</p>
<pre><code>&lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>
<p>则Controller中的返回对象ModelAndView中指定的视图不用添加前缀和后缀</p>
<pre><code>mav.setViewName(&quot;result&quot;);</code></pre>
<p>将返回同样的结果</p>
<hr>
<h1 id="Controller注解和-RequestMapping注解"><a href="#Controller注解和-RequestMapping注解" class="headerlink" title="@Controller注解和@RequestMapping注解"></a><strong>@Controller注解和@RequestMapping注解</strong></h1><p><strong>注：要使用注解，要在控制器的配置文件中加上如下语句</strong>    </p>
<pre><code>&lt;context: component-scan base-package=&quot;package-name&quot;&gt;&lt;/context: component-scan&gt;</code></pre>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>使用@Controller注解将某类声明为控制器，使用@Controller就不用在Dispatcher配置文件中配置控制器了</p>
<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>使用@RequestMapping可以为每个请求编写对应的处理方法</p>
<h3 id="方法级别注解"><a href="#方法级别注解" class="headerlink" title="方法级别注解"></a>方法级别注解</h3><p>@RequestMapping作用于方法时，若客户端有相应的请求，则dispatcher将通过该请求找到对应的方法，从而找到方法所在的控制器，由控制器处理</p>
<pre><code>@Controller
public class LoginController &#123;
    @RequestMapping(&quot;/login&quot;)
    public String login()&#123;
        return &quot;login&quot;;
    &#125;
    @RequestMapping(value = &quot;/result&quot;)
    public String result()&#123;
        return &quot;result&quot;;
    &#125;
&#125;

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;welcome to login&lt;/h1&gt;
&lt;form action=&quot;/result&quot;&gt;
    学号：&lt;input name=&quot;id&quot;&gt;&lt;br&gt;
    姓名：&lt;input name=&quot;name&quot;&gt;&lt;br&gt;
    年龄：&lt;input name=&quot;age&quot;&gt;&lt;br&gt;
    &lt;button type=&quot;sumbit&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><strong>注：此配置是基于视图处理器的配置</strong></p>
<p>此时，浏览器打开<a target="_blank" rel="noopener" href="http://localhost:8080/login">http://localhost:8080/login</a> 将会成功显示登陆界面</p>
<h3 id="类级别注解"><a href="#类级别注解" class="headerlink" title="类级别注解"></a>类级别注解</h3><p>在类级别注解的情况下，控制器类中的所有方法都将映射为类级别的请求。</p>
<pre><code>@Controller
@RequestMapping(&quot;/init&quot;)
public class LoginController &#123;
    @RequestMapping(&quot;/login&quot;)
    public String login()&#123;
        return &quot;login&quot;;
    &#125;
    @RequestMapping(value = &quot;/result&quot;)
    public String result()&#123;
        return &quot;result&quot;;
    &#125;
&#125;</code></pre>
<p>此时，浏览器打开<a target="_blank" rel="noopener" href="http://localhost:8080/init/login">http://localhost:8080/init/login</a> 将会成功显示登陆界面</p>
<h2 id="接收请求参数"><a href="#接收请求参数" class="headerlink" title="接收请求参数"></a><strong>接收请求参数</strong></h2><h3 id="直接把表单数据写在参数列表中"><a href="#直接把表单数据写在参数列表中" class="headerlink" title="直接把表单数据写在参数列表中"></a><strong>直接把表单数据写在参数列表中</strong></h3><pre><code>@Controller
public class LoginController &#123;
    @RequestMapping(&quot;/login&quot;)
    public String login()&#123;
        return &quot;login&quot;;
    &#125;
    @RequestMapping(value = &quot;/result&quot;)
    public String result(String name,String id,int age,Model model)&#123;
        model.addAttribute(&quot;id&quot;,id);
        model.addAttribute(&quot;name&quot;,name);
        model.addAttribute(&quot;age&quot;,age);
        return &quot;result&quot;;
    &#125;
&#125;</code></pre>
<h3 id="HttpServletRequest获得参数"><a href="#HttpServletRequest获得参数" class="headerlink" title="HttpServletRequest获得参数"></a><strong>HttpServletRequest获得参数</strong></h3><p>如Model接口和javax.servlet.http.HttpServletRequest组合可以像ModelAndView那样返回客户端的值</p>
<pre><code>@RequestMapping(value = &quot;/result&quot;)
public String result(Model model,javax.servlet.http.HttpServletRequest httpServletRequest)&#123;
    model.addAttribute(&quot;id&quot;,httpServletRequest.getParameter(&quot;id&quot;));
    model.addAttribute(&quot;name&quot;,httpServletRequest.getParameter(&quot;name&quot;));
    model.addAttribute(&quot;age&quot;,httpServletRequest.getParameter(&quot;age&quot;));
    return &quot;result&quot;;
&#125;</code></pre>
<h3 id="通过实体Bean接收请求参数"><a href="#通过实体Bean接收请求参数" class="headerlink" title="通过实体Bean接收请求参数"></a><strong>通过实体Bean接收请求参数</strong></h3><p>student类：</p>
<pre><code>@Component
public class student &#123;
    private String id;
    private String name;
    private int age;
    //省略getter和setter
    public String toString()&#123;
        return &quot;[id=&quot;+id+&quot;,name=&quot;+name+&quot;,age=&quot;+age+&quot;]&quot;;
    &#125;
&#125;

@RequestMapping(value = &quot;/result&quot;)
public String result(student stu,Model model)&#123;
    model.addAttribute(&quot;id&quot;,stu.getId());
    model.addAttribute(&quot;name&quot;,stu.getName());
    model.addAttribute(&quot;age&quot;,stu.getAge());
    return &quot;result&quot;;
&#125;</code></pre>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><strong>@RequestParam</strong></h3><pre><code>@RequestMapping(value = &quot;/result&quot;)
public String result(student stu, Model model, @RequestParam String name, @RequestParam String id)&#123;
        System.out.println(id + &quot; &quot; + name);
        model.addAttribute(&quot;id&quot;, stu.getId());
        model.addAttribute(&quot;name&quot;, stu.getName());
        model.addAttribute(&quot;age&quot;, stu.getAge());
    return &quot;result&quot;;
&#125;</code></pre>
<h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><strong>@ModelAttribute</strong></h3><p>当 @ModelAttribute 注解放在处理方法的形参上时，用于将多个请求参数封装到一个实体对象，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用。而“通过实体Bean接收请求参数”中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用 model.addAttribute 语句才能暴露为模型数据)</p>
<pre><code>@RequestMapping(value = &quot;/result&quot;)
public String result(@ModelAttribute(&quot;stu&quot;) student stu)&#123;
    System.out.println(stu.getId()+&quot; &quot;+stu.getName()+&quot; &quot;+stu.getAge());
    return &quot;result&quot;;
&#125;</code></pre>
<p>在result处理方法中，ModelAttribute(“stu”) student stu先将请求参数的输入封装到student对象中，然后再创建对象的实例，以键值为stu存储在Model对象中</p>
<p>此时，只要在相应的result.jsp中使用EL表达式¥{property}就可以将数据表示出来</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;登录成功&lt;/h1&gt;
    &lt;p&gt;$&#123;id&#125;&lt;/p&gt;
    &lt;p&gt;$&#123;name&#125;&lt;/p&gt;
    &lt;p&gt;$&#123;age&#125;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>ModelAttribute作用于无返回值的方法，被@ModelAttribute注释的方法会在此controller每个方法执行前被执行</p>
<p>在控制器中添加show方法，想要把请求参数显示在result.jsp中</p>
<pre><code>@ModelAttribute
public void show(Model model,@RequestParam String name)&#123;
    model.addAttribute(&quot;name&quot;,name);
&#125;</code></pre>
<p>运行发现，name请求参数成功显示在页面中</p>
<h1 id="Service和-AutoWired"><a href="#Service和-AutoWired" class="headerlink" title="@Service和@AutoWired"></a>@Service和@AutoWired</h1><p>在springmvc.controller包下创建ServiceInterface接口</p>
<pre><code>public interface ServiceInterface &#123;
    public void service(student stu);
&#125;</code></pre>
<p>提供实现类ServiceImpl，该类标注为Service类</p>
<pre><code>@Service
public class ServiceImpl implements ServiceInterface&#123;
    public void service(student stu)&#123;
        System.out.println(&quot;service&quot;);
        System.out.println(stu.toString());
    &#125;
&#125;</code></pre>
<p>在LoginController控制器中添加属性，标志为自动注入</p>
<pre><code>@Autowired(required = false)
ServiceInterface serviceInterface;</code></pre>
<p>修改result处理方法</p>
<pre><code>@RequestMapping(value = &quot;/result&quot;)
public String result(@ModelAttribute(&quot;stu&quot;) student stu)&#123;
    serviceInterface.service(stu);
    return &quot;result&quot;;
&#125;</code></pre>
<p>在postman中提交请求，可以发现IDEA输出端成功显示表单信息</p>
<h1 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a><strong>转发和重定向</strong></h1><p>重定向是将用户从当前处理请求定向到另一个视图或处理请求，以前的请求（request）中存放的信息全部失效，并进入一个新的 request 作用域，如return “redirect:aview”;</p>
<p>转发是将用户对当前处理的请求转发给另一个视图或处理请求，以前的 request 中存放的信息不会失效。</p>
<p>转发是服务器行为，重定向是客户端行为。</p>
<p>在 Spring MVC 框架中，控制器类中处理方法的 return 语句默认就是转发实现，只不过实现的是转发到视图。</p>
<h1 id="SpringMVC与JSON的数据交互"><a href="#SpringMVC与JSON的数据交互" class="headerlink" title="SpringMVC与JSON的数据交互"></a>SpringMVC与JSON的数据交互</h1><h2 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a><strong>jackson</strong></h2><p>添加依赖</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
  &lt;version&gt;2.8.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
  &lt;version&gt;2.8.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
  &lt;version&gt;2.8.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>在UserController中添加json方法</p>
<pre><code>@RequestMapping(&quot;/json&quot;)
@ResponseBody
public String json()&#123;
    return new student(&quot;123&quot;,&quot;张三&quot;,12).toString();
&#125;</code></pre>
<p>或者使用ObjectMapper对象的writeValueAsString方法，将对象解析为字符串</p>
<pre><code>@RequestMapping(value = &quot;/json&quot;)
@ResponseBody
public String json() throws IOException &#123;
    student stu =  new student(&quot;123&quot;,&quot;张三&quot;,12);
    ObjectMapper objectMapper = new ObjectMapper();
    String str = objectMapper.writeValueAsString(stu);
    return str;
&#125;</code></pre>
<p>另外，用@ResponseBody作用于方法返回字符串给请求，@RequestBody作用于参数用于接受Json对象字符串后自动转换为对象</p>
<p>postman测试，网页中出现[id=123,name=??,age=12]，出现乱码</p>
<p><strong>JSON乱码解决</strong></p>
<ul>
<li>@RequestMapping添加属性 produces=”application/json;charset=utf-8”</li>
</ul>
<p>此时返回[id=123,name=张三,age=12]</p>
<ul>
<li><p>在dispatcher-servlet中添加如下配置统一解决问题</p>
<p>  &lt;mvc: annotation-driven&gt;</p>
<pre><code>  &lt;mvc: message-converters register-defaults=&quot;true&quot;&gt;
      &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
          &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
      &lt;/bean&gt;
      &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
          &lt;property name=&quot;objectMapper&quot;&gt;
              &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                  &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
              &lt;/bean&gt;
          &lt;/property&gt;
      &lt;/bean&gt;
  &lt;/mvc: message-converters&gt;</code></pre>
<p>  &lt;/mvc: annotation-driven&gt;</p>
</li>
<li><p>将控制器注解位@RestController</p>
</li>
</ul>
<p>此时控制器类的所有处理方法都返回一个JSON字符串，不再进行视图解析</p>
<h2 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a><strong>fastjson</strong></h2><p>添加依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.74&lt;/version&gt;
 &lt;/dependency&gt;</code></pre>
<p>fastjson中JSON类中有很多静态方法，只要返回字符串就好，如</p>
<pre><code>String str = JSON.toJSONString(stu);</code></pre>
<p>当然也有json字符串转换为java对象的方法</p>
<h2 id="ajax-json与MVC交互实例"><a href="#ajax-json与MVC交互实例" class="headerlink" title="ajax json与MVC交互实例"></a><strong>ajax json与MVC交互实例</strong></h2><p>模仿注册页面中账号和密码的有效性检验</p>
<p>User类：</p>
<p>@Component<br>public class User {</p>
<pre><code>@NotBlank(message = &quot;用户名不能为空&quot;)
private String name;
@NotBlank(message = &quot;密码不能为空&quot;)
@Length(min = 3,max = 8,message = &quot;密码位数为3-8位&quot;)
private String passwords;

public String getPasswords() &#123;
    return passwords;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setPasswords(String passwords) &#123;

    this.passwords = passwords;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

public String toString()&#123;
    return &quot;[name=&quot;+name+&quot;,passwords=&quot;+passwords+&quot;]&quot;;
&#125;</code></pre>
<p>}</p>
<p>UserController：</p>
<pre><code>@Controller
public class UserController &#123;

    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    public String test(User user)&#123;
//        System.out.println(user+&quot; &quot;+passwords);
        System.out.println(user);
        String msg = &quot;&quot;;
        if(user.getName()!=null)&#123;
            if(user.getName().equals(&quot;123&quot;))&#123;
                msg =  &quot;ok&quot;;
            &#125;else&#123;
                msg =  &quot;failed&quot;;
            &#125;
        &#125;
        if(user.getPasswords()!=null)&#123;
            if(user.getPasswords().equals(&quot;1233&quot;))&#123;
                msg =  &quot;ok&quot;;
            &#125;else&#123;
                msg = &quot;failed&quot;;
            &#125;
        &#125;
        return msg;
    &#125;

&#125;</code></pre>
<p>jsp文件：</p>
<pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;https://s3.pstatp.com/cdn/expire-1-M/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script&gt;
        function uservalidator() &#123;
            $.ajax(&#123;
                url:&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;,
                data:&#123;&quot;name&quot;:$(&quot;#user&quot;).val(),&quot;passwords&quot;:$(&quot;#passwords&quot;).val()&#125;,
                success:function (data) &#123;
                    $(&quot;#usermsg&quot;).html(data)
                &#125;
            &#125;)
        &#125;
    &lt;/script&gt;
    &lt;script&gt;
        function passwordsvalidator() &#123;
            $.ajax(&#123;
                url:&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;,
                data:&#123;&quot;name&quot;:$(&quot;#user&quot;).val(),&quot;passwords&quot;:$(&quot;#passwords&quot;).val()&#125;,
                success:function (data) &#123;
                    $(&quot;#pswmsg&quot;).html(data)
                &#125;
            &#125;)
        &#125;
    &lt;/script&gt;
    &lt;form&gt;
        用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; id=&quot;user&quot; onblur=&quot;uservalidator()&quot;&gt;&lt;br&gt;
        &lt;p id=&quot;usermsg&quot;&gt;&lt;/p&gt;
        密码：&lt;input type=&quot;password&quot; name=&quot;passwords&quot; id=&quot;passwords&quot; onblur=&quot;passwordsvalidator()&quot;&gt;
        &lt;p id=&quot;pswmsg&quot;&gt;&lt;/p&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><strong>拦截器</strong></h1><p>SpringMVC的拦截器和Servlet中的Filter相似，主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上</p>
<p>定义一个拦截器需要实现HandlerInterceptor接口，HandlerInterceptor接口中有三个方法</p>
<ul>
<li><p>preHandle：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。</p>
</li>
<li><p>postHandle：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型<br>和视图做进一步的修改。</p>
</li>
<li><p>afterCompletion：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。</p>
</li>
</ul>
<h2 id="拦截器的配置与使用"><a href="#拦截器的配置与使用" class="headerlink" title="拦截器的配置与使用"></a><strong>拦截器的配置与使用</strong></h2><p>在springmvc.controller包下定义一个MyInterceptor类，实现HandlerInterceptor接口</p>
<pre><code>public class MyInterceptor implements HandlerInterceptor &#123;
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(&quot;preHandle&quot;);
        return true;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;postHandle&quot;);
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;afterCompletion&quot;);
    &#125;
&#125;</code></pre>
<p>在springmvc-dispatcher.xml中配置拦截器</p>
<pre><code>&lt;mvc:interceptors&gt;
    &lt;bean class=&quot;springmvc.controller.MyInterceptor&quot;&gt;&lt;/bean&gt;
&lt;/mvc:interceptors&gt;</code></pre>
<p>&lt;mvc： interceptors&gt; 元素用于配置一组拦截器，其子元素 <bean> 定义的是全局拦截器，即拦截所有的请求。</bean></p>
<p>若还要定义其他拦截器，可在里面加上</p>
<pre><code>&lt;mvc:interceptor&gt;
    &lt;!-- 配置拦截器作用的路径 --&gt;
    &lt;mvc:mapping path=&quot;&quot; /&gt;
    &lt;!-- 配置不需要拦截作用的路径 --&gt;
    &lt;mvc:exclude-mapping path=&quot;&quot; /&gt;
    &lt;!-- 定义&lt;mvc:interceptor&gt;元素中，表示匹配指定路径的请求才进行拦截 --&gt;
    &lt;bean class=&quot;&quot;/&gt;
&lt;/mvc:interceptor&gt;</code></pre>
<p>&lt;mvc： interceptor&gt; 元素的子元素必须按照 &lt;mvc： mapping…/&gt;、&lt;mvc： exclude-mapping…/&gt;、&lt;bean…/&gt; 的顺序配置。</p>
<p>运行程序，输出端输出：</p>
<p>preHandle<br>springmvc.controller.LoginController<br>postHandle<br>afterCompletion</p>
<h2 id="拦截器的执行流程"><a href="#拦截器的执行流程" class="headerlink" title="拦截器的执行流程"></a><strong>拦截器的执行流程</strong></h2><p>若配置文件中只定义了一个拦截器，则根据 preHandle -&gt; ControllerMethod -&gt; postHandle -&gt; afterCompletion执行</p>
<p>若配置了多个拦截器，则它们的 preHandle 方法将按照配置文件中拦截器的配置顺序执行，而它们的 postHandle 方法和 afterCompletion 方法则按照配置顺序的反序执行</p>
<p>定义一个类MyInterceptor1，和类MyInterceptor一样，MyInterceptor类中的三个方法输出1，MyInterceptor1的三个方法输出2，在springmvc配置文件中定义两个拦截器interceptor、interceptor1</p>
<pre><code>&lt;mvc:interceptors&gt;</code></pre>
<!--        <bean class="springmvc.controller.MyInterceptor"></bean>-->
<pre><code>    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;bean class=&quot;springmvc.controller.MyInterceptor&quot;&gt;&lt;/bean&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/login&quot;/&gt;
        &lt;bean class=&quot;springmvc.controller.MyInterceptor1&quot;&gt;&lt;/bean&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre>
<p>输出端输出：</p>
<p>preHandle 1<br>preHandle 2<br>postHandle 2<br>postHandle 1<br>afterCompletion 2<br>afterCompletion 1</p>
<h2 id="拦截器实例：用户的登录权限验证"><a href="#拦截器实例：用户的登录权限验证" class="headerlink" title="拦截器实例：用户的登录权限验证"></a><strong>拦截器实例：用户的登录权限验证</strong></h2><p>这个WEB应用中，主要有tologin跳转登录页面、login登录页面、result结果页面，如果用户未登录直接进入到result页面，则显示用户未登录，如果用户账号或密码错误，则提示账号或密码错误</p>
<p>在springmvc.interceptor包下添加User类</p>
<pre><code>public class User &#123;

    private String users;

    private String passwords;

    //省略getter和setter方法
&#125;

@Controller
public class UserController &#123;</code></pre>
<p>UserController控制器</p>
<pre><code>    @RequestMapping(&quot;/tologin&quot;)
    public String tologin()&#123;
        return &quot;login&quot;;
    &#125;
    @RequestMapping(&quot;/login&quot;)
    public String login(User user, HttpSession session, Model model)&#123;
        System.out.println(user.getUsers()+&quot; &quot;+user.getPasswords());
        if(&quot;123&quot;.equals(user.getUsers())&amp;&amp;&quot;123&quot;.equals(user.getPasswords()))&#123;
            session.setAttribute(&quot;user&quot;,user);
            return &quot;redirect:result&quot;;
        &#125;
        model.addAttribute(&quot;msg&quot;,&quot;用户名或密码错误，请重新登录！&quot;);
        return &quot;login&quot;;
    &#125;
    @RequestMapping(&quot;/result&quot;)
    public String result()&#123;
        return &quot;result&quot;;
    &#125;

    @RequestMapping(&quot;/exit&quot;)
    public String exit(HttpServletRequest request,HttpSession session)&#123;
    session.invalidate();
    return &quot;login&quot;;
&#125;

&#125;</code></pre>
<p>创建拦截器loginInterceptor</p>
<pre><code>public class loginInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(&quot;123&quot;);
        StringBuffer url = request.getRequestURL();
        if(url.indexOf(&quot;/tologin&quot;)&gt;=0||url.indexOf(&quot;/login&quot;)&gt;=0) return true;
        HttpSession session = request.getSession();
        Object obj = session.getAttribute(&quot;user&quot;);
        if(obj != null) return true;
        request.setAttribute(&quot;msg&quot;,&quot;请登录！&quot;);
        request.getRequestDispatcher(&quot;/WEB-INF/login.jsp&quot;).forward(request,response);
        return false;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;</code></pre>
<p>配置Dispatcher-servlet.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
        &lt;context:component-scan base-package=&quot;springmvc.interceptor&quot;&gt;&lt;/context:component-scan&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt;
            &lt;bean class=&quot;springmvc.interceptor.loginInterceptor&quot;&gt;&lt;/bean&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
&lt;/beans&gt;</code></pre>
<p>配置web.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee
http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;interceptor&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.springframework.web.servlet.DispatcherServlet
        &lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;interceptor&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
<p>login.jsp：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;$&#123;msg&#125;&lt;/h1&gt;
&lt;form method=&quot;get&quot; action=&quot;/login&quot;&gt;
    账号：&lt;input type=&quot;text&quot; name=&quot;users&quot; id=&quot;users&quot;&gt;&lt;br&gt;
    密码：&lt;input type=&quot;password&quot; name=&quot;passwords&quot; id=&quot;passwords&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>result.jsp：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;当前用户：$&#123;user.users&#125;&lt;/p&gt;
    &lt;form action=&quot;/exit&quot;&gt;
        &lt;button type=&quot;submit&quot;&gt;退出&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>直接进入result<br><img src="/2020/10/04/SpringMVC/1.png" alt="1"></p>
<p>输入账号密码<br><img src="/2020/10/04/SpringMVC/2.png" alt="2"></p>
<p>退出<br><img src="/2020/10/04/SpringMVC/3.png" alt="3"></p>
<p>再次直接进入result<br><img src="/2020/10/04/SpringMVC/4.png" alt="4"></p>
<h1 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a><strong>验证器</strong></h1><h2 id="Validator接口"><a href="#Validator接口" class="headerlink" title="Validator接口"></a><strong>Validator接口</strong></h2><p>创建自定义的验证器需要实现org.springframework.validation.Validator 接口，该接口有两个接口方法：</p>
<p>boolean supports(Class&lt;?&gt; klass)<br>void validate(Object object,Errors errors)</p>
<p>当supports返回true时，验证器可以处理指定的Class</p>
<p>validate 方法的功能是验证目标对象 object，并将验证错误消息存入 Errors 对象</p>
<p>往 Errors 对象存入错误消息的方法是 reject 或 rejectValue，这两个方法的部分重载方法如下：</p>
<p>void reject(String errorCode)<br>void reject(String errorCode,String defaultMessage)<br>void rejectValue(String filed,String errorCode)<br>void rejectValue(String filed,String errorCode,String defaultMessage)</p>
<h2 id="ValidationUtils类"><a href="#ValidationUtils类" class="headerlink" title="ValidationUtils类"></a><strong>ValidationUtils类</strong></h2><p>org.springframework.validation.ValidationUtils 是一个工具类</p>
<h2 id="验证器实例"><a href="#验证器实例" class="headerlink" title="验证器实例"></a>验证器实例</h2><p>引用上面用户登录的例子，当用户用户名或密码为空的时候，提示错误</p>
<p>在springmvc.validator包下创建MyValidator类，实现Validator接口</p>
<pre><code>@Component
public class MyValidator implements Validator &#123;
    public boolean supports(Class&lt;?&gt; aClass) &#123;
        return User.class.isAssignableFrom(aClass);
    &#125;

    public void validate(Object o, Errors errors) &#123;
        User user = (User)o;
        ValidationUtils.rejectIfEmpty(errors,&quot;users&quot;,&quot;user.users.required&quot;);
        ValidationUtils.rejectIfEmpty(errors,&quot;passwords&quot;,&quot;passwords.invalid&quot;);
    &#125;
&#125;</code></pre>
<p>在interceptor-servlet.xml中添加对validator包的自动扫描机制</p>
<pre><code>    &lt;context:component-scan base-package=&quot;springmvc.validator&quot;&gt;&lt;/context:component-scan&gt;</code></pre>
<p>修改UserController中的login处理方法</p>
<pre><code>public String login(@ModelAttribute User user, HttpSession session, Model model, BindingResult result)&#123;
    MyValidator myValidator = new MyValidator();
    if(myValidator.supports(User.class))&#123;
        myValidator.validate(user,result);
        List&lt;ObjectError&gt; list = result.getAllErrors();
        for(ObjectError error:list)&#123;
            System.out.println(error.getCode());
        &#125;
    &#125;
    if(result.hasErrors())  return &quot;redirect:tologin&quot;;
    if(&quot;123&quot;.equals(user.getUsers())&amp;&amp;&quot;123&quot;.equals(user.getPasswords()))&#123;
        session.setAttribute(&quot;user&quot;,user);
        return &quot;redirect:result&quot;;
    &#125;
    model.addAttribute(&quot;msg&quot;,&quot;用户名或密码错误，请重新登录！&quot;);
    return &quot;login&quot;;
&#125;</code></pre>
<p>此时，若不输入账号密码直接登录，则终端输出</p>
<p>user.users.required<br>passwords.invalid</p>
<p>##<strong>Spring MVC JSR-303验证框架之Hibernate-Validator</strong></p>
<p>JSR-303是一个数据验证的规范，JSR-303的校验是基于注解的，Spring中没有对这一规范进行实现，所以在SpringMVC中使用JSR-303的时候就需要提供一个对JSR-303规范的实现，而Hibernate-Validator是实现了这一规范的，使用Hibernate-Validator进行验证，不再需要实现Validator接口</p>
<p>Hibernate-Validator内部已经定义好了一系列的限制注解，我们只需要把这些注解标记在需要验证的实体类的属性上或是其对应的get方法上</p>
<p><strong>注：要使用Hibernate-Validator进行验证，需要在配置文件中加上</strong></p>
<pre><code>    &lt;mvc:annotation-driven/&gt;  </code></pre>
<p><strong>并添加依赖：</strong></p>
<pre><code>dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
        &lt;version&gt;6.1.6.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>使用Hibernate-Validator进行验证，可以在要验证的 类的属性 或 getter方法加上相应的注解</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Nul</td>
<td>被注释的元素必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>被注释的元素必须不为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>被注释的元素必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>被注释的元素必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@Size(max, min)</td>
<td>被注释的元素的大小必须在指定的范围内，元素必须为集合，代表集合个数</td>
</tr>
<tr>
<td>@Digits (integer, fraction)</td>
<td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>
<tr>
<td>@Email</td>
<td>被注释的元素必须是电子邮箱地址</td>
</tr>
<tr>
<td>@Length(min=, max=)</td>
<td>被注释的字符串的大小必须在指定的范围内，必须为数组或者字符串，若微数组则表示为数组长度，字符串则表示为字符串长度</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>被注释的字符串的必须非空</td>
</tr>
<tr>
<td>@Range(min=, max=)</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>被注释的字符串的必须非空</td>
</tr>
<tr>
<td>@Pattern(regexp = )</td>
<td>正则表达式校验</td>
</tr>
<tr>
<td>@Valid</td>
<td>对象级联校验,即校验对象中对象的属性</td>
</tr>
</tbody></table>
<p>如：</p>
<p>在User的字段中添加标签</p>
<pre><code>public class User &#123;

    @NotBlank(message = &quot;用户名不能为空&quot;)
    private String users;

    @NotBlank(message = &quot;密码不能为空&quot;)
    @Length(min = 3,max = 8,message = &quot;密码位数为3-8位&quot;)
    private String passwords;

    //省略getter和setter方法
&#125;</code></pre>
<p>在UserController添加test处理方法</p>
<pre><code>@RequestMapping(&quot;/test&quot;)
public String test(@Valid User user,BindingResult result)&#123;
    if(result.hasErrors())&#123;
        for (ObjectError error:result.getAllErrors())&#123;
            System.out.println(error.getDefaultMessage());
        &#125;
    &#125;
    return &quot;test&quot;;
&#125;</code></pre>
<p>test页面和login页面一样（省去拦截器）</p>
<p>部署项目，此时，如果账号密码都为空，直接登录，则输出</p>
<p>用户名不能为空<br>密码位数为3-8位<br>密码不能为空</p>
<h1 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a><strong>RESTful风格</strong></h1><p>RESTful风格是一个资源定位及操作的风格，它既不是标准也不是协议，仅仅只是一种风格，主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>使用RESTful风格可以通过相同的请求方式实现不同的效果，对于相同的请求方式，只要在表单元素中使用不同的method，然后在mvc的控制器相应的处理方法中使用不同的method作出回应，即可实现</p>
<p>原来的请求方式：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/login?name=123&amp;passwords=123">http://localhost:8080/login?name=123&amp;passwords=123</a></p>
<p>使用RESTful风格：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/login/123/123">http://localhost:8080/login/123/123</a></p>
<pre><code>@RequestMapping(&quot;/test/&#123;name&#125;/&#123;passwords&#125;&quot;)
public String login(@PathVariable int name,@PathVariable String passwords)&#123;
    System.out.println(name);
    System.out.println(passwords);
    return &quot;newresult&quot;;
&#125;</code></pre>
<p>newresult页面为新jsp</p>
<pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;登录成功&lt;/h1&gt;
    $&#123;name&#125;
    &lt;br&gt;
    $&#123;passwords&#125;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>还可以使用对应于表单中的请求方式</p>
<pre><code>@RequestMapping(&quot;/test&quot;,method = RequestMethod.POST)
public String login(@PathVariable int name,@PathVariable String passwords)&#123;
    System.out.println(name);
    System.out.println(passwords);
    return &quot;newresult&quot;;
&#125;</code></pre>
<p>此时，若表单中的请求方式为post，则会出现405方法不允许错误</p>
<p>也可以使用基于注解的请求方式</p>
<pre><code>@GetMapping(&quot;/login/&#123;name&#125;/&#123;passwords&#125;&quot;)
public String login(@PathVariable int name, @PathVariable String passwords, Model model)&#123;
    model.addAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;passwords&quot;,passwords);
    return &quot;result&quot;;
&#125;</code></pre>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:zhangakenug@qq.com">leobro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/10/04/SpringMVC/">http://example.com/2020/10/04/SpringMVC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">十二点前要睡觉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/SpringMVC/">SpringMVC</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/04/Servlet/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaWeb之Servlet</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/02/AOP2/"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AOP的API实现及SpringAOP实现原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/10/02/AOP2/" title="AOP的API实现及SpringAOP实现原理"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-02</div><div class="title">AOP的API实现及SpringAOP实现原理</div></div></a></div><div><a href="/2020/10/04/Servlet/" title="JavaWeb之Servlet"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-04</div><div class="title">JavaWeb之Servlet</div></div></a></div><div><a href="/2020/09/22/Spring/" title="Spring简介"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-22</div><div class="title">Spring简介</div></div></a></div><div><a href="/2020/10/12/mvcwrong/" title="MVC Cannot resolve reference to bean 'cacheManager'异常解决"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-12</div><div class="title">MVC Cannot resolve reference to bean 'cacheManager'异常解决</div></div></a></div><div><a href="/2020/09/25/AOP/" title="Spring AOP的两种实现方式（XML、AspectJ）"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">Spring AOP的两种实现方式（XML、AspectJ）</div></div></a></div><div><a href="/2020/09/24/IOC/" title="Spring之控制反转（IOC）"><img class="cover" src="/2020/09/24/IOC/Spring,IOC,java"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-24</div><div class="title">Spring之控制反转（IOC）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><label><input id="switch-comments-btn" type="checkbox"/><span class="slider"></span></label><span class="second-comment"></span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By leobro</div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span></span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const initData = {
      el: '#vcomment',
      appId: 'o54aCaKzTFHPaGNnITdvAfOS-gzGzoHsz',
      appKey: 'jvbQisVTLo4YUOsf7ftzcPAn',
      placeholder: '',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (false) { 
      initData.requiredFields= (''.split(','))
    }

    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机操作系统概述</title>
    <url>/2020/10/28/os/</url>
    <content><![CDATA[<h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a><strong>操作系统引论</strong></h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a><strong>什么是操作系统</strong></h2><p>操作系统（os）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，os的主要作用是管理好这些设备，提高它们的利用率和系统吞吐量，并为用户和应用程序提供一个简单的接口，便于使用。</p>
<p>os是现代计算机系统中最基本和最重要的系统软件，其他的编译程序、管理系统等系统软件，以及大量的应用软件，都直接依赖于操作系统的支持和服务</p>
<h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a><strong>操作系统的目标和作用</strong></h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a><strong>操作系统的目标</strong></h3><p>在计算机上配置操作系统，其主要目标是：</p>
<ul>
<li>方便性</li>
<li>有效性</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
<h3 id="操作系统的使用"><a href="#操作系统的使用" class="headerlink" title="操作系统的使用"></a><strong>操作系统的使用</strong></h3><h4 id="os作为用户与计算机硬件系统之间的接口"><a href="#os作为用户与计算机硬件系统之间的接口" class="headerlink" title="os作为用户与计算机硬件系统之间的接口"></a><strong>os作为用户与计算机硬件系统之间的接口</strong></h4><p>os处于用户与计算机硬件系统之间，用户通过os来使用计算机系统</p>
<p><img src="/2020/10/28/os/osinterface.jpg" alt="osinterface"></p>
<p>由图看出，用户可以通过 命令方式 、 系统调用方式 、 图标-窗口方式 实现与操作系统之间的通信</p>
<h4 id="os作为计算机系统资源的管理者"><a href="#os作为计算机系统资源的管理者" class="headerlink" title="os作为计算机系统资源的管理者"></a><strong>os作为计算机系统资源的管理者</strong></h4><p>在计算机系统中，通常包含许多硬件和软件资源，这些资源可分为：</p>
<ul>
<li><p>处理机</p>
</li>
<li><p>存储器</p>
</li>
<li><p>I/O设备</p>
</li>
<li><p>文件（数据和程序）</p>
</li>
</ul>
<p>相应地，OS的功能也正是对这四类资源进行有效的管理</p>
<h4 id="os实现了对计算机资源的抽象"><a href="#os实现了对计算机资源的抽象" class="headerlink" title="os实现了对计算机资源的抽象"></a><strong>os实现了对计算机资源的抽象</strong></h4><p>对于一台完全无软件的计算机系统，由于它向用户提供的仅是硬件接口，因此，用户必须对物理接口的实现细节有充分的了解。为了方便用户使用I/O设备，在裸机上覆盖一层I/O设备管理软件，由它实现对I/O设备的操作细节，这样，用户就无需关心I/O是如何具体实现的，从而更容易地使用计算机硬件资源</p>
<p>通常把这些覆盖了软件的机器称为扩充机器或虚机器</p>
<h3 id="推动操作系统发展的动力"><a href="#推动操作系统发展的动力" class="headerlink" title="推动操作系统发展的动力"></a><strong>推动操作系统发展的动力</strong></h3><ul>
<li><p>不断提高计算机资源的利用率</p>
</li>
<li><p>方便用户</p>
</li>
<li><p>器件的不断更新</p>
</li>
<li><p>计算机体系结构的不断发展</p>
</li>
<li><p>不断提出新的应用需求</p>
</li>
</ul>
<h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a><strong>操作系统的发展过程</strong></h2><h3 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a><strong>未配置操作系统的计算机系统</strong></h3><p>在第一代计算机中，这些计算机还没配置os，对计算机的全部操作都是由用户采取人工操作方式进行</p>
<p>人机操作方式中严重降低了计算机资源的利用率，更加突出了cpu和I/O设备之间速度不匹配的矛盾</p>
<ul>
<li>人工操作方式</li>
</ul>
<p>用户独占全机，即一台计算机的全部资源由上机用户所独占</p>
<p>CPU等待人工操作。当用户进行装带（卡）、卸带（卡）等人工操作时，CPU及内存等资源是空闲的</p>
<ul>
<li>脱机输入/输出方式</li>
</ul>
<p>程序的输入和输出都是在外围机的控制下完成的，或者说，他们是在脱离主机的的情况下进行的，故称脱机输入/输出</p>
<p>缺点：减少了CPU的空闲时间</p>
<p>优点：提高了I/O速度</p>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a><strong>单道批处理系统</strong></h3><p>为了解决第一代计算机资源利用率的不足，提高资源利用率，尽量保持系统的连续运行，即在处理完一个作业后紧接着处理下一个作业，减少机器的空闲时间，引入了单道批处理系统</p>
<p>单道批处理系统的处理过程为：</p>
<ul>
<li><p>把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序（Monitor)，在它的控制下，使这批作业能一个接一个地连续处理。</p>
</li>
<li><p>由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业</p>
</li>
<li><p>当该作业处理完成时，又把控制权交还给监督程序，再由监督程序把磁带上的第二个作业调入内存。</p>
</li>
</ul>
<p>计算机系统就这样自动地一个作业紧接一个作业地进行处理，直至磁带上的所有作业全部完成。虽然系统对作业的处理是成批进行的，但是内存中始终只保持一道作业。</p>
<p>单道批处理系统的缺点：</p>
<p>最主要的缺点是：系统中的资源得不到充分的利用，因为在内存中只有一道程序，当程序在运行过程中发出I/O请求后，cpu便处于等待状态，必须在I/O请求完成后才能继续运行</p>
<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a><strong>多道批处理系统</strong></h3><p>为了提高资源的利用率和系统吞吐量，引入了多道批处理系统</p>
<p>在多道批处理系统中，用户提交的作业先存放在外存上并排成一个后备队列，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享cpu和系统中的各种资源，由于内存中存在若干个程序，这样便可以在运行程序A时，利用其因I/O操作而暂停执行时的cpu空闲时间再调度程序B，… 使多道程序可以交替执行，保持cpu处于忙碌状态</p>
<p>多道批处理程序的优点：</p>
<ul>
<li><p>资源利用率高</p>
</li>
<li><p>系统吞吐量大</p>
</li>
<li><p>平均周转时间长</p>
</li>
<li><p>无交互能力</p>
</li>
</ul>
<p>多道批处理程序的需要解决的问题：</p>
<ul>
<li><p>处理机争用问题</p>
</li>
<li><p>内存分配和保护问题</p>
</li>
<li><p>I/O设备分配问题</p>
</li>
<li><p>文件的组织和管理问题</p>
</li>
<li><p>作业管理问题</p>
</li>
<li><p>用户与系统间的接口问题</p>
</li>
</ul>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a><strong>分时系统</strong></h3><p>为了满足人机交互的需求，引入了分时系统</p>
<p><strong>人机交互</strong></p>
<p>有时候用户希望能够独占全机并对它进行直接控制，以便能方便地与自己的作业进行交互</p>
<p><strong>共享主机</strong></p>
<p>用户们在共享一台计算机时，每个人都希望能向独占时一样，可以随时与计算机进行交互，而且还不会感觉到其他用户的存在</p>
<p>分时系统是指：在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互的方式使用计算机，共享主机中的资源</p>
<p><strong>分时系统需要解决的问题</strong></p>
<p>为了实现人机交互，必须解决的问题是：实现用户与自己作业的交互</p>
<ul>
<li><p>系统为多个用户提供多个终端</p>
</li>
<li><p>用户在自己的终端上输入命令，系统及时接受并响应，将结果返回给用户</p>
</li>
<li><p>用户根据返回的结果继续输入下一条命令…</p>
</li>
<li><p>系统允许多个用户通过自己的终端输入命令，并及时接受和处理用户的全部命令</p>
</li>
</ul>
<p><strong>系统的及时接受与及时处理</strong></p>
<ul>
<li><p>及时接受<br>要做到及时接受多个用户的命令，需要在系统中配置多路卡，同时，为每个用户终端配置缓冲区，用来暂时存放用户的命令或数据</p>
</li>
<li><p>及时处理<br>要实现人机交互，必须改变原有的批处理系统的运行方式，因为作业是先存放在外存中，而作业是不能在外存中运行的，系统无法做到及时处理，要转用以下方式：</p>
<ul>
<li><p>作业直接进入内存</p>
</li>
<li><p>采用轮转方式运行：如果一个作业独占CPU连续运行，那么其他作业没法运行。为了避免这种情况，引入了时间片概念。一个时间片是一个很短的时间，系统规定了每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在不长的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而使用户的请求的到及时响应。</p>
</li>
</ul>
</li>
</ul>
<p><strong>分时系统的特征</strong></p>
<ul>
<li><p>多路性</p>
</li>
<li><p>独立性</p>
</li>
<li><p>及时性</p>
</li>
<li><p>交互性</p>
</li>
</ul>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a><strong>实时系统</strong></h3><p>实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行，实时系统最主要的特征是将<strong>时间</strong>作为关键参数，具有实时特征</p>
<p><strong>实时系统的类型</strong></p>
<ul>
<li><p>工业控制系统</p>
</li>
<li><p>信息查询系统</p>
</li>
<li><p>多媒体系统</p>
</li>
<li><p>嵌入式系统</p>
</li>
</ul>
<p>** 实时任务的类型**</p>
<ul>
<li>周期性实时任务</li>
</ul>
<p>周期性实时任务是指：外部设备周期性地发出激励信号给计算机，要求计算机按指定周期循环执行，以便周期性地控制外部设备</p>
<ul>
<li>非周期性实时任务</li>
</ul>
<p>非周期性任务无明显的周期性</p>
<p>在这两种任务中，都必须关联着一个截止时间（最后期限）</p>
<ol>
<li>开始截止时间：指某任务必须开始的最迟时间</li>
<li>完成截止时间：指某任务必须在某时间前完成</li>
</ol>
<ul>
<li>硬实时任务</li>
</ul>
<p>硬实时任务是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的后果</p>
<ul>
<li>软实时任务</li>
</ul>
<p>软实时任务也关联着一个截止时间，但并不严格，即若偶尔错过了任务的截止时间，对系统产生的影响也不大</p>
<h3 id="微操作系统"><a href="#微操作系统" class="headerlink" title="微操作系统"></a><strong>微操作系统</strong></h3><ul>
<li><p>单用户单任务操作系统</p>
</li>
<li><p>单用户多任务操作系统</p>
</li>
<li><p>多用户多任务操作系统</p>
</li>
</ul>
<h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a><strong>操作系统的基本特性</strong></h2><p>操作系统的基本特性有：并发、共享、虚拟、异步四个基本特征，其中<strong>并发</strong>和<strong>共享</strong>是多用户OS的两个最基本的特征</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><ul>
<li><p>并行：指两个或多个事件在同一时刻发生</p>
</li>
<li><p>并发：指两个或多个事件在同一个时间间隔发生</p>
</li>
</ul>
<p>在多道程序环境下，并发是指在一段时间内宏观上有多个程序同时运行， 但在单处理系统中，每一时刻却仅有一道程序运行，微观上这些程序只能是分时地交替执行</p>
<p>若计算机系统有多个处理机，这些并发的程序便可以分配到多个处理机上，实现并行执行</p>
<p>3.进程</p>
<p>在一个未引入的进程的系统中，在属于同一个应用程序的多个程序间只能是顺序执行的，为了实现并发，引入了进程，如果为每个程序分别建立一个进程，这些进程间就可以并发执行，并且能极大提高系统资源的利用率和系统的吞吐量</p>
<p>进程：进程是指在系统中能够独立运行并作为资源分配的基本单位，它是由一组机器指令、数据、堆栈等组成的</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a><strong>共享</strong></h3><p>在OS的环境下的资源共享（资源复用）是指系统中的资源可供内存中多个并发执行的进程共同使用</p>
<p>实现资源共享的方式主要有两种：</p>
<ul>
<li>互斥共享方式</li>
</ul>
<p>系统中的某些资源，如打印机、磁带机等，虽然可以提供给多个线程使用，但应规定在一段时间内，只允许一个进程访问该资源。</p>
<p>当进程A要访问某资源时，必须先提出请求，若此时资源空闲，则分配给进程A使用，此后若再有其他进程也要访问该资源，只要A还没用完就必须等待，仅当A进程访问完并释放该资源后，才允许另一进程对该资源进行访问。</p>
<p>这种资源共享方式称为互斥共享方式，这种资源称为临界资源</p>
<ul>
<li>同时访问方式</li>
</ul>
<p>系统中还存在另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问，典型的资源为磁盘设备</p>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a><strong>虚拟</strong></h3><p>在OS中，把通过某种技术将一个物理实体变为若干个逻辑上对应物的功能称为“虚拟”，前者是实的，后者是虚的，是用户感觉上的东西</p>
<p>虚拟技术是通过“空分复用”和“时分复用”技术实现的</p>
<p>1.时分复用</p>
<p>时分复用技术被广泛用来实现虚拟处理机、虚拟设备等。</p>
<p>时分复用技术能提高资源利用率的根本原因在于：它利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用</p>
<p>1.1 虚拟处理机技术</p>
<p>在该技术中，利用多道程序设计技术，为毎道程序创建一个进程，让多道程序并发地执行，以此来分时使用一台处理机。此时虽然系统中只有一台处理机，但它能同时为多个用户服务，使每个终端用户都认为是有一个处理机在专门的为自己服务。亦即，利用多道程序设计技术，把一台物理上的处理机虚拟为多台逻辑上的处理机，在每台逻辑处理机上运行一道程序。我们把用户感觉到的处理机称为虚拟处理器。</p>
<p>1.2 虚拟设备技术</p>
<p>通过虚拟设备技术，将一台物理I\O设备虚拟为多台逻辑上的I\O设备，并允许每个用户占用同一台逻辑上的I\O设备，这样便可使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为在一段时间内允许多个用户同时访问的共享设备。</p>
<p>2.空分复用</p>
<p>空分复用技术是利用存储器的空闲空间分区域存放和允许其他的多道程序，以此来提高内存的利用率。</p>
<p>但是，单纯的空分复用存储器只能提高内存的利用率，并不能实现在逻辑上扩大存储器容量的功能，还必须引入虚拟存储技术。</p>
<p>虚拟存储技术在本质上是实现内存的分时复用</p>
<p>应该指出，时分复用和空分复用中，虚拟设备的平均速度和平均空间等于或低于物理设备的1/n</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a><strong>操作系统的主要功能</strong></h2><h3 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a><strong>处理机管理</strong></h3><p>在传统的多道程序系统中，处理机的分配和运行都是以进程为基本单位的，因而对处理机的管理可归结为对进程的管理</p>
<ul>
<li>进程控制（进程创建与撤销）</li>
</ul>
<p>在多道程序环境下，为使作业能够并发执行，必须为作业创建进程，并为之分配必要的资源。当进程结束后，应该立即撤销进程，以便及时回收资源。</p>
<p>进程控制的主要功能是为作业创建进程、撤销进程、以及控制进程在运行过程中的状态转换</p>
<ul>
<li><p>进程同步：该机制的主要任务是协调多个进程的运行</p>
<ul>
<li><p>进程互斥方式</p>
</li>
<li><p>进程同步方式</p>
</li>
</ul>
</li>
<li><p>进程通信：</p>
</li>
</ul>
<p>进程通信的任务是实现相互合作进程之间的信息交换</p>
<p>当相互合作的进程处于同一计算机系统时，通常采用直接通信方式，由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接受命令从消息队列中去除消息</p>
<ul>
<li><p>调度：</p>
<ul>
<li><p>作业调度</p>
</li>
<li><p>进程调度</p>
</li>
</ul>
</li>
</ul>
<h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a><strong>存储器管理</strong></h3><p>存储器管理的主要任务是为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能从逻辑上扩充内存</p>
<ul>
<li><p>内存分配的主要任务：</p>
<ul>
<li><p>为每道程序分配内存空间，使它们“各得其所”</p>
</li>
<li><p>提高存储器的利用率，尽量减少不可用的内存空间（碎片）</p>
</li>
<li><p>允许正在运行的程序申请附加的内存空间</p>
</li>
</ul>
</li>
<li><p>内存的分配方式：</p>
<ul>
<li><p>静态分配方式：一次性申请空间</p>
</li>
<li><p>动态分配方式：动态申请空间</p>
</li>
</ul>
</li>
<li><p>内存保护</p>
<ul>
<li><p>确保用户程序都仅在自己的内存空间内运行，彼此互不干扰，（设置内存保护机制）</p>
</li>
<li><p>不允许用户程序访问操作系统的程序和数据</p>
</li>
<li><p>不允许用户程序转移到非共享的其他用户程序中去执行</p>
</li>
</ul>
</li>
<li><p>地址映射</p>
</li>
</ul>
<p>将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址</p>
<ul>
<li>内存扩充</li>
</ul>
<p>借助于虚拟存储技术，从逻辑上扩充内存容量。</p>
<p>为了能够在逻辑上扩充内存，系统必须设置内存扩充机制，并实现如下功能：</p>
<ol>
<li>请求调入功能</li>
</ol>
<p>系统允许在仅装入部分用户程序和数据的情况下便能启动该程序运行，在程序运行过程中，若发现继续运行时所需的程序和数据尚未装入内存，则请求OS将所需部分调入内存</p>
<ol start="2">
<li>置换功能</li>
</ol>
<p>若发现在内存中无足够的空间装入需要调度的程序和数据时，系统将内存中一部分暂时不用的程序和数据调至硬盘上腾出空间</p>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a><strong>设备管理</strong></h3><p>设备管理的主要任务如下：</p>
<ol>
<li><p>完成用户提出的I/O请求，为进程分配所需的I/O设备，并完成指定的I/O操作</p>
</li>
<li><p>提高cpu和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备</p>
</li>
</ol>
<ul>
<li>缓冲管理</li>
</ul>
<p>在I/O设备和cpu间引入缓冲，可有效地缓和cpu和I/O设备速度不匹配的矛盾，提高cpu利用率，进而提高系统吞吐量</p>
<ul>
<li>设备分配</li>
</ul>
<p>设备分配的基本任务是根据用户进程的I/O请求、系统的现有资源情况以及按照某种设备分配策略，为之分配其所需的设备</p>
<ul>
<li>设备处理</li>
</ul>
<p>设备处理程序又称为设备驱动程序，基本任务是用于实现cpu和设备控制器间的通信</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><strong>文件管理</strong></h3><ul>
<li><p>文件存储空间的管理</p>
</li>
<li><p>目录管理</p>
</li>
<li><p>文件的读/写管理和保护</p>
</li>
</ul>
<h3 id="向用户提供方便的用户接口"><a href="#向用户提供方便的用户接口" class="headerlink" title="向用户提供方便的用户接口"></a><strong>向用户提供方便的用户接口</strong></h3><p>为方便用户对操作系统的使用，向用户提供用户与操作系统的接口</p>
<ul>
<li><p>用户接口</p>
<ul>
<li><p>用户联机接口：为联机用户提供</p>
</li>
<li><p>脱机用户接口：为批处理作业的用户提供</p>
</li>
<li><p>图形用户接口：提供图形化的操作页面</p>
</li>
</ul>
</li>
<li><p>程序接口</p>
</li>
</ul>
<p>为用户程序在执行过程中提供访问系统资源的唯一路径</p>
<h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a><strong>进程的描述与控制</strong></h1><h2 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a><strong>前趋图和程序执行</strong></h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a><strong>前趋图</strong></h3><p>为了更好的描述程序的顺序和并发执行情况，引入了前趋图，前趋图是一个有向无环图（DAG），它用于描述进程之间执行的先后顺序，图中的每个节点可用来表示一个进程或程序段，乃至一条语句，节点间的有向边表示两个节点间存在偏序关系（前趋关系），此外，每个节点还应该具有一个权重，用来表示该节点所罕有的程序量或程序的执行时间，前趋图中不允许出现环</p>
<ul>
<li><p>初始节点：没有前趋的节点</p>
</li>
<li><p>终止节点：没有后继的节点</p>
</li>
</ul>
<h3 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a><strong>程序顺序执行</strong></h3><p>通常，一个应用程序由若干个程序段组成，每一个程序段完成特定的功能，它们在运行时，总是按照某种特定的次序先后执行，仅当前一程序执行完后才运行后一段程序段</p>
<p>程序顺序执行的特征：</p>
<ul>
<li>顺序性</li>
</ul>
<p>程序按严格的顺序执行</p>
<ul>
<li>封闭性</li>
</ul>
<p>程序运行时独占全机资源，程序执行时不受外界因素影响</p>
<ul>
<li>可再现性</li>
</ul>
<p>只要程序的初始条件和执行时的环境相同，则结果相同</p>
<h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a><strong>程序的并发执行</strong></h3><p>程序的并发执行中，程序间不再有前趋关系，不再是顺序执行</p>
<p>只有没有前趋关系的程序之间才能并发执行</p>
<p>程序并发的特点：</p>
<ul>
<li>间断性</li>
</ul>
<p>程序在并发运行时，由于共享系统资源，导致它们之间产生了相互制约的关系，在执行时具有“走走停停”的特征</p>
<ul>
<li>失去封闭性</li>
</ul>
<p>由于程序并发执行时，程序之间共享系统资源，导致任一程序在运行时的运行环境都会受到其他程序的影响</p>
<ul>
<li>不可再现性</li>
</ul>
<p>由于失去了封闭性，所以也失去了可再现性</p>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a><strong>进程的描述</strong></h2><p>由于程序并发执行时的 <strong>失去封闭性</strong> 和 <strong>不可再现性</strong>，所以导致程序之间时不能并发执行的。</p>
<h3 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a><strong>进程的定义和特征</strong></h3><p>为了能够使程序并发执行，同时对并发执行的程序加以描述和控制，从而引入了进程</p>
<p>为了使并发执行的每个程序都能独立运行，在操作系统中为之配置了一种专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程基本的情况和活动过程，进而控制和管理进程</p>
<p>进程实体包含：</p>
<ul>
<li><p>程序段</p>
</li>
<li><p>数据段</p>
</li>
<li><p>PCB</p>
</li>
</ul>
<p>进程的特征：</p>
<ul>
<li>动态性</li>
</ul>
<p>进程由创建产生，由调度而运行，由撤回而消亡</p>
<ul>
<li><p>并发性</p>
</li>
<li><p>独立性</p>
</li>
</ul>
<p>进程作为独立运行、分配资源的独立单位</p>
<ul>
<li>异步性</li>
</ul>
<p>进程是按异步的方式执行的</p>
<h3 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a><strong>进程的基本状态及转换</strong></h3><ul>
<li><p>进程的三种状态：</p>
<ul>
<li><p>就绪状态</p>
<p>进程已经分配到除了cpu以外的所有必要资源，只要获得cpu的调度就可以执行</p>
</li>
<li><p>执行状态</p>
<p>cpu调度后，进程便开始执行</p>
</li>
<li><p>阻塞状态</p>
<p>当进程执行时发生了某种事件（I/O请求）等暂时无法执行时的状态</p>
<p>当正在执行的进程处于阻塞状态时，此时会引起进程调度，将处理机分配给其他就绪进程</p>
<p>根据阻塞原因的不同，设置多个阻塞队列</p>
</li>
</ul>
</li>
<li><p>三种基本状态的转换：</p>
</li>
</ul>
<p><img src="/2020/10/28/os/staus.jpg" alt="staus"></p>
<ul>
<li><p>创建状态和终止状态：</p>
<ul>
<li><p>创建状态</p>
<p>进程的创建过程：首先由进程申请一个空白PCB，向PCB中填写用于控制和管理进程的信息，然后系统为该进程分配运行时所必需的资源，最后将进程转入就绪状态并插入就绪队列中</p>
<p>进程是由创建产生的，当进程所需的资源尚不能够得到满足时，进程的创建工作失败，进程不能被调度，此时的状态为创建状态</p>
</li>
<li><p>终止状态</p>
<p>进程的终止过程：当进程完成工作或者遇到异常，会进入终止状态，此时进程不能再执行，但其状态码和一些计时统计数据仍会保存在os中，供其他进程收集，一旦其他进程完成了对这些信息的收集，os立即删除该进程（将pcb清零），同时将pcb还给os</p>
</li>
</ul>
</li>
</ul>
<p>引入创建状态和终止状态的五种状态转换图：</p>
<p><img src="/2020/10/28/os/staus.jpg" alt="staus5"></p>
<h3 id="挂起操作和进程状态的转换"><a href="#挂起操作和进程状态的转换" class="headerlink" title="挂起操作和进程状态的转换"></a><strong>挂起操作和进程状态的转换</strong></h3><p>为了方便用户检查自己的程序、方便操作系统进行负荷调节，操作系统引入了挂起操作（内存-&gt;外存）</p>
<p>使用挂起原语（suspend）将某个进程挂起，激活原语（active）激活进程</p>
<ul>
<li><p>引入挂起原语后进程状态的转换</p>
<ul>
<li><p>活动就绪-&gt;静止就绪</p>
<p>当进程处于未被挂起的就绪状态时，称为活动就绪，将处于活动就绪的进程挂起后，称为静止就绪，此时进程不再被调度执行</p>
</li>
<li><p>活动阻塞-&gt;静止阻塞</p>
<p>当进程处于未被挂起的阻塞状态时，称为活动阻塞，阻塞后变成静止阻塞</p>
</li>
<li><p>静止就绪-&gt;活动就绪</p>
<p>active原语激活进程</p>
</li>
<li><p>静止阻塞-&gt;活动阻塞</p>
<p>avtive激活进程</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/28/os/staus7.jpg" alt="staus7"></p>
<h3 id="进程管理中的数据结构"><a href="#进程管理中的数据结构" class="headerlink" title="进程管理中的数据结构"></a><strong>进程管理中的数据结构</strong></h3><p>为了使进程能够独立运行，描述和管理进程的执行，引入了专门的数据结构pcb，pcb作为进程实体的一部分，记录了os所需的，用于描述进程当前情况及管理进程运行的全部信息。</p>
<h3 id="进程控制块PCB的作用"><a href="#进程控制块PCB的作用" class="headerlink" title="进程控制块PCB的作用"></a><strong>进程控制块PCB的作用</strong></h3><ul>
<li>作为独立运行的基本单位的标志</li>
</ul>
<p>系统是通过pcb感知进程的存在的，pcb已经成为进程存在于os的唯一标志</p>
<ul>
<li>实现间断性运行方式</li>
</ul>
<p>当进程因阻塞而暂停运行时，它必须保留运行时的cpu现场信息，再次被调度运行时，还需要恢复其cpu现场信息，从而保证了结果的可再现性</p>
<ul>
<li>提供进程管理需要的信息</li>
</ul>
<p>os总是通过pcb对进程加以控制和管理的</p>
<ul>
<li>提供进程调度所需要的信息</li>
</ul>
<p>只有处于就绪状态的进程才能被调度执行，而在pcb中就提供了进程处于何种状态的信息</p>
<ul>
<li>实现与其他进程的同步与通信</li>
</ul>
<h3 id="pcb中的信息"><a href="#pcb中的信息" class="headerlink" title="pcb中的信息"></a><strong>pcb中的信息</strong></h3><ul>
<li><p>进程标识符：进程标识符永雨唯一标识一个进程</p>
<ul>
<li><p>外部标识符</p>
<p>由创建者提供，可以由数字、字母组成</p>
</li>
<li><p>内部标识符</p>
<p>os为每个进程提供的唯一的一个数字标识符 </p>
</li>
</ul>
</li>
<li><p>处理机状态</p>
</li>
</ul>
<p>处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成，当进程被切换时，处理机的状态信息都必须保存在相应的pcb中，以便再被调度的时候恢复现场信息</p>
<ul>
<li><p>进程调度信息</p>
<ul>
<li><p>进程状态，指明进程的当前状态</p>
</li>
<li><p>进程优先级</p>
</li>
<li><p>进程调度所需的其它信息，它们与所采用的进程调度算法有关</p>
</li>
</ul>
</li>
<li><p>进程控制信息</p>
<ul>
<li><p>程序和数据的地址</p>
</li>
<li><p>进程同步和通信机制</p>
</li>
<li><p>资源清单</p>
</li>
<li><p>链接指针，给岀了本进程所在队列中的下一个进程的PCB的首地址</p>
</li>
</ul>
</li>
</ul>
<h3 id="进程控制块的组织方式"><a href="#进程控制块的组织方式" class="headerlink" title="进程控制块的组织方式"></a><strong>进程控制块的组织方式</strong></h3><ul>
<li><p>线性方式</p>
</li>
<li><p>链接方式</p>
</li>
<li><p>索引方式</p>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h2><p>进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、负责进程运行中的状态转换等功能</p>
<h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a><strong>操作系统内核</strong></h3><p>现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。通常将一些与硬件紧密相关的模块(如中断处理程序等)、各种常用设备的驱动程序以及运行频率较高的模块(如时钟管理、进程调度和许多模块所公用的一些基本操作都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为的OS内核</p>
<p>相对应的是，为了防止OS本身及关键数据(如PCB等)遭受到应用程序有意或无意的破坏，通常也将处理机的执行状态分成系统态和用户态两种</p>
<ul>
<li><p>系统态：又称管态、内核态，它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的OS 都在系统态运行。</p>
</li>
<li><p>用户态：目态，一般情况下，应用程序只能在用户态运行</p>
</li>
</ul>
<h4 id="内核的支撑功能"><a href="#内核的支撑功能" class="headerlink" title="内核的支撑功能"></a><strong>内核的支撑功能</strong></h4><p>该功能是提供给OS其它众多模块所需要的一些基本功能，以便支撑这些模块工作。其中三种最基本的支撑功能是：中断处理、时钟管理和原语操作。</p>
<ul>
<li><p>中断处理。中断处理是内核最基本的功能</p>
</li>
<li><p>时钟管理。时钟管理是内核的一项基本功能</p>
</li>
<li><p>原语操作。原语就是由若干条指令组成的，用于完成一定功能的一个过程，原语是原子操作：要么都做，要么都不做</p>
</li>
</ul>
<h4 id="资源管理功能"><a href="#资源管理功能" class="headerlink" title="资源管理功能"></a><strong>资源管理功能</strong></h4><ul>
<li><p>进程管理：在进程管理中，或者由于各个功能模块的运行频率较高，如进程的调 度与分派、进程的创建与撤消等；或者由于它们为多种功能模块所需要，如用于实现进程 同步的原语、常用的进程通信原语等。通常都将它们放在内核中，以提高OS的性能。</p>
</li>
<li><p>存储器管理：存储器管理软件的运行频率也比较高，如用于实现将用户空间的逻辑地 址变换为内存空间的物理地址的地址转换机构、内存分配与回收的功能模块以及实现内存保 护和对换功能的模块等。通常也将它们放在内核中，以保证存储器管理具有较高的运行速度。</p>
</li>
<li><p>设备管理：由于设备管理与硬件(设备)紧密相关，因此其中很大部分也都设置在内核中</p>
</li>
</ul>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a><strong>进程的创建</strong></h3><h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a><strong>进程的层次结构</strong></h4><p>在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，而把被创建的进程称为子进程</p>
<p>子进程可以继承父进程所拥有的资源，当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程，此外，在撤消父进程时，也必须同时撤消其所有的子进程。</p>
<h4 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a><strong>进程图</strong></h4><p>为了形象地描述一个进程的家族关系而引入了进程图。所谓进程图就是用于描述进程间关系的一棵有向树。</p>
<h4 id="引起创建进程的事件"><a href="#引起创建进程的事件" class="headerlink" title="引起创建进程的事件"></a><strong>引起创建进程的事件</strong></h4><ul>
<li><p>用户登录</p>
</li>
<li><p>作业调度</p>
</li>
<li><p>提供服务</p>
</li>
<li><p>应用请求</p>
</li>
</ul>
<h4 id="进程的创建-1"><a href="#进程的创建-1" class="headerlink" title="进程的创建"></a><strong>进程的创建</strong></h4><p>在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语Creat按下述步骤创建一个新进程</p>
<ol>
<li><p>申请空白pcb，获得进程的唯一标识符</p>
</li>
<li><p>为新进程分配其运行所需的全部资源</p>
</li>
<li><p>初始化pcb</p>
<ol>
<li>初始化标识信息</li>
<li>初始化处理机状态信息</li>
<li>初始化处理机控制信息</li>
</ol>
</li>
<li><p>插入就绪队列</p>
</li>
</ol>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a><strong>进程的终止</strong></h3><h4 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a><strong>引起进程终止的事件</strong></h4><ul>
<li><p>正常结束</p>
</li>
<li><p>异常结束</p>
</li>
<li><p>外界干预</p>
</li>
</ul>
<h4 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a><strong>进程的终止过程</strong></h4><p>如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程：</p>
<ol>
<li>根据被终止进程的标识符，从PCB集合中检索出该进程的PCB,从中读出该进程 的状态</li>
<li>若被终止进程正处于执行状态，立即终止该进程的执行，置调度标志为真，用于指示该进程被终止后应重新进行调度</li>
<li>若该进程还有子孙进程，还应将其所有子孙进程也都予以终止</li>
<li>将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统</li>
<li>将被终止进程(PCB)从所在队列(或链表)中移出，等待其它程序来搜集信息</li>
<li>其他进程搜集完信息后，撤销pcb，归还空白pcb</li>
</ol>
<h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a><strong>进程的阻塞与唤醒</strong></h3><h4 id="引起进程阻塞和唤醒的事件"><a href="#引起进程阻塞和唤醒的事件" class="headerlink" title="引起进程阻塞和唤醒的事件"></a><strong>引起进程阻塞和唤醒的事件</strong></h4><ul>
<li><p>请求共享资源失败</p>
</li>
<li><p>等待某种操作完成</p>
</li>
<li><p>新数据未到达</p>
</li>
<li><p>等待新任务</p>
</li>
</ul>
<h4 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a><strong>进程阻塞过程</strong></h4><p>正在执行的进程，如果发生了上述某事件，进程便通过调用阻塞原语block将自己阻塞，插入到相应的阻塞队列中，最后调度程序重新进行调度。阻塞是进程自身的一种主动行为。</p>
<h4 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a><strong>进程唤醒过程</strong></h4><p>当被阻塞进程所期待的事件发生时，由有关进程调用唤醒原语wakeup，将等待该事件的进程唤醒</p>
<p>wakeup执行的过程是：把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。唤醒是进程的一种被动行为。</p>
<p>block原语和wakeup原语是一对作用刚好相反的原语，必须成对使用，防止阻塞进程再无机会运行</p>
<h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a><strong>进程的挂起与激活</strong></h3><h4 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a><strong>进程的挂起</strong></h4><p>当系统中出现了引起进程挂起的事件时，OS将利用挂起原语suspend将指定进程或处于阻塞状态的进程挂起</p>
<p>suspend的执行过程是：检查并被挂起进程的状态</p>
<p>活动就绪-&gt;静止就绪</p>
<p>活动阻塞状态-&gt;静止阻塞。</p>
<p>为了方便用户或父进程考查该进程的运行情况，而把该进程的PCB复制到某指定的内存区域。</p>
<p>最后，若被挂起的进程正在执行，则转向调度程序重新调度。</p>
<h3 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a><strong>进程的激活</strong></h3><p>当系统中发生激活进程的事件时，OS将利用激活原语active将指定进程激活。激活原语先将进程从外存调入内存，检査并改变该进程的现行状态</p>
<p>静止就绪-&gt;活动就绪</p>
<p>静止阻塞-&gt;活动阻塞。</p>
<p>最后根据相应的调度算法进行进程的调度</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a><strong>进程同步</strong></h2><p>为保证多个进程能有条不紊地运行，在多道程序系统中，必须引入进程同步机制。</p>
<h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a><strong>进程同步的基本概念</strong></h3><p>进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则(或时序)共享系统资源，并能很好地相互合作，从而使程序的执行具有可再现性。</p>
<h4 id="两种形式的制约关系"><a href="#两种形式的制约关系" class="headerlink" title="两种形式的制约关系"></a><strong>两种形式的制约关系</strong></h4><p>在多道程序环境下，对于同处于一个系统中的多个进程，由于它们共享系统中的资源，或为完成某一任务而相互合作，它们之间可能存在着以下两种形式的制约关系：</p>
<ul>
<li>间接相互制约关系</li>
</ul>
<p>对于访问临界资源，必须保证进程间对临界资源的访问是互斥的，对于系统中的这类资源，必须由系统 实施统一分配，即用户在要使用之前，应先提岀申请，而不允许用户进程直接使用。</p>
<ul>
<li>直接相互制约关系</li>
</ul>
<p>某些应用程序，为了完成某任务而建立了两个或多个进程。这些进程将为完成同一项任务而相互合作。进程间的直接制约关系就是源于它们之间的相互合作。如进程A向进程B提供数据，进程AB共享一个缓冲池，如果缓冲池为空，进程B无法拿到数据，此时进程B就将被阻塞</p>
<h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a><strong>临界资源</strong></h4><p>许多硬件资源，如：打印机、磁带机等，都属于临界资源，对临界资源的访问必须采用互斥访问的方式</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a><strong>临界区</strong></h4><p>在每个进程中访问临界资源的那段<strong>代码</strong>称为临界区，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。每个进程在进入临界区之前，应先对欲访问的临界资源进行检査。</p>
<h4 id="同步机制遵循的规则"><a href="#同步机制遵循的规则" class="headerlink" title="同步机制遵循的规则"></a><strong>同步机制遵循的规则</strong></h4><p>为了实现进程互斥地进入自己的临界区，可用软件方法，更多的是在系统中设置专门的同步机构来协调各进程间的运行。所有同步机制都应遵循下述四条准则：</p>
<ul>
<li><p>空闲让进</p>
</li>
<li><p>忙则等待</p>
</li>
<li><p>有限等待</p>
</li>
<li><p>让权等待</p>
</li>
</ul>
<p>当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入 “忙等”状态。</p>
<h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a><strong>硬件同步机制</strong></h3><h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a><strong>关中断</strong></h4><h4 id="Test-and-Set指令"><a href="#Test-and-Set指令" class="headerlink" title="Test-and-Set指令"></a><strong>Test-and-Set指令</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">boolean TS(boolean *lock)&#123;<br>	boolean old;<br>	old &#x3D; *lock;<br>	*lock &#x3D; TRUE;<br>	return old;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a><strong>Swap指令</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void swap(boolean *a,boolean *b)&#123;<br>	boolean t;<br>	t &#x3D; *a;<br>	*a &#x3D; *b;<br>	*b &#x3D; t;<br>&#125;<br><br>do&#123;<br>	key &#x3D; TRUE;<br>	do&#123;<br>		swap(&amp;lock,&amp;key);<br>	&#125;<br>	while(key!&#x3D;FALSE);<br>	lock &#x3D; FALSE;<br>	...<br>&#125;<br>while(TRUE);<br></code></pre></td></tr></table></figure>

<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><strong>信号量机制</strong></h3><h4 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a><strong>整形信号量</strong></h4><p>定义一个整型变量S表示资源数目，通过两个原子操作wait(s) signal(s)访问资源</p>
<p>wait(s) signal(s) 也被称为p、v操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">wait(S)&#123;<br>	while(S&lt;&#x3D;0);<br>	S--;<br>&#125;<br><br>signal(S)&#123;<br>	S++;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a><strong>记录型信号量</strong></h4><p>在整形信号量中，如果信号量S&lt;=0,就会不断进行测试，此时不遵循让权等待的原则，进程处于忙等状态。</p>
<p>在记录型信号量机制中，除了用一个value代表资源数目外，还要增加一个进程链表指针list，用于链接所有等待进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">typedef struct&#123;<br>	int value;<br>	struct process_control_block *list;<br>&#125;semaphore;<br><br>wait(semaphore *s)&#123;<br>	s-&gt;value--;<br>	if(s-&gt;value&lt;0)	block(s-&gt;list);<br>&#125;<br><br>signal(semaphore *s)&#123;<br>	s-&gt;value++;<br>	if(s-&gt;value&lt;&#x3D;0)	wakeup(s-&gt;list);	&#x2F;&#x2F;表示仍有等待进程<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a><strong>AND型信号量</strong></h4><p>前面的两种信号量都是基于进程只共享一个临界资源的情况，在有些场合中，一个进程往往要活的更多的共享资源才能执行任务。</p>
<p>and型信号量的思想是将进程在整个运行过程中需要的所有资源一次性全部分配给进程，待进程使用完后再一起释放，只要有一个资源不能分配给进程，其他所有可以分配的资源也不分配给它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Swait(s1,s2,s3...sn)&#123;<br>	while(TRUE)&#123;<br>		if(s1&gt;&#x3D;1&amp;&amp;s2&gt;&#x3D;1&amp;&amp;...sn&gt;&#x3D;1)&#123;<br>			for(int i&#x3D;1;i&lt;&#x3D;n;i++)	si--;<br>			break;<br>		&#125;<br>		else&#123;<br>			到相应阻塞队列<br>		&#125;<br>	&#125;<br>&#125;<br><br>Ssignal(s1,s2,s3...sn)&#123;<br>	while(TRUE)&#123;<br>		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;<br>			si++;<br>			移除所有可能会获取该资源的进程<br>		&#125;	<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a><strong>信号量集</strong></h4><p>前面的信号量机制中，pv操作仅能对信号量进行加一减一操作，若某个进程需要获取多个某个资源时，要执行多次的加一操作，这是很低效的。</p>
<p>因此，引用了信号量集。同时，为了确保系统的安全性，当进程申请某类临界资源时，在每次分配前，必须测试资源的数量，判断是否大于可分配的下限值ti（?si&gt;=ti)，再决定是否分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>Swait(s1,t1,d1,...,sn,tn,dn);<br><br>Ssignal(s1,d1,...sn,dn);<br><br></code></pre></td></tr></table></figure>

<p>信号量集的特殊情况：</p>
<ul>
<li>Swait(s,d,d)</li>
</ul>
<p>只有一个信号量s，允许每次分配d个，小于d个不分配</p>
<ul>
<li>swait(s,1,1)</li>
</ul>
<p>只有一个信号量s，允许每次分配1个，小于1个不分配，此时相当于记录型信号量</p>
<ul>
<li>swait(s,1,0)</li>
</ul>
<p>s&lt;0则阻止分配，相当于一个开关</p>
<h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a><strong>管程机制</strong></h3><p>代表 共享资源的数据结构 以及 对数据结构实施操作的一组过程 所组成的资源管理程序共同构成了一个操作系统的<strong>资源管理模块</strong>，称之为管程，管程被请求和释放资源的进程所调用，管程相当于一个框架，封装了一些公共的属性和方法。</p>
<p>所有进程要访问临界资源时，都要通过管程间接访问，管程确保每次仅有一个进程进入管程并执行这组过程</p>
<ul>
<li><p>管程的组成：</p>
<ul>
<li><p>管程的名字</p>
</li>
<li><p>局部于管程的共享数据结构说明</p>
</li>
<li><p>对该数据结构进行操作的一组过程</p>
</li>
<li><p>对局部于管程的共享数据设置初始值的语句</p>
</li>
</ul>
</li>
<li><p>管程的特性：</p>
<ul>
<li><p>模块化</p>
</li>
<li><p>抽象</p>
</li>
<li><p>信息掩蔽</p>
</li>
</ul>
</li>
</ul>
<h2 id="经典的进程同步问题"><a href="#经典的进程同步问题" class="headerlink" title="经典的进程同步问题"></a><strong>经典的进程同步问题</strong></h2><ul>
<li><p>生产者-消费者问题</p>
</li>
<li><p>哲学家进餐问题</p>
</li>
<li><p>读者-写者问题</p>
</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><strong>进程通信</strong></h2><p>进程通信是指进程之间的信息交换，由于进程的互斥与同步，需要在进程间交换一定的信息。</p>
<h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a><strong>进程通信的类型</strong></h3><ul>
<li>低级通信机制</li>
</ul>
<p>信号量机制</p>
<ul>
<li><p>高级通信机制</p>
<ul>
<li><p>共享存储器系统</p>
</li>
<li><p>管道通信系统</p>
</li>
<li><p>消息传递系统</p>
</li>
<li><p>客户机-服务器系统</p>
</li>
</ul>
</li>
</ul>
<h4 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a><strong>共享存储器系统</strong></h4><ul>
<li>基于共享数据结构的通信方式</li>
</ul>
<p>在这种通信方式中，要求诸进程公用某些数据结构，借以实现诸进程间的信息交换，操作系统仅提供共享存储器，由程序员负责对公用数据结构的设置及对进程间同步的处理。这种通信方式仅适于传递相对少量的数据，通信效率低下，属于低级通信。</p>
<ul>
<li>基于共享存储区的通信方式</li>
</ul>
<p>为了传输大量数据，在内存中划岀了一块共享存储区域，进程可通过对该共享区的读或写交换信息，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是OS。这种通信方式属于高级通信。需要通信的进程在通信前，先向系统申请获得共享存储区中的一个分区，并将其附加到自己的地址空间中，便可对其中的数据进行正常读、写，读写完成或不再需要时，将其归还给共享存储区。</p>
<h4 id="管道通信系统"><a href="#管道通信系统" class="headerlink" title="管道通信系统"></a><strong>管道通信系统</strong></h4><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。以字符流的形式进行传输。</p>
<p>管道机制必须提供以下三方面的协调能力：</p>
<ul>
<li><p>互斥</p>
</li>
<li><p>同步</p>
</li>
<li><p>确定对方是否存在</p>
</li>
</ul>
<h4 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a><strong>消息传递系统</strong></h4><p>在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递，完成进程间的数据交换。属于高级通信方式。</p>
<p>因其实现方式的不同，可进一步分成两类：</p>
<ul>
<li>直接通信方式</li>
</ul>
<p>发送进程利用OS所提供的发送原语，直接把消息发送给目标 进程</p>
<ul>
<li>间接通信方式</li>
</ul>
<p>是指发送和接收进程，都通过共享中间实体（称为邮箱）的方式进行消息的发送和接收，完成进程间的通信。</p>
<h4 id="客户机-服务器系统"><a href="#客户机-服务器系统" class="headerlink" title="客户机-服务器系统"></a><strong>客户机-服务器系统</strong></h4><p>客户机-服务器系统主要应用于网络环境</p>
<p>其主要的实现方法分为三类：</p>
<ul>
<li><p>套接字（socket）</p>
<ul>
<li><p>基于文件型</p>
</li>
<li><p>基于网络型</p>
</li>
</ul>
</li>
<li><p>远程过程调用和远程方法调用</p>
</li>
</ul>
<h3 id="消息传递系统的实现方式"><a href="#消息传递系统的实现方式" class="headerlink" title="消息传递系统的实现方式"></a><strong>消息传递系统的实现方式</strong></h3><h4 id="直接消息传递系统"><a href="#直接消息传递系统" class="headerlink" title="直接消息传递系统"></a><strong>直接消息传递系统</strong></h4><p>在直接消息传递系统中釆用直接通信方式，即发送进程利用OS所提供的发送命令(原语)，直接把消息发送给目标进程。</p>
<ul>
<li><p>直接通信原语：send、receive</p>
</li>
<li><p>对称寻址方式：</p>
</li>
</ul>
<p>该方式要求发送进程和接收进程都必须以显式方式提供对方的标识符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">send(receiver, message);	发送一个消息给接收进程<br>receive(sender, message); 接收 Sender 发来的消息<br></code></pre></td></tr></table></figure>

<p>对称寻址方式，一旦改变了进程名称，则可能需要改变所有的通信原语</p>
<ul>
<li>非对称寻址方式：</li>
</ul>
<p>在某些情况下，接收进程可能需要与多个发送进程通信，无法事先指定发送进程。对于这样的应用，在接收进程的原语中，不需要命名发送进程，只填写表示源进程的参数，即完成通信后的返回值，而发送进程仍需要命名接收进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">send（P, message）; 发送一个消息给进程P<br>receive （id, message）；接收来自任何进程的消息，id变量可设置为进行通信的发送方 进程id或名字。<br></code></pre></td></tr></table></figure>

<ul>
<li>消息格式</li>
</ul>
<p>对于单机系统环境，一般采用较短的定长消息格式</p>
<p>对于计算机网络环境，一般采用变长的消息格式</p>
<ul>
<li>进程的同步方式</li>
</ul>
<p>在进程之间进行通信时，同样需要有进程同步机制，以使诸进程间能协调通信。</p>
<ul>
<li>通信链路</li>
</ul>
<p>为使在发送进程和接收进程之间能进行通信，必须在两者之间建立一条通信链路。有两种方式建立通信链路。</p>
<p>第一种方式是：由发送进程在通信之前用显式的“建立连接”命令（原语）请求系统为之建立一条通信链路，在链路使用完后拆除链路。这种方式主要用于计算机网络中。</p>
<p>第二种方式是：发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令（原语），系统会自动地为之建立一条链路。这种方式主要用于单机系统中。而根据通信方式的不同，则又可把链路分成两种：①单向通信链路，只允许发送进程向接收进程发送消息，或者相反；②双向通信链路，既允许由进程A向进程B发送消息，也允许进程B同时向进程A发送消息。</p>
<h4 id="信箱通信"><a href="#信箱通信" class="headerlink" title="信箱通信"></a><strong>信箱通信</strong></h4><p>信箱通信属于间接通信方式，即进程之间的通信，需要通过某种中间实体(如共享数据结构等)来完成。</p>
<p>该实体建立在随机存储器的公用缓冲区上，用来暂存发送进程发送给目标进程的消息，接收进程可以从该实体中取岀发送进程发送给自己的消息，通常把这种中间实体称为邮箱(或信箱）。每个邮箱都有一个唯一的标识符。</p>
<p>消息在邮箱中可以安全地保存，只允许核准的目标用户随时读取。因此，利用邮箱通信方式既可实现实时通信，又可实现非实时通信。</p>
<ul>
<li><p>信箱的结构</p>
<ul>
<li><p>信箱头</p>
<p>存放有关信箱的描述信息，如信箱标识符、信箱的拥有者、信箱口令、信箱的空格数</p>
</li>
<li><p>信箱体</p>
<p>由若干个可以存放消息(或消息头)的信箱格组成，信箱格的数目以及每格的大小是在创建信箱时确定的。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>信箱通信原语</p>
<ul>
<li><p>信箱创建和撤销原语</p>
</li>
<li><p>消息的放松与接受</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Send(mailbox, message); 将一个消息发送到指定邮箱<br>Receive(mailbox, message);从指定邮箱中接收一个消息<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>信箱类型</p>
<ul>
<li><p>私用邮箱</p>
</li>
<li><p>公用邮箱</p>
</li>
<li><p>共享邮箱</p>
</li>
</ul>
</li>
<li><p>发送进程和接受进程间的关系</p>
<ul>
<li><p>一对一</p>
</li>
<li><p>多对一</p>
</li>
<li><p>一对多</p>
<p>发送进程通过广播的方式向接受者发送信息</p>
</li>
<li><p>多对多</p>
</li>
</ul>
</li>
</ul>
<h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a><strong>线程的基本概念</strong></h2><h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a><strong>线程的引入</strong></h3><p>在OS中引入进程的目的是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，而在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。</p>
<h3 id="程序并发执行时所付出的时空开销"><a href="#程序并发执行时所付出的时空开销" class="headerlink" title="程序并发执行时所付出的时空开销"></a><strong>程序并发执行时所付出的时空开销</strong></h3><p>为使程序能并发执行，系统必须进行以下的一系列操作：</p>
<ul>
<li><p>创建进程，为它分配其所必需的、除处理机以外的所有资源、建立相应的PCB；</p>
</li>
<li><p>撤消进程，系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB；</p>
</li>
<li><p>进程切换，对进程进行上下文切换时，需要保留当前进程的CPU环境，设置新选中进程的CPU环境，因而须花费不少的处理机时间。 </p>
</li>
</ul>
<p>据此可知，由于进程是一个资源的拥有者，因而在创建、撤消和切换中，系统必须为之付岀较大的时空开销。</p>
<p>而为了能使多个程序更好地并发执行，同时又尽量减少系统的开销，要设法将进程的上述两个属性分开，由OS分开处理，亦即并不把作为调度和分派的基本单位也同时作为拥有资源的单位，以做到“轻装上阵”，而对于拥有资源的基本单位，又不对之施以频繁的切换，这样才引入了线程的概念</p>
<h3 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a><strong>进程与线程的比较</strong></h3><ul>
<li>调度的基本单位</li>
</ul>
<p>在传统的OS中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次被调度时，都需要进行上下文切换，开销较大。而在引入线程的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会 引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然就会引起进程的切换。</p>
<ul>
<li>并发性</li>
</ul>
<p>在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，甚至还允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。这使得OS具有更好的并发性</p>
<ul>
<li>拥有资源</li>
</ul>
<p>进程可以拥有资源，并作为系统中拥有资源的一个基本单位。然而，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源。</p>
<ul>
<li>独立性</li>
</ul>
<p>进程中的线程共享进程的内存地址空间和资源</p>
<ul>
<li>系统开销</li>
</ul>
<p>在创建或撤消进程时，系统都要为之分配和回收进程控制块、分配或回收其它资源，OS为此所付出的开销，明显大于线程创建或撤消时所付出的开销</p>
<ul>
<li>支持多处理机系统</li>
</ul>
<p>在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行</p>
<h3 id="线程的状态和线程控制块"><a href="#线程的状态和线程控制块" class="headerlink" title="线程的状态和线程控制块"></a><strong>线程的状态和线程控制块</strong></h3><ul>
<li><p>线程的状态</p>
<ul>
<li><p>就绪状态</p>
</li>
<li><p>执行状态</p>
</li>
<li><p>阻塞状态</p>
</li>
</ul>
</li>
<li><p>线程控制块</p>
</li>
</ul>
<p>如同进程控制块一样，线程控制块中也有和进程控制块中相应的内容</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a><strong>线程的实现</strong></h2><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a><strong>线程的实现方式</strong></h3><ul>
<li><p>内核支持线程KST</p>
</li>
<li><p>用户级线程ULT</p>
</li>
<li><p>组合方式</p>
</li>
</ul>
<h3 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a><strong>线程的创建和终止</strong></h3><ul>
<li>线程的创建</li>
</ul>
<p>在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用。</p>
<ul>
<li>线程的终止</li>
</ul>
<p>当一个线程完成了自己的任务后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数（或系统调用）对它执行终止操作。但有些线程（主要是系统线程），它们一旦被建立起来之后，便一直运行下去而不被终止。</p>
<p>在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。</p>
<p>虽已被终止但尚未释放资源的线程仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用线程须调用一条被称为“等待线程终止”的连接命令来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令，试图与指定线程连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后，才能实现它与调用者线程的连接并继续执行：若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。</p>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a><strong>处理机调度与死锁</strong></h1><p>在多道程序环境下，内存中存在着多个进程，其数目往往多于处理机数目。这就要求系统能按某种算法，动态地将处理机分配给处于就绪状态的一个进程，使之执行。分配处理机的任务是由处理机调度程序完成的。</p>
<p>在多道程序系统中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度</p>
<h2 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a><strong>处理机调度的层次和调度算法的目标</strong></h2><h3 id="处理机调度层次（三层）"><a href="#处理机调度层次（三层）" class="headerlink" title="处理机调度层次（三层）"></a><strong>处理机调度层次（三层）</strong></h3><ul>
<li>高级调度</li>
</ul>
<p>高级调度又称长程调度或作业调度，它的调度对象是作业。其主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列。高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度。</p>
<ul>
<li>低级调度</li>
</ul>
<p>低级调度又称为进程调度或短程调度，其所调度的对象是进程(或内核级线程)。其主要功能是，根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必须配置这级调度。</p>
<ul>
<li>中级调度</li>
</ul>
<p>中级调度又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐量。为此，应把那些暂时不能运行的进程，调至外存等待，此时进程的状态称为就绪驻外存状态(或挂起状态)。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态， </p>
<p>上述三种调度中，进程调度的运行频率最高，作业调度的运行频率最低，中级调度的运行频率介于两者中间</p>
<h3 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a><strong>处理机调度算法的目标</strong></h3><ul>
<li><p>处理机调度算法的共同目标</p>
<ul>
<li><p>提高资源利用率：cpu利用率 = cpu有效工作时间/（cpu有效工作时间+cpu等待空闲时间）</p>
</li>
<li><p>公平性：防止饥饿现象</p>
</li>
<li><p>平衡性：保持系统资源的使用平衡</p>
</li>
<li><p>策略强制执行：如安全策略</p>
</li>
</ul>
</li>
<li><p>批处理系统的目标</p>
<ul>
<li><p>平均周转时间短</p>
<p>周转时间：指作业被提交给系统开始，到作业完成为之的这段时间间隔，分为：</p>
<ul>
<li><p>作业在外存后备队列的等待时间</p>
</li>
<li><p>进程在就绪队列等待进程调度的时间</p>
</li>
<li><p>进程在cpu执行的时间</p>
</li>
<li><p>进程等待i/o操作完成的时间</p>
</li>
</ul>
<p>平均周转时间：∑Ti/n</p>
<p>带权周转时间：（∑Ti/Ts）/n，Ti：作业周转时间，Ts：作业获得的服务时间</p>
</li>
<li><p>系统吞吐量高</p>
<p>吞吐量：单位时间内完成的作业数，与批处理作业的平均作业长度有关</p>
</li>
<li><p>处理机利用率高</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger</title>
    <url>/2020/11/11/swagger/</url>
    <content><![CDATA[<h1 id="什么是swagger"><a href="#什么是swagger" class="headerlink" title="什么是swagger"></a><strong>什么是swagger</strong></h1><p>在前后端分离的时代，前后端的唯一交流方式就是接口文档，将一些请求地址、请求方法、请求参数、返回内容等等写入文档中，便于前后端之间的对接，接口文档变成了前后端开发人员联系的纽带。</p>
<p>而swagger是一个简单但功能强大的API表达工具，能够自动生成和同步接口，使前后端之间的联系变得更加简单</p>
<h1 id="springboot集成swagger2"><a href="#springboot集成swagger2" class="headerlink" title="springboot集成swagger2"></a><strong>springboot集成swagger2</strong></h1><p>导入依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br><br>&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>配置swagger 配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>@EnableSwagger2<br>public class swaggerConfig &#123;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>访问：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="/2020/11/11/swagger/swagger.jpg" alt="swagger"></p>
<h1 id="配置swagger信息"><a href="#配置swagger信息" class="headerlink" title="配置swagger信息"></a><strong>配置swagger信息</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>@EnableSwagger2<br>public class swaggerConfig &#123;<br><br>&#x2F;&#x2F;    docket配置了swagger<br>    @Bean<br>    public Docket getDocket()&#123;<br><br>        return new Docket(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo());<br><br>    &#125;<br><br>    private ApiInfo apiInfo()&#123;<br><br>&#x2F;&#x2F;        作者信息<br>        Contact contact &#x3D; new Contact(&quot;十二点前要睡觉&quot;,&quot;https:&#x2F;&#x2F;zleo-bug.github.io&#x2F;&quot;,&quot;abc@qq.com&quot;);<br><br>        return new ApiInfo(<br><br>                &quot;API文档&quot;,<br>                &quot;文档描述信息description&quot;,<br>                &quot;版本号version&quot;,<br>                &quot;termsOfServiceUrl&quot;,<br>                contact,<br>                &quot;Apache 2.0&quot;,<br>                &quot;http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0&quot;,<br>                new ArrayList()<br><br>        );<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="swagger配置扫描接口"><a href="#swagger配置扫描接口" class="headerlink" title="swagger配置扫描接口"></a><strong>swagger配置扫描接口</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Bean<br>public Docket getDocket()&#123;<br><br>    return new Docket(DocumentationType.SWAGGER_2)<br>            .apiInfo(apiInfo())<br>            .select()<br>&#x2F;&#x2F;                RequestHandlerSelectors:配置要扫描接口的方式<br>&#x2F;&#x2F;                basePackage:扫描包下的接口<br>&#x2F;&#x2F;                any():全部扫描<br>&#x2F;&#x2F;                none():全都不扫描<br>&#x2F;&#x2F;                withClassAnnotation: 扫描类上的注解<br>&#x2F;&#x2F;                withMethodAnnotation：扫描方法上的注解<br>            .apis(RequestHandlerSelectors.basePackage(&quot;com.swagger.controller&quot;))<br>&#x2F;&#x2F;                扫描指定路径<br>            .paths(PathSelectors.ant(&quot;&#x2F;hello&quot;))<br>            .build();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="选择要显示swagger的配置环境"><a href="#选择要显示swagger的配置环境" class="headerlink" title="选择要显示swagger的配置环境"></a><strong>选择要显示swagger的配置环境</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Bean<br>public Docket getDocket(Environment environment)&#123;<br><br>&#x2F;&#x2F;      设置要显示swagger的环境<br>    Profiles profiles &#x3D; Profiles.of(&quot;dev&quot;,&quot;pro&quot;);<br><br>&#x2F;&#x2F;        通过environment.acceptsProfiles判断当前环境是否处于设置的环境中<br>    boolean flag &#x3D; environment.acceptsProfiles(profiles);<br><br>    if(!flag)   return null;<br><br>    return new Docket(DocumentationType.SWAGGER_2)<br>            .apiInfo(apiInfo())<br>            .select()<br>&#x2F;&#x2F;                RequestHandlerSelectors:配置要扫描接口的方式<br>&#x2F;&#x2F;                basePackage:扫描包下的接口<br>&#x2F;&#x2F;                any():全部扫描<br>&#x2F;&#x2F;                none():全都不扫描<br>&#x2F;&#x2F;                withClassAnnotation: 扫描类上的注解<br>&#x2F;&#x2F;                withMethodAnnotation：扫描方法上的注解<br>            .apis(RequestHandlerSelectors.basePackage(&quot;com.swagger.controller&quot;))<br>&#x2F;&#x2F;                扫描指定路径<br>            .paths(PathSelectors.ant(&quot;&#x2F;hello&quot;))<br>            .build();<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a><strong>分组</strong></h1><p>设置多个Docket + groupName 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Bean<br>public Docket getDocket(Environment environment)&#123;<br><br>&#x2F;&#x2F;      设置要显示swagger的环境<br>    Profiles profiles &#x3D; Profiles.of(&quot;dev&quot;,&quot;pro&quot;);<br><br>&#x2F;&#x2F;        通过environment.acceptsProfiles判断当前环境是否处于设置的环境中<br>    boolean flag &#x3D; environment.acceptsProfiles(profiles);<br><br>    if(!flag)   return null;<br><br>    return new Docket(DocumentationType.SWAGGER_2)<br>            .apiInfo(apiInfo())<br>            .groupName(&quot;A&quot;)<br>            .select()<br>&#x2F;&#x2F;                RequestHandlerSelectors:配置要扫描接口的方式<br>&#x2F;&#x2F;                basePackage:扫描包下的接口<br>&#x2F;&#x2F;                any():全部扫描<br>&#x2F;&#x2F;                none():全都不扫描<br>&#x2F;&#x2F;                withClassAnnotation: 扫描类上的注解<br>&#x2F;&#x2F;                withMethodAnnotation：扫描方法上的注解<br>            .apis(RequestHandlerSelectors.basePackage(&quot;com.swagger.controller&quot;))<br>&#x2F;&#x2F;                扫描指定路径<br>            .paths(PathSelectors.ant(&quot;&#x2F;hello&quot;))<br>            .build();<br><br>&#125;<br><br>@Bean<br>public Docket getDocket1()&#123;<br><br>    return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;B&quot;);<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="扫描实体类-和-给实体类加文档注释"><a href="#扫描实体类-和-给实体类加文档注释" class="headerlink" title="扫描实体类 和 给实体类加文档注释"></a><strong>扫描实体类 和 给实体类加文档注释</strong></h1><p>pojo类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@ApiModel(&quot;用户类&quot;)<br>public class User &#123;<br><br>    @ApiModelProperty(&quot;用户名&quot;)<br>    private String username;<br><br>    @ApiModelProperty(&quot;密码&quot;)<br>    private String password;<br><br>    public String getUsername() &#123;<br>        return username;<br>    &#125;<br><br>    public void setUsername(String username) &#123;<br>        this.username &#x3D; username;<br>    &#125;<br><br>    public String getPassword() &#123;<br>        return password;<br>    &#125;<br><br>    public void setPassword(String password) &#123;<br>        this.password &#x3D; password;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>controller:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;    只要接口中返回值存在实体类，docket扫描了这个包下的接口，实体类就会被扫描到swagger的model中<br><br>@ApiOperation(&quot;这个接口是用来干嘛的&quot;)<br>@RequestMapping(&quot;&#x2F;user&quot;)<br>public User user(@ApiParam(&quot;这个参数是用来干嘛的&quot;) String name)&#123;<br><br>    return new User();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>@ApiModel：注释实体类</p>
<p>@ApiModelProperty：注释属性</p>
<p>@ApiOperation：注释方法</p>
<h1 id="在swagger中测试"><a href="#在swagger中测试" class="headerlink" title="在swagger中测试"></a><strong>在swagger中测试</strong></h1><p><img src="/2020/11/11/swagger/test.jpg" alt="test"></p>
<p><img src="/2020/11/11/swagger/result.jpg" alt="result"></p>
]]></content>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>java安全框架与springboot的整合</title>
    <url>/2020/11/07/springsecurity/</url>
    <content><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a><strong>SpringSecurity</strong></h1><h2 id="什么是SpringSecurity"><a href="#什么是SpringSecurity" class="headerlink" title="什么是SpringSecurity"></a><strong>什么是SpringSecurity</strong></h2><p>SpringSecurity是针对spring项目的一个身份验证和权限认证的一个框架（拦截器），可以实现强大的web安全控制。对于安全控制，只要导入 spring-boot-starter-security 依赖，进行少量配置，就可以实现强大的安全管理。</p>
<h2 id="SpringSecurity的使用"><a href="#SpringSecurity的使用" class="headerlink" title="SpringSecurity的使用"></a><strong>SpringSecurity的使用</strong></h2><p>导入SpringSecurity依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-security --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>与SpringSecurity相关的重要类和注解如下：</p>
<ul>
<li><p>WebSecurityConfigurerAdapter 自定义Security策略</p>
</li>
<li><p>AuthenticationMangerBuilder 自定义认证策略</p>
</li>
<li><p>HttpSecurity：对特定的http请求基于安全考虑进行配置</p>
</li>
<li><p>@enableWebSecurity 开启websecurity</p>
</li>
</ul>
<p>要使用SpringSecurity，只需要写一个配置类，继承WebSecurityConfigurerAdapter类并重写相应的configure方法，最后在配置类上加上注解<code>@EnableWebSecurity</code>即可</p>
<h2 id="用户的登录和注销"><a href="#用户的登录和注销" class="headerlink" title="用户的登录和注销"></a><strong>用户的登录和注销</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;        跳转登陆页面<br>    http.formLogin();<br><br>&#x2F;&#x2F;        注销功能：自动删除所有session，还能指定logout后跳转的页面<br><br>    http.logout().logoutSuccessUrl(&quot;&#x2F;&quot;);<br></code></pre></td></tr></table></figure>

<p><img src="/2020/11/07/springsecurity/login1.jpg" alt="login1"></p>
<p><img src="/2020/11/07/springsecurity/login2.jpg" alt="login2"></p>
<p><img src="/2020/11/07/springsecurity/logout.jpg" alt="logout"></p>
<h2 id="用户的认证和授权"><a href="#用户的认证和授权" class="headerlink" title="用户的认证和授权"></a><strong>用户的认证和授权</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@EnableWebSecurity<br>public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;<br><br>&#x2F;&#x2F;    授权<br>    @Override<br>    protected void configure(HttpSecurity http) throws Exception &#123;<br><br>        http.authorizeRequests().antMatchers(&quot;&#x2F;&quot;).permitAll()<br>                .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)<br>                .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)<br>                .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);<br><br>        http.formLogin().loginPage(&quot;&#x2F;tologin&quot;).usernameParameter().passwordParameter();<br><br>    &#125;<br><br>&#x2F;&#x2F;    认证<br>    @Override<br>    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;<br><br>        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())<br>                .withUser(&quot;admin&quot;).password(new BCryptPasswordEncoder().encode(&quot;111111&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)<br>                .and()<br>                .withUser(&quot;admin1&quot;).password(new BCryptPasswordEncoder().encode(&quot;111111&quot;)).roles(&quot;vip1&quot;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>authorizeRequests().antMatchers()方法的作用是为请求路径赋予权限，hasRole()方法表示用户拥有某个权限才能不被拦截</p>
<p>http.formLogin().loginPage(“/tologin”)方法的作用是如果有拦截的请求则自动跳转到自定义的登陆首页</p>
<p>usernameParameter().passwordParameter()是表单中的字段name</p>
<p>auth.inMemoryAuthentication()</p>
<p>方法的作用是对内存中的用户进行认证</p>
<p>passwordEncoder(new BCryptPasswordEncoder())的作用是密码编码，BCryptPasswordEncoder()是一种密码编码方式，如果不配置密码编码方式，则SpringSecurity会报错</p>
<p>withUser()、password() 方法的作用是认证用户，roles() 的作用是为用户赋予权限</p>
<p>认证的方式：</p>
<ul>
<li><p>inMemoryAuthentication()</p>
</li>
<li><p>jdbcAuthentication()</p>
</li>
</ul>
<p><strong>jdbcAuthentication()：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>auth.jdbcAuthentication()<br>                .dataSource(dataSource)<br>                .usersByUsernameQuery(&quot;select username,password,enabled from users WHERE username&#x3D;?&quot;)<br>                .authoritiesByUsernameQuery(&quot;select username,authority from authorities where username&#x3D;?&quot;)<br>                .passwordEncoder(new BCryptPasswordEncoder());<br></code></pre></td></tr></table></figure>

<h2 id="RememberMe功能"><a href="#RememberMe功能" class="headerlink" title="RememberMe功能"></a><strong>RememberMe功能</strong></h2><p>SpringSecurity实现该功能非常简单，只需要在配置类中添加一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@EnableWebSecurity<br>public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;<br><br><br>    @Override<br>    protected void configure(HttpSecurity http) throws Exception &#123;<br><br><br>        http.rememberMe().rememberMeParameter(&quot;rememberme&quot;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中rememberme为html中选择框的name</p>
<h1 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a><strong>shiro</strong></h1><p>shiro是一个强大且易用的Java安全框架,提供了认证、授权、加密和会话管理等功能。shiro都可以轻松为其提供全面的安全管理服务，相比业内spring security 而言，shiro显得更加小巧，应用也更加广泛。</p>
<p><img src="/2020/11/07/springsecurity/shiro.jpg" alt="shiro"></p>
<p>shiro的三大核心组件：</p>
<ul>
<li>Subject</li>
</ul>
<p>认证主体(当前用户)，代表了需要认证的内容，用户通过表单登陆后，Controller通过SecurityUtils.getSubject()方法获得当前的用户对象</p>
<ul>
<li>Shiro SecurityManager</li>
</ul>
<p>shiro的核心，所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager，所有具体的交互都通过 SecurityManager 进行控制</p>
<ul>
<li>Realm：</li>
</ul>
<p>连接 Shiro 和具体应用的桥梁，Shiro 从Realm 获取安全数据，SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法，相当于是DataSource</p>
<p>springboot配置shiro，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class shiroConfig &#123;<br><br><br>&#x2F;&#x2F;    shiroFilterFactoryBean<br><br>    @Bean<br>    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;manager&quot;) DefaultWebSecurityManager manager)&#123;<br><br>         ...<br><br>    &#125;<br><br>&#x2F;&#x2F;    DeafultWebSecurityManager<br><br>    @Bean(name &#x3D; &quot;manager&quot;)<br>    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) userRealm userRealm)&#123;<br><br>        DefaultWebSecurityManager securityManager &#x3D; new DefaultWebSecurityManager();<br><br>        securityManager.setRealm(userRealm);<br><br>        return securityManager;<br><br>    &#125;<br><br><br>&#x2F;&#x2F;    realm对象 需要自定义<br><br>    @Bean<br>    public userRealm userRealm()&#123;<br><br>        return new userRealm();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class userRealm extends AuthorizingRealm &#123;<br><br>    @Autowired<br>    userService userService;<br><br>&#x2F;&#x2F;    授权<br>    @Override<br>    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;<br><br>        ...<br><br>    &#125;<br><br><br>&#x2F;&#x2F;    认证<br>    @Override<br>    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;<br><br>        ...<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="shiro实现登录拦截"><a href="#shiro实现登录拦截" class="headerlink" title="shiro实现登录拦截"></a><strong>shiro实现登录拦截</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Bean<br>public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;manager&quot;) DefaultWebSecurityManager manager)&#123;<br><br>     ...<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>ShiroFilterFactoryBean是实现登陆拦截的核心，它是shiro中的过滤器，可以自定义很多拦截配置</p>
<p><img src="/2020/11/07/springsecurity/bean.jpg" alt="bean"></p>
<p>配置拦截的重要方法是setFilterChainDefinitionMap(hashmap)方法，参数中传入一个HashMap，HashMap中存放着代表（url，权限）的键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">anon：无需验证就可访问<br><br>authc：必须验证才能访问<br><br>user：必须有 remember me 功能才能使用<br><br>perms：拥有某些资源才能访问<br><br>role：拥有某个权限才能访问<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>ShiroFilterFactoryBean bean &#x3D; new ShiroFilterFactoryBean();<br><br>bean.setSecurityManager(manager);<br><br>LinkedHashMap&lt;String, String&gt; filterMap &#x3D; new LinkedHashMap&lt;&gt;();<br><br>filterMap.put(&quot;&#x2F;add&quot;,&quot;authc&quot;);<br><br>filterMap.put(&quot;&#x2F;update&quot;,&quot;authc&quot;);<br><br>filterMap.put(&quot;&#x2F;add&quot;,&quot;perms[add]&quot;);<br><br>filterMap.put(&quot;&#x2F;update&quot;,&quot;perms[update]&quot;);<br><br>bean.setFilterChainDefinitionMap(filterMap);<br><br>return bean;<br></code></pre></td></tr></table></figure>

<p>在过滤器中，还可以自定义拦截的页面、未授权页面 ….</p>
<h2 id="实现用户验证"><a href="#实现用户验证" class="headerlink" title="实现用户验证"></a><strong>实现用户验证</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Override<br>protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现用户的验证，要交给userRealm（底层）中的doGetAuthenticationInfo()方法负责</p>
<p>用户在表单登陆，Controller通过SecurityUtils.getSubject()获得当前对象，通过new UsernamePasswordToken(username,password)获得token doGetAuthenticationInfo获得 token ，最后再通过subject.login(token)进行验证，此时会进入userRealm中的方法进行验证</p>
<p>在Realm中的doGetAuthenticationInfo方法中，对用户名和密码进行验证，其中 对密码的验证 是shiro已经帮我们做好了的，它在方法中返回new SimpleAuthenticationInfo((principle),user.getPassword(),(realmName)) 对密码进行验证</p>
<p>第一个参数代表用户信息，可以通过subject.getPrincipal()方法获取</p>
<p>SimpleAuthenticationInfo 密码判断（shiro已经帮我们做好了对密码判断的工作）</p>
<h2 id="实现授权"><a href="#实现授权" class="headerlink" title="实现授权"></a><strong>实现授权</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Override<br>protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在shiro的过滤链的哈希表中，键值对（url，perms[]）表示拥有了perms[]中指定的资源才可以访问url，对url进行访问的权限限制是在过滤链中进行，而授予用户权限是在realm中的doGetAuthorizationInfo方法中进行的</p>
<p>在该方法中，可以通过subject.getPrincipal()方法获得当前对象（认证方法中传入的参数），通过SimpleAuthorizationInfo对象中的addStringPermission方法，为当前用户添加权限。</p>
<h2 id="shiro整合thymeleaf"><a href="#shiro整合thymeleaf" class="headerlink" title="shiro整合thymeleaf"></a><strong>shiro整合thymeleaf</strong></h2><h2 id="springboot整合mybatis、shiro"><a href="#springboot整合mybatis、shiro" class="headerlink" title="springboot整合mybatis、shiro"></a><strong>springboot整合mybatis、shiro</strong></h2><p>数据库表：</p>
<p><img src="/2020/11/07/springsecurity/db.jpg" alt="db"></p>
<p>依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependencies&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>    &lt;&#x2F;dependency&gt;<br><br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;<br>        &lt;optional&gt;true&lt;&#x2F;optional&gt;<br>    &lt;&#x2F;dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;<br>        &lt;scope&gt;test&lt;&#x2F;scope&gt;<br>        &lt;exclusions&gt;<br>            &lt;exclusion&gt;<br>                &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;<br>                &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;<br>            &lt;&#x2F;exclusion&gt;<br>        &lt;&#x2F;exclusions&gt;<br>    &lt;&#x2F;dependency&gt;<br><br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;<br>        &lt;version&gt;1.5.3&lt;&#x2F;version&gt;<br>    &lt;&#x2F;dependency&gt;<br><br><br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;<br>        &lt;version&gt;2.1.3&lt;&#x2F;version&gt;<br>    &lt;&#x2F;dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;<br>        &lt;version&gt;8.0.19&lt;&#x2F;version&gt;<br>    &lt;&#x2F;dependency&gt;<br><br><br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.thymeleaf&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;thymeleaf-spring5&lt;&#x2F;artifactId&gt;<br>    &lt;&#x2F;dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;thymeleaf-extras-java8time&lt;&#x2F;artifactId&gt;<br>    &lt;&#x2F;dependency&gt;<br><br>    &lt;dependency&gt;<br>        &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;<br>        &lt;version&gt;1.2.12&lt;&#x2F;version&gt;<br>    &lt;&#x2F;dependency&gt;<br><br><br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.thymeleaf&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;thymeleaf-spring5&lt;&#x2F;artifactId&gt;<br>    &lt;&#x2F;dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;thymeleaf-extras-java8time&lt;&#x2F;artifactId&gt;<br>    &lt;&#x2F;dependency&gt;<br><br><br>&lt;&#x2F;dependencies&gt;<br></code></pre></td></tr></table></figure>

<p>User类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>public class User &#123;<br><br>    private String username;<br><br>    private String password;<br><br>    private String permission;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>userMapper:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Mapper<br>@Repository<br>public interface userMapper &#123;<br><br>    public User queryByUserName(String name);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>resources/mybatis/mapper:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE mapper<br>        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;<br>        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;<br>&lt;!--namespace: 绑定一个mapper接口 包名.--&gt;<br>&lt;mapper namespace&#x3D;&quot;springbootshiro.mapper.userMapper&quot;&gt;<br><br><br>    &lt;select id&#x3D;&quot;queryByUserName&quot; resultType&#x3D;&quot;user&quot;&gt;<br>        select * from users where username &#x3D; #&#123;username&#125;;<br>    &lt;&#x2F;select&gt;<br><br>&lt;&#x2F;mapper&gt;<br></code></pre></td></tr></table></figure>


<p>application.yaml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">spring:<br>  datasource:<br>    username: root<br>    password: 111111<br>    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC<br>    driver-class-name: com.mysql.cj.jdbc.Driver<br>    <br>mybatis:<br>  type-aliases-package: springbootshiro.pojo<br>  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml<br></code></pre></td></tr></table></figure>

<p>userService:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface userService &#123;<br><br>    public User queryByUserName(String name);<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>userServiceImpl:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class userServiceImpl implements userService&#123;<br><br>    @Autowired<br>    userMapper userMapper;<br><br>    @Override<br>    public User queryByUserName(String name) &#123;<br>        return userMapper.queryByUserName(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>userController:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class userController &#123;<br><br>    @Autowired<br>    userService userService;<br><br>    @RequestMapping(&quot;&#x2F;login&quot;)<br>    public String login(String username, String password, Model model)&#123;<br><br>        Subject subject &#x3D; SecurityUtils.getSubject();<br><br>        UsernamePasswordToken token &#x3D; new UsernamePasswordToken(username,password);<br><br>        try&#123;<br><br>            subject.login(token);<br><br>            return &quot;redirect:&#x2F;logining&quot;;<br><br>        &#125;<br>        catch (UnknownAccountException e)&#123;<br><br>            model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;);<br><br>            return &quot;login&quot;;<br><br>        &#125;<br><br>        catch (IncorrectCredentialsException e)&#123;<br><br>            model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;);<br><br>            return &quot;login&quot;;<br><br>        &#125;<br><br><br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;add&quot;)<br>    public String add()&#123;<br><br>        return &quot;add&quot;;<br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;update&quot;)<br>    public String update()&#123;<br><br>        return &quot;update&quot;;<br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;Unauthorized&quot;)<br>    public String Unauthorized()&#123;<br><br>        return &quot;unauthorized&quot;;<br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;logout&quot;)<br>    public String logout()&#123;<br><br>        Subject subject &#x3D; SecurityUtils.getSubject();<br><br>        subject.logout();<br><br>        return &quot;login&quot;;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置类：</p>
<p>myConfig:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class myConfig implements WebMvcConfigurer &#123;<br><br>    @Override<br>    public void addViewControllers(ViewControllerRegistry registry) &#123;<br>        registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;login&quot;);<br>        registry.addViewController(&quot;&#x2F;logining&quot;).setViewName(&quot;main&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>shiroConfig:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class shiroConfig &#123;<br><br><br>&#x2F;&#x2F;    shiroFilterFactoryBean<br><br>    @Bean<br>    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;manager&quot;) DefaultWebSecurityManager manager)&#123;<br><br>         ShiroFilterFactoryBean bean &#x3D; new ShiroFilterFactoryBean();<br><br>         bean.setSecurityManager(manager);<br><br>        LinkedHashMap&lt;String, String&gt; filterMap &#x3D; new LinkedHashMap&lt;&gt;();<br><br>        filterMap.put(&quot;&#x2F;add&quot;,&quot;authc&quot;);<br><br>        filterMap.put(&quot;&#x2F;update&quot;,&quot;authc&quot;);<br><br>        filterMap.put(&quot;&#x2F;add&quot;,&quot;perms[add]&quot;);<br><br>        filterMap.put(&quot;&#x2F;update&quot;,&quot;perms[update]&quot;);<br><br>        bean.setFilterChainDefinitionMap(filterMap);<br><br>        bean.setLoginUrl(&quot;&#x2F;&quot;);<br><br>        bean.setUnauthorizedUrl(&quot;&#x2F;Unauthorized&quot;);<br><br>         return bean;<br><br>    &#125;<br><br>&#x2F;&#x2F;    DeafultWebSecurityManager<br><br>    @Bean(name &#x3D; &quot;manager&quot;)<br>    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) userRealm userRealm)&#123;<br><br>        DefaultWebSecurityManager securityManager &#x3D; new DefaultWebSecurityManager();<br><br>        securityManager.setRealm(userRealm);<br><br>        return securityManager;<br><br>    &#125;<br><br>&#x2F;&#x2F;    realm对象 需要自定义<br><br><br>    @Bean<br>    public userRealm userRealm()&#123;<br><br>        return new userRealm();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>userRealm:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class userRealm extends AuthorizingRealm &#123;<br><br>    @Autowired<br>    userService userService;<br><br>&#x2F;&#x2F;    授权<br>    @Override<br>    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;<br><br>        SimpleAuthorizationInfo info &#x3D; new SimpleAuthorizationInfo();<br><br>        Subject subject &#x3D; SecurityUtils.getSubject();<br><br>        User currentUser &#x3D; (User) subject.getPrincipal();<br><br>        info.addStringPermission(currentUser.getPermission());<br><br>        return info;<br><br>    &#125;<br><br><br>&#x2F;&#x2F;    认证<br>    @Override<br>    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;<br><br>        UsernamePasswordToken userToken &#x3D; (UsernamePasswordToken) token;<br><br>        User user &#x3D; userService.queryByUserName(userToken.getUsername());<br><br>        if(user&#x3D;&#x3D;null)&#123;<br><br>            return null;<br><br>        &#125;<br>&#x2F;&#x2F;      密码验证<br>&#x2F;&#x2F;      第一个参数是principle，代表用户信息<br>        return new SimpleAuthenticationInfo(user,user.getPassword(),&quot;&quot;);<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>最后简单写页面即可</p>
<p>目录结构如下：</p>
<p><img src="/2020/11/07/springsecurity/1.jpg" alt="1"></p>
]]></content>
      <tags>
        <tag>SpringSecurity</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot整合数据库</title>
    <url>/2020/11/05/springbootDatabase/</url>
    <content><![CDATA[<h1 id="springboot整合数据库"><a href="#springboot整合数据库" class="headerlink" title="springboot整合数据库"></a><strong>springboot整合数据库</strong></h1><p>springboot整合数据库只需要做三个事情：</p>
<ul>
<li><p>导入相应依赖</p>
</li>
<li><p>修改数据源DataSource（可选，默认Hikari）</p>
</li>
<li><p>yaml文件进行相应的配置</p>
</li>
</ul>
<h1 id="整合jdbc"><a href="#整合jdbc" class="headerlink" title="整合jdbc"></a><strong>整合jdbc</strong></h1><p><img src="/2020/11/05/springbootDatabase/jdbc.jpg" alt="jdbc"></p>
<p>jdbc的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;<br>    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>配置yaml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">spring:<br>  datasource:<br>    username: root<br>    password: 111111<br>    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC<br>    driver-class-name: com.mysql.cj.jdbc.Driver<br></code></pre></td></tr></table></figure>

<p>springboot的数据源DataSource：<code>class com.zaxxer.hikari.HikariDataSource</code></p>
<p>jdbc增删查改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class jdbcController &#123;<br><br>    @Autowired<br>    JdbcTemplate jdbcTemplate;<br><br>    @RequestMapping(&quot;selectAll&quot;)<br>    @ResponseBody<br>    public String selectAll()&#123;<br><br>        String sql &#x3D; &quot;select * from dbtest01.teacher;&quot;;<br><br>        List&lt;Map&lt;String, Object&gt;&gt; list &#x3D; jdbcTemplate.queryForList(sql);<br><br>        return list.toString();<br><br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;add&quot;)<br>    @ResponseBody<br>    public String  add()&#123;<br><br>        String sql &#x3D; &quot;insert into teacher(tno,tname) values(?,?);&quot;;<br><br>        HashMap&lt;Object, Object&gt; map &#x3D; new HashMap&lt;&gt;();<br><br>        Object[] objects &#x3D; new Object[2];<br><br>        objects[0] &#x3D; 9;<br><br>        objects[1] &#x3D; &quot;四国一&quot;;<br><br>        jdbcTemplate.update(sql,objects);<br><br>        return &quot;ok&quot;;<br><br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)<br>    @ResponseBody<br>    public String delete(@PathVariable(&quot;id&quot;) int id)&#123;<br><br>        String sql &#x3D; &quot;delete from teacher where tno&#x3D;&quot;+id;<br><br>        jdbcTemplate.update(sql);<br><br>        return &quot;ok&quot;;<br><br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;update&#x2F;&#123;id&#125;&quot;)<br>    @ResponseBody<br>    public String update(@PathVariable(&quot;id&quot;) int id)&#123;<br><br>        String sql &#x3D; &quot;update teacher set tname&#x3D;? where tno&#x3D;&quot;+id;<br><br>        Object object &#x3D; &quot;name&quot;;<br><br>        jdbcTemplate.update(sql,object);<br><br>        return &quot;ok&quot;;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="整合druid"><a href="#整合druid" class="headerlink" title="整合druid"></a><strong>整合druid</strong></h1><p>springboot整合druid，只要导入依赖就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.1.10&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>yaml配置DataSource</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">spring:<br>  datasource:<br>    username: root<br>    password: 111111<br>    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC<br>    driver-class-name: com.mysql.cj.jdbc.Driver<br>    type: com.alibaba.druid.pool.DruidDataSource<br></code></pre></td></tr></table></figure>

<p>druid的最强大之处在于druid支持 监控、日志、防御sql注入等功能</p>
<p>配置druid：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">druid:<br>      # 连接池的配置信息<br>      # 初始化大小，最小，最大<br>      initial-size: 5<br>      min-idle: 5<br>      maxActive: 20<br>      # 配置获取连接等待超时的时间<br>      maxWait: 60000<br>      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒<br>      timeBetweenEvictionRunsMillis: 60000<br>      # 配置一个连接在池中最小生存的时间，单位是毫秒<br>      minEvictableIdleTimeMillis: 300000<br>      validationQuery: SELECT 1<br>      testWhileIdle: true<br>      testOnBorrow: false<br>      testOnReturn: false<br>      # 打开PSCache，并且指定每个连接上PSCache的大小<br>      poolPreparedStatements: true<br>      maxPoolPreparedStatementPerConnectionSize: 20<br>      # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙<br>      filters: stat,wall,slf4j<br>      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录<br>      connectionProperties: druid.stat.mergeSql\&#x3D;true;druid.stat.slowSqlMillis\&#x3D;5000<br>      # 配置DruidStatFilter<br>      web-stat-filter:<br>        enabled: true<br>        url-pattern: &quot;&#x2F;*&quot;<br>        exclusions: &quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,&#x2F;druid&#x2F;*&quot;<br>      # 配置DruidStatViewServlet<br>      stat-view-servlet:<br>        url-pattern: &quot;&#x2F;druid&#x2F;*&quot;<br>        # IP白名单(没有配置或者为空，则允许所有访问)<br>        allow: 127.0.0.1,192.168.163.1<br>        # IP黑名单 (存在共同时，deny优先于allow)<br>        deny: 192.168.1.73<br>        #  禁用HTML页面上的“Reset All”功能<br>        reset-enable: false<br>        # 登录名<br>        login-username: admin<br>        # 登录密码<br>        login-password: 111111<br></code></pre></td></tr></table></figure>

<p>访问    <a href="http://localhost:8080/druid%EF%BC%8C%E8%BF%9B%E5%85%A5Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8Bdruid%E7%9A%84%E6%89%80%E6%9C%89%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8A%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE%E5%BA%93">http://localhost:8080/druid，进入Druid的监控页面，可以查看druid的所有配置信息以及监控数据库</a></p>
<h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a><strong>整合mybatis</strong></h1><p>导入mybatis-spring-boot-starter依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.1.3&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>配置yaml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">spring:<br>  datasource:<br>    username: root<br>    password: 111111<br>    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC<br>    driver-class-name: com.mysql.cj.jdbc.Driver<br></code></pre></td></tr></table></figure>

<p>pojo类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Component<br>public class Teacher &#123;<br><br>    private int tno;<br><br>    private String tname;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>TeacherMapper:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Mapper<br>@Repository<br>public interface TeacherMapper &#123;<br><br>    public List&lt;Teacher&gt; queryAllTeacher();<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>TeacherMapper.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE mapper<br>        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;<br>        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;<br>&lt;!--namespace: 绑定一个mapper接口 包名.--&gt;<br>&lt;mapper namespace&#x3D;&quot;com.database.mapper.TeacherMapper&quot;&gt;<br>    <br>    <br>    &lt;select id&#x3D;&quot;queryAllTeacher&quot; resultType&#x3D;&quot;Teacher&quot;&gt;<br>        select * from teacher;<br>    &lt;&#x2F;select&gt;<br>    <br>&lt;&#x2F;mapper&gt;<br></code></pre></td></tr></table></figure>

<p>yaml配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mybatis:<br>&lt;!-- 别名 --&gt;<br>  type-aliases-package: com.database.pojo<br>  &lt;!-- 配置映射 （去mybatis-config中配置mapper） --&gt;<br>  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml<br></code></pre></td></tr></table></figure>

<p>controller:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class teacherController &#123;<br><br>    @Autowired<br>    TeacherMapper mapper;<br><br>    @RequestMapping(&quot;&#x2F;all&quot;)<br>    @ResponseBody<br>    public String queryAllTeacher()&#123;<br><br>        List&lt;Teacher&gt; teachers &#x3D; mapper.queryAllTeacher();<br><br>        System.out.println(teachers);<br><br>        return teachers.toString();<br><br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;select&#x2F;&#123;id&#125;&quot;)<br>    @ResponseBody<br>    public String queryTeacherById(@PathVariable(&quot;id&quot;) int id) &#123;<br><br>        Teacher teacher &#x3D; mapper.queryTeacherById(id);<br><br>        System.out.println(teacher);<br><br>        return teacher.toString();<br><br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;add&quot;)<br>    @ResponseBody<br>    public String addTeacher() &#123;<br><br>        mapper.AddTeacher(new Teacher(8,&quot;omg&quot;));<br><br>        return &quot;ok&quot;;<br><br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;update&#x2F;&#123;id&#125;&quot;)<br>    @ResponseBody<br>    public String updateTeacher(@PathVariable(&quot;id&quot;) int id) &#123;<br><br>        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();<br><br>        map.put(&quot;id&quot;,id);<br><br>        map.put(&quot;name&quot;,&quot;oomg&quot;);<br><br>        mapper.updateTeacher(map);<br><br>        return &quot;ok&quot;;<br><br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)<br>    @ResponseBody<br>    public String deleteTeacher(@PathVariable(&quot;id&quot;) int id) &#123;<br><br>        mapper.deleteTeacher(8);<br><br>        return &quot;ok&quot;;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在springboot中，不用再创建sqlsession单元，用sqlsession去获得mapper类了！</p>
<p>目录结构为：</p>
<p><img src="/2020/11/05/springbootDatabase/structure.jpg" alt="structure"></p>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot入门</title>
    <url>/2020/11/03/springboot/</url>
    <content><![CDATA[<h1 id="什么是springboot"><a href="#什么是springboot" class="headerlink" title="什么是springboot"></a><strong>什么是springboot</strong></h1><p>springboot是由Pivotal团队提供的框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式(继承starter，约定优先于配置)来进行配置，从而使开发人员不再需要定义样板化的配置。springboot的核心是<strong>自动装配</strong></p>
<p>springboot不是什么新的框架！它是spring基础上的进一步简化，默认配置了很多框架的使用方式，就像maven整合了所有的jar包，springboot整合了spring的框架并且进一步简化了配置</p>
<p>回顾mvc和ssm整合阶段，每个项目都需要大量的配置文件，如果项目只是一个非常小型的应用，如果还要配置像mvc和ssm这样配置这么多文件，这工作量无疑是巨大的，但使用springboot，便可省去大量的配置文件，从而使开发变得更加简单</p>
<h1 id="springboot框架的生成方式"><a href="#springboot框架的生成方式" class="headerlink" title="springboot框架的生成方式"></a><strong>springboot框架的生成方式</strong></h1><p>生成springboot项目的方式有两种：</p>
<ol>
<li>官网生成<br>springboot快速生成：<a href="https://start.spring.io/">https://start.spring.io</a><br><img src="/2020/11/03/springboot/fastsb1.png" alt="fastsb1"><br><img src="/2020/11/03/springboot/fastsb2.png" alt="fastsb2"><br>创建后在idea导入项目即可</li>
</ol>
<ol start="2">
<li>idea生成<br><img src="/2020/11/03/springboot/idea.jpg" alt="idea"><br>生成项目后，会自动生成springboot的一些核心配置：<br>xxxApplication：springboot程序的入口，通过运行该类启动项目，其中启动类必须要加上注解<code>@SpringBootApplication</code><br>application.properties：springboot的核心配置文件，可以在该文件内修改springboot的默认配置<br>springboot的核心依赖<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;<br>	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;<br>	&lt;parent&gt;<br>		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;<br>		&lt;version&gt;2.3.5.RELEASE&lt;&#x2F;version&gt;<br>		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;<br>	&lt;&#x2F;parent&gt;<br>	&lt;groupId&gt;com.sprintbootTest&lt;&#x2F;groupId&gt;<br>	&lt;artifactId&gt;demo1&lt;&#x2F;artifactId&gt;<br>	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;<br>	&lt;name&gt;demo1&lt;&#x2F;name&gt;<br>	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;<br><br>	&lt;properties&gt;<br>		&lt;java.version&gt;11&lt;&#x2F;java.version&gt;<br>	&lt;&#x2F;properties&gt;<br><br>	&lt;dependencies&gt;<br><br>&lt;!--		web依赖：tomcat、web.xml、dispatcher、springmvc.xml--&gt;<br>		&lt;dependency&gt;<br>			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>		&lt;&#x2F;dependency&gt;<br><br>&lt;!--所有的springboot依赖都是spring-boot-stater-xxx--&gt;<br><br><br>&lt;!--		单元测试--&gt;<br>		&lt;dependency&gt;<br>			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;<br>			&lt;scope&gt;test&lt;&#x2F;scope&gt;<br>			&lt;exclusions&gt;<br>				&lt;exclusion&gt;<br>					&lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;<br>					&lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;<br>				&lt;&#x2F;exclusion&gt;<br>			&lt;&#x2F;exclusions&gt;<br>		&lt;&#x2F;dependency&gt;<br>	&lt;&#x2F;dependencies&gt;<br><br><br>&lt;!--	打包插件：打包成可执行的jar文件--&gt;<br>	&lt;build&gt;<br>		&lt;plugins&gt;<br>			&lt;plugin&gt;<br>				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;<br>			&lt;&#x2F;plugin&gt;<br>		&lt;&#x2F;plugins&gt;<br>	&lt;&#x2F;build&gt;<br><br>&lt;&#x2F;project&gt;<br><br></code></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到，在springboot中，依赖都是spring-boot-starter-xxx的格式</p>
<p>spring-boot-starter地址：<a href="https://docs.spring.io/spring-boot/docs/1.5.12.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/1.5.12.RELEASE/reference/htmlsingle/#using-boot-starter</a></p>
<h1 id="第一个springboot程序"><a href="#第一个springboot程序" class="headerlink" title="第一个springboot程序"></a><strong>第一个springboot程序</strong></h1><p>目录结构：</p>
<p><img src="/2020/11/03/springboot/first.png" alt="first"></p>
<p><strong>注：要在xxxApplication的同级上下文中写controller、mapper、pojo和service</strong></p>
<p>controller:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>@ResponseBody<br>public class HelloController &#123;<br><br>    @RequestMapping(&quot;hello&quot;)<br>    public String hello()&#123;<br>        return &quot;hello world!&quot;;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Demo1Application：程序入口，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@SpringBootApplication<br>public class Demo1Application &#123;<br><br>	public static void main(String[] args) &#123;<br>		SpringApplication.run(Demo1Application.class, args);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以发现：springboot已经帮我们内置了tomcat并且配置好了dispatcher</p>
<p><img src="/2020/11/03/springboot/tomcat.jpg" alt="tomcat"></p>
<p>可以看到，springboot帮我们简化了很多配置，更加简化了开发</p>
<h1 id="springboot的核心配置文件"><a href="#springboot的核心配置文件" class="headerlink" title="springboot的核心配置文件"></a><strong>springboot的核心配置文件</strong></h1><p>在springboot中，可以通过修改核心配置文件来修改springboot的默认配置。</p>
<p>springboot的核心配置文件application有两种：</p>
<ul>
<li>application.properties</li>
</ul>
<p>语法结构为：key=value</p>
<ul>
<li>application.yaml</li>
</ul>
<p>语法结构为：key:空格value</p>
<p><strong>spring官网不推荐使用properties这种配置文件，而是使用yaml格式的配置文件</strong></p>
<p>但是两种配置文件可以同时存在，但名字必须相同</p>
<h2 id="properties和yaml语法"><a href="#properties和yaml语法" class="headerlink" title="properties和yaml语法"></a><strong>properties和yaml语法</strong></h2><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a><strong>properties</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>name&#x3D;十二点前要睡觉<br><br>student.name&#x3D;十二点前要睡觉<br><br>student.age&#x3D;3<br><br></code></pre></td></tr></table></figure>

<h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a><strong>yaml</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">name: 十二点前要睡觉<br><br># 在yaml中，还可以存储对象<br><br>student: <br>	name: 十二点前要睡觉<br>	age: 3<br><br>student: &#123;name: 十二点要睡觉,age: 3&#125;<br><br>arr: [1,2,3,4]<br></code></pre></td></tr></table></figure>

<p><strong>注：yaml中，对空格的要求很严格</strong></p>
<p>在同一层次的属性中，必须保证空格数相同，如：student中，name和age都表示为student中的属性:student.name(age)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">student:<br>    name: 十二点前要睡觉<br>    age: 3<br></code></pre></td></tr></table></figure>


<h2 id="给实体类赋值的几种方式"><a href="#给实体类赋值的几种方式" class="headerlink" title="给实体类赋值的几种方式"></a><strong>给实体类赋值的几种方式</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Component<br>public class dog &#123;<br><br>    private String name;<br>    private int age;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>public class person &#123;<br><br>    private String name;<br>    private String age;<br>    private List hobby;<br>    private Map&lt;String,Object&gt; map;<br>    private dog dog;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Value（spring"><a href="#Value（spring" class="headerlink" title="@Value（spring)"></a><strong>@Value（spring)</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Component<br>public class dog &#123;<br><br>    @Value(&quot;汪汪&quot;)<br>    private String name;<br>    @Value(&quot;3&quot;)<br>    private int age;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@SpringBootTest<br>class Demo1ApplicationTests &#123;<br><br>	@Autowired<br>	private dog dog;<br><br>	@Test<br>	public void Test()&#123;<br><br>		System.out.println(dog);<br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="使用properties文件"><a href="#使用properties文件" class="headerlink" title="使用properties文件"></a><strong>使用properties文件</strong></h3><p>加载指定.properties配置文件，可以使用spel表达式 @Value(${“”})对属性赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Component<br>@PropertySource(value &#x3D; &quot;classpath:application.properties&quot;)<br>public class dog &#123;<br><br>    @Value(&quot;$&#123;name&#125;&quot;)<br>    private String name;<br>    @Value(&quot;$&#123;age&#125;&quot;)<br>    private int age;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">wangwang</span><br><span class="hljs-attr">age</span>=<span class="hljs-string">10</span><br></code></pre></td></tr></table></figure>

<p><strong>注：在使用@Value后，配置文件中的属性名要与类中的属性名一致！</strong></p>
<p>另外，还可以在properties文件中使用如下方式进行绑定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Component<br>@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)<br>@PropertySource(value &#x3D; &quot;classpath:application.properties&quot;)<br>public class person &#123;<br><br>    private String name;<br>    private String age;<br>    private List hobby;<br>    private Map&lt;String,Object&gt; map;<br>    private dog dog;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">person.name</span>=<span class="hljs-string">asd</span><br><span class="hljs-meta">person.age</span>=<span class="hljs-string">10</span><br><span class="hljs-meta">person.hobby</span>=<span class="hljs-string">[1,2,3,4]</span><br><span class="hljs-meta">person.map.name</span>=<span class="hljs-string">awsl</span><br><span class="hljs-meta">person.map.age</span>=<span class="hljs-string">100</span><br><span class="hljs-meta">person.dog.name</span>=<span class="hljs-string">wangwang</span><br><span class="hljs-meta">person.dog.age</span>=<span class="hljs-string">10</span><br></code></pre></td></tr></table></figure>

<p><strong>@ConfigurationProperties(prefix = “”)将配置文件中指定prefix的属性 与 类中的属性进行绑定</strong></p>
<p>不过使用properties有可能会出现乱码：</p>
<p>乱码解决:</p>
<p>settings -&gt; FileEncoding 设置统一编码</p>
<p><img src="/2020/11/03/springboot/properties.jpg" alt="properties"></p>
<h3 id="使用yaml"><a href="#使用yaml" class="headerlink" title="使用yaml"></a><strong>使用yaml</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Component<br>@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)<br>public class person &#123;<br><br>    private String name;<br>    private String age;<br>    private List hobby;<br>    private Map&lt;String,Object&gt; map;<br>    private dog dog;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>application.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">person:<br>  name: asd<br>  age: 10<br>  hobby: [1,2,3]<br>  map: &#123;name: asdasd, age: 10&#125;<br>  dog:<br>    name: wangwang<br>    age: 10<br><br></code></pre></td></tr></table></figure>

<p>以下错误不用理会，或者去根据官网指令添加相应依赖即可</p>
<p><img src="/2020/11/03/springboot/wrong.jpg" alt="wrong"></p>
<p><strong>注：yaml中的属性字段要与类中的字段一致！</strong></p>
<p>另外，yaml还支持松散绑定：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dog:</span><br>  <span class="hljs-attr">dog-name:</span> <span class="hljs-string">wangwang</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dog:</span><br>  <span class="hljs-attr">dog_name:</span> <span class="hljs-string">wangwang</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Component<br>@PropertySource(value &#x3D; &quot;classpath:application.yaml&quot;)<br>@ConfigurationProperties(prefix &#x3D; &quot;dog&quot;)<br>public class dog &#123;<br><br>    private String dogName;<br>    private int age;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Value和-Configuration对比"><a href="#Value和-Configuration对比" class="headerlink" title="@Value和@Configuration对比"></a><strong>@Value和@Configuration对比</strong></h3><p><img src="/2020/11/03/springboot/compare.png" alt="compare"></p>
<p>可以看到，@Configuration支持更为复杂的功能</p>
<h2 id="多环境配置及配置文件位置"><a href="#多环境配置及配置文件位置" class="headerlink" title="多环境配置及配置文件位置"></a><strong>多环境配置及配置文件位置</strong></h2><h3 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a><strong>文件位置</strong></h3><p>配置文件的位置有四种：</p>
<ul>
<li>file:./config/</li>
</ul>
<p>项目的config目录下</p>
<ul>
<li>file:./</li>
</ul>
<p>项目下</p>
<ul>
<li>classpath:/config/</li>
</ul>
<p>类路径的config目录下</p>
<ul>
<li>classpath:/</li>
</ul>
<p>类路径下</p>
<p>位置及优先级如图所示</p>
<p><img src="/2020/11/03/springboot/yamladdress.jpg" alt="yamladdress"></p>
<h3 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a><strong>多环境切换</strong></h3><p>在真实项目中，可能会有多套环境，比如测试环境、开发环境等等，那这个时候怎么选择指定的环境呢</p>
<ul>
<li><p>如果使用的是properties文件<br><img src="/2020/11/03/springboot/mulproperties.jpg" alt="mulproperties"><br>只需要在默认的properties文件中进行指定选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">spring.profiles.active&#x3D;dev<br><br>或<br><br>spring.profiles.active&#x3D;test<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果使用的是yaml文件<br>yaml可以使用多文档模块，在yaml中使用<code>---</code>分割多个文档</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">spring:<br>  profiles:<br>    active: dev<br><br>---<br><br>server:<br>  port: 8081<br>spring:<br>  profiles: dev<br><br>---<br><br>server:<br>  port: 8082<br>spring:<br>  profiles: test<br><br></code></pre></td></tr></table></figure>

<h1 id="springboot的web开发"><a href="#springboot的web开发" class="headerlink" title="springboot的web开发"></a><strong>springboot的web开发</strong></h1><p>在springboot中，可以使用以下方法处理静态资源</p>
<h2 id="处理静态资源"><a href="#处理静态资源" class="headerlink" title="处理静态资源"></a><strong>处理静态资源</strong></h2><h3 id="webjars"><a href="#webjars" class="headerlink" title="webjars"></a><strong>webjars</strong></h3><p>webjars官网：<a href="https://www.webjars.org/">https://www.webjars.org/</a></p>
<p>访问localhost:8080/webjars/… 便可以获取静态资源</p>
<p>如：添加jquery的webjars后，访问<a href="http://localhost:8081/webjars/jquery/3.5.1/jquery.js%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97jquery.js%E7%9A%84%E8%B5%84%E6%BA%90">http://localhost:8081/webjars/jquery/3.5.1/jquery.js就可以获得jquery.js的资源</a></p>
<p><img src="/2020/11/03/springboot/jquerywebjars.jpg" alt="jquerywebjars"></p>
<h3 id="resources-xx"><a href="#resources-xx" class="headerlink" title="resources/xx"></a><strong>resources/xx</strong></h3><ul>
<li><p>resources/public：localhost:8080/</p>
</li>
<li><p>resources/static：localhost:8080/</p>
</li>
<li><p>resources/resources：localhost:8080/</p>
</li>
</ul>
<p>可以在resources目录下创建以上三个文件，访问localhost:8080/xx 都可以获得静态资源</p>
<p>优先级：resources、public、static</p>
<p>通常将静态资源放入以上目录下，相当于mvc中/WEB-INF目录</p>
<h2 id="Thymeleaf模版"><a href="#Thymeleaf模版" class="headerlink" title="Thymeleaf模版"></a><strong>Thymeleaf模版</strong></h2><p>Thymeleaf是用来开发Web和独立环境项目的服务器端的Java模版引擎，能够处理HTML，XML，JavaScript，CSS 甚至纯文本。一些常用的模版引擎有JSP、Freemarker、Thymeleaf等等，而springboot并不支持jsp这种模版引擎。</p>
<p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
<p>Thymeleaf 在 Github 的主页：<a href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a></p>
<p>导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>	&lt;groupId&gt;org.thymeleaf&lt;&#x2F;groupId&gt;<br>	&lt;artifactId&gt;thymeleaf-spring5&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>	&lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;<br>	&lt;artifactId&gt;thymeleaf-extras-java8time&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br><br></code></pre></td></tr></table></figure>

<p><strong>注意导入的thymeleaf是3.x版本的</strong></p>
<p><img src="/2020/11/03/springboot/thymeleafproperties.jpg" alt="thymeleafproperties"></p>
<p>可以看到，thymeleaf已经帮我们生成好了视图解析器，且默认路径为resources/templates，所以视图应该放在templates目录下，以便默认的视图解析器生效</p>
<p><strong>注：如果将页面放在templates目录下，需要thymeleaf的支持，不然直接404</strong></p>
<p>thymeleaf关闭缓存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">spring:<br>  thymeleaf:<br>    cache: false<br></code></pre></td></tr></table></figure>

<h3 id="thymeleaf语法"><a href="#thymeleaf语法" class="headerlink" title="thymeleaf语法"></a><strong>thymeleaf语法</strong></h3><p>要在html文件中使用thymeleaf，要在html中加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>thymeleaf的语法和vue的语法很相似    <a href="https://blog.csdn.net/malimingwq/article/details/79329921">https://blog.csdn.net/malimingwq/article/details/79329921</a></p>
<h3 id="mvc的配置和扩展"><a href="#mvc的配置和扩展" class="headerlink" title="mvc的配置和扩展"></a><strong>mvc的配置和扩展</strong></h3><p>springboot为我们配置好了默认的mvc框架，如果我们想保持mvc的特征并且为mvc添加一些特定配置，如配置 拦截器、过滤器、改变视图解析器等等，我们可以用<code>@Configuration</code>作用于某个bean并且让它实现<code>WebMvcConfigurer</code>接口中方法即可，如果要往spring容器中添加组件，则添加一个带@Bean的方法即可</p>
<p>WebMvcConfigurer接口中的方法如下：</p>
<p><img src="/2020/11/03/springboot/webmvcconfigurer.jpg" alt="webmvcconfigurer"></p>
<p>如配置拦截器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class myconfiguration implements WebMvcConfigurer &#123;<br><br>    @Override<br>    public void addInterceptors(InterceptorRegistry registry) &#123;<br>        registry.addInterceptor(new HandlerInterceptor() &#123;<br>            @Override<br>            public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;<br>                return false;<br>            &#125;<br><br>            @Override<br>            public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;<br><br>            &#125;<br><br>            @Override<br>            public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;<br><br>            &#125;<br>        &#125;).addPathPatterns();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定制首页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class myconfiguration implements WebMvcConfigurer &#123;<br><br>    @Override<br>    public void addViewControllers(ViewControllerRegistry registry) &#123;<br>        registry.addViewController(&quot;&quot;).setViewName(&quot;&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注：定制首页时，如果放在templates目录下，需要thymeleaf支持，不然直接404，或者放在static、resources、public目录下</strong></p>
<p><strong>template下：<code>registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</code></strong></p>
<p><strong>其他目录下:<code>registry.addViewController(&quot;/&quot;).setViewName(&quot;index.html&quot;);</code></strong></p>
<p>配置定制视图解析器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyReviewResolver implements ViewResolver &#123;<br>    @Override<br>    public View resolveViewName(String s, Locale locale) throws Exception &#123;<br>        return null;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class myconfiguration implements WebMvcConfigurer &#123;<br>    <br>    @Bean<br>    public MyReviewResolver reviewResolver()&#123;<br>        return new MyReviewResolver();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="异常页面处理"><a href="#异常页面处理" class="headerlink" title="异常页面处理"></a><strong>异常页面处理</strong></h3><p>springboot中处理404非常简单，只要在templates下添加子目录error，将404页面放进error目录即可，500页面也一样，<strong>注：html页面的名字必须为404 或 500</strong></p>
<h1 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a><strong>springboot自动配置原理</strong></h1><p>@SpringBootApplication -&gt;   @EnableAutoConfiguration   -&gt;  AutoConfigurationImportSelector</p>
<p>-&gt;  selectImports   -&gt;  /meta/spring.factories    -&gt;    xxxAutoConfiguration</p>
<p>xxxAutoConfiguration    -&gt;      @EnableConfigurationProperties(xxxProperties.class)     -&gt;</p>
<p>xxxProperties(@ConfigurationProperties(prefix = “xxx”)</p>
<h2 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a><strong>工作原理：</strong></h2><p>在springboot中，所有关于自动配置的源码（自动配置类）都在spring-boot-autoconfigure-x.x.x.x.jar包中的 spring.factories文件中</p>
<p><img src="/2020/11/03/springboot/springfactories.jpg" alt="springfactories"></p>
<p>在spring.factories中 包含了大量的 键值对 形式，表示自动配置类</p>
<p><img src="/2020/11/03/springboot/autoconfigurationclass.jpg" alt="autoconfigurationclass"></p>
<p>springboot的每个启动类中，都有一个注解<code>@SpringBootApplication</code>，<code>@SpringBootApplication</code>是一个复合注解或派生注解，在<code>@SpringBootApplication</code>中有一个注解<code>@EnableAutoConfiguration</code>，意思就是开启自动配置</p>
<p><img src="/2020/11/03/springboot/springbootapplication.jpg" alt="springbootapplication"></p>
<p><code>@EnableAutoConfiguration</code>这个注解也是一个派生注解，其中的关键功能由@Import提供，<code>@EnableAutoConfiguration</code>注解通过<code>@SpringBootApplication</code>被间接的标记在了springboot的启动类上</p>
<p><img src="/2020/11/03/springboot/EnableAutoConfiguratio.jpg" alt="EnableAutoConfiguratio"></p>
<p>在AutoConfigurationImportSelector有一个方法selectImports()</p>
<p><img src="/2020/11/03/springboot/selectImports.jpg" alt="selectImports"></p>
<p>AutoConfigurationImportSelector的selectImports()方法通过SpringFactoriesLoader.loadFactoryNames()方法扫描所有具有META-INF/spring.factories的jar包</p>
<p>而在spring-boot-autoconfigure-x.x.x.x.jar包中的spring.factories文件中，就包含了springboot中的所有自动配置类，所以在启动springboot时，SpringApplication.run方法就会将所有自动配置类加载到Spring容器中。</p>
<h2 id="自动配置如何生效"><a href="#自动配置如何生效" class="headerlink" title="自动配置如何生效"></a><strong>自动配置如何生效</strong></h2><p>上面说到，所有的自动配置类都在spring-boot-autoconfigure-x.x.x.x.jar包中的spring.factories文件中</p>
<p>可以看到自动配置类都是xxxAutoConfiguration这样的形式</p>
<p>以ServletWebServerFactoryAutoConfiguration为例：</p>
<p><img src="/2020/11/03/springboot/ServletWebServerFactoryAutoConfiguration.jpg" alt="ServletWebServerFactoryAutoConfiguration"></p>
<p>可以看到在ServletWebServerFactoryAutoConfiguration中有一个注解<code>@EnableConfigurationProperties(ServerProperties.class)</code>，它表示允许配置属性</p>
<p>而在<code>ServerProperties.class</code>中，看到了熟悉的注解<code>@ConfigurationProperties</code>，它的作用就是从配置文件中绑定属性到对应的bean上</p>
<p><img src="/2020/11/03/springboot/ServerProperties.jpg" alt="ServerProperties"></p>
<p>而<code>@EnableConfigurationProperties(ServerProperties.class)</code>负责将这个已经绑定了属性的bean导入spring容器中</p>
<p>所以，到现在可以大概的得出结论：</p>
<p>springboot中所有的自动配置类都是以xxxAutoConfiguration这样的形式，每个自动配置类都是通过注解<code>@EnableConfigurationProperties(xxxProperties.class)</code>将绑定了属性的自动配置类导入spring容器中，而它们的属性由<br>xxxProperties类提供，xxxProperties类的属性又是通过<code>@ConfigurationProperties</code>注解与配置文件中的对应属性进行绑定</p>
<p>所以，每个自动配置类xxxAutoConfiguration的属性 都对应着 xxxProperties类 中的属性，要想配置自动配置类中的属性，只要找到相应的xxxProperties即可</p>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>vue入门</title>
    <url>/2020/10/29/vue/</url>
    <content><![CDATA[<h1 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a><strong>什么是vue</strong></h1><p>vue是一款渐进式的JavaScript框架 vue = （Angular+React）</p>
<p>vue文档官网：<a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p>
<h1 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a><strong>MVVM模式</strong></h1><p>MMVC是mode-view-viewmodel的缩写，是一种软件架构设计模式，本质是mvc的改进，mmvc的核心是viewmodel，vue.js其实就是mvvm的实现者</p>
<p>model：模型层，代表JavaScript对象</p>
<p>view：视图层，代表dom元素</p>
<p>viewmodel：连接视图和数据的中间层，vue对象其实就是viewmodel</p>
<p>viewmodel的作用：</p>
<ul>
<li><p>观察数据的变化，并更新视图对应的内容</p>
</li>
<li><p>观察视图的变化，并通知数据发生改变</p>
</li>
</ul>
<p><img src="/2020/10/29/vue/mvvc.jpg" alt="mvvc"></p>
<h1 id="第一个vue程序"><a href="#第一个vue程序" class="headerlink" title="第一个vue程序"></a><strong>第一个vue程序</strong></h1><p>导入cdn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		&lt;!-- view层 --&gt;<br>		&lt;div id&#x3D;&quot;div&quot;&gt;<br>			&#123;&#123;message&#125;&#125;<br>		&lt;&#x2F;div&gt;<br>		<br>		&lt;script&gt;<br>		&lt;!-- viewmodel --&gt;<br>			var vm &#x3D; new Vue(&#123;<br>				&lt;!-- 绑定的view --&gt;<br>				el:&quot;#div&quot;,<br>				&lt;!-- model层 --&gt;<br>				data:&#123;<br>					message:&quot;hello vue&quot;<br>				&#125;<br>			&#125;)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<h1 id="vue基本语法"><a href="#vue基本语法" class="headerlink" title="vue基本语法"></a><strong>vue基本语法</strong></h1><p>在vue中，形如v-xx的被称为指令，指令带有前缀v-，表示它们是vue提供的特殊特性，它们会渲染dom上应用特殊的响应式行为</p>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><strong>v-bind</strong></h2><p>v-bind的作用是进行动态数据绑定，比如<code>&lt;img src=&quot;&quot;&gt;</code>中的src属性、<code>&lt;a href=&quot;&quot;&gt;</code>中的href</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>	&lt;div id&#x3D;&quot;div&quot;&gt;<br>		&lt;!--&lt;li v-for&#x3D;&quot;i in info&quot;&gt;&#123;&#123;i&#125;&#125;&lt;&#x2F;li&gt;--&gt;<br>		&lt;a v-bind:href&#x3D;&quot;message&quot;&gt;myurl&lt;&#x2F;a&gt;<br>	&lt;&#x2F;div&gt;<br>	&lt;script&gt;<br>		var vm &#x3D; new Vue(&#123;<br>			el:&quot;#div&quot;,<br>			data:&#123;<br>				message:&quot;https:&#x2F;&#x2F;zleo-bug.github.io&#x2F;&quot;<br>			&#125;<br>		&#125;)<br>	&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<p>v-text：改变text的值 v-html改变html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>	&lt;div id&#x3D;&quot;div&quot;&gt;<br>		&lt;!--&lt;li v-for&#x3D;&quot;i in info&quot;&gt;&#123;&#123;i&#125;&#125;&lt;&#x2F;li&gt;--&gt;<br>		&lt;p v-text&#x3D;&quot;message&quot;&gt;myurl&lt;&#x2F;p&gt;<br>	&lt;&#x2F;div&gt;<br>	&lt;script&gt;<br>		var vm &#x3D; new Vue(&#123;<br>			el:&quot;#div&quot;,<br>			data:&#123;<br>				message:&quot;https:&#x2F;&#x2F;zleo-bug.github.io&#x2F;&quot;<br>			&#125;<br>		&#125;)<br>	&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<h2 id="v-if、v-else、v-if-else"><a href="#v-if、v-else、v-if-else" class="headerlink" title="v-if、v-else、v-if-else"></a><strong>v-if、v-else、v-if-else</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		<br>		&lt;div id&#x3D;&quot;div&quot;&gt;<br>			&lt;p v-if&#x3D;&quot;message&#x3D;&#x3D;&#x3D;&#39;A&#39;&quot;&gt;false&lt;&#x2F;p&gt;<br>			&lt;p v-else-if&#x3D;&quot;message&#x3D;&#x3D;&#x3D;&#39;B&#39;&quot;&gt;false&lt;&#x2F;p&gt;<br>			&lt;p v-else-if&#x3D;&quot;message&#x3D;&#x3D;&#x3D;&#39;C&#39;&quot;&gt;false&lt;&#x2F;p&gt;<br>			&lt;p v-else&gt;true&lt;&#x2F;p&gt;<br>		&lt;&#x2F;div&gt; <br>		<br>		&lt;script&gt;<br>			var vm &#x3D; new Vue(&#123;<br>				el:&quot;#div&quot;,<br>				data:&#123;<br>					message:&#39;D&#39;<br>				&#125;<br>			&#125;)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a><strong>v-for</strong></h2><p>v-for=”(,)”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		<br>		&lt;div id&#x3D;&quot;div&quot;&gt;<br>			&lt;li v-for&#x3D;&quot;(item,index) in items&quot;&gt;<br>				&#123;&#123;item.message&#125;&#125;----&#123;&#123;index&#125;&#125;<br>			&lt;&#x2F;li&gt;<br>		&lt;&#x2F;div&gt; <br>		<br>		&lt;script&gt;<br>			var vm &#x3D; new Vue(&#123;<br>				el:&quot;#div&quot;,<br>				data:&#123;<br>					items:[<br>						&#123;message:&quot;123&quot;&#125;,<br>						&#123;message:&quot;234&quot;&#125;,<br>						&#123;message:&quot;345&quot;&#125;<br>					]<br>				&#125;<br>			&#125;)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a><strong>v-on</strong></h2><p>v-on指令可以监听dom事件，dom中对应事件的方法必须定义在vue对象的methods对象中</p>
<p>v-on:event=””</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		<br>		&lt;div id&#x3D;&quot;div&quot;&gt;<br>			&lt;button v-on:click&#x3D;&quot;say&quot;&gt;点我&lt;&#x2F;button&gt;<br>		&lt;&#x2F;div&gt; <br>		<br>		&lt;script&gt;<br>			var vm &#x3D; new Vue(&#123;<br>				el:&quot;#div&quot;,<br>				data:&#123;<br>					message:&quot;hello vue!&quot;<br>				&#125;,<br>				methods:&#123;<br>					say:function()&#123;<br>						alert(this.message)<br>					&#125;<br>				&#125;<br>			&#125;)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<h1 id="vue数据双向绑定"><a href="#vue数据双向绑定" class="headerlink" title="vue数据双向绑定"></a><strong>vue数据双向绑定</strong></h1><p>可以用v-model指令在 <code>&lt;input&gt; &lt;textarea&gt; &lt;select&gt;</code>标签上创建数据的双向绑定，只要在标签里面加上<code>v-model=“”</code>，放入要绑定的数据即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		<br>		&lt;div id&#x3D;&quot;div&quot;&gt;<br>			&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot;&gt; &#123;&#123;message&#125;&#125;<br>		&lt;&#x2F;div&gt; <br>		<br>		&lt;script&gt;<br>			var vm &#x3D; new Vue(&#123;<br>				el:&quot;#div&quot;,<br>				data:&#123;<br>					message:&quot;hello vue!&quot;<br>				&#125;<br>			&#125;)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		<br>		&lt;div id&#x3D;&quot;div&quot;&gt;<br>			&lt;select v-model&#x3D;&quot;message&quot;&gt;<br>				&lt;option value&#x3D;&quot;&quot; disabled&#x3D;&quot;disabled&quot; selected&gt;---请选择---&lt;&#x2F;option&gt;<br>				&lt;option&gt;A&lt;&#x2F;option&gt;<br>				&lt;option&gt;B&lt;&#x2F;option&gt;<br>				&lt;option&gt;C&lt;&#x2F;option&gt;<br>			&lt;&#x2F;select&gt;<br>			&#123;&#123;message&#125;&#125;<br>		&lt;&#x2F;div&gt; <br>		<br>		&lt;script&gt;<br>			var vm &#x3D; new Vue(&#123;<br>				el:&quot;#div&quot;,<br>				data:&#123;<br>					message:&quot;hello vue!&quot;<br>				&#125;<br>			&#125;)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<h1 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a><strong>vue组件</strong></h1><p>组件是可复用的 Vue 实例，且带有一个名字，我们可以创建一个组件，把组件当作自定义标签使用</p>
<p>通过v-bind绑定数据，props:[‘’]接受数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>	&lt;div id&#x3D;&quot;div&quot;&gt;<br>		&lt;mycomponent v-for&#x3D;&quot;item in items&quot; v-bind:i&#x3D;&quot;item&quot;&gt;&lt;&#x2F;mycomponent&gt;<br>	&lt;&#x2F;div&gt;<br>	&lt;script&gt;<br>		Vue.component(&quot;mycomponent&quot;,&#123;<br>			props: [&#39;i&#39;],<br>			template:&quot;&lt;li&gt;&#123;&#123;i.message&#125;&#125;&lt;&#x2F;li&gt;&quot;<br>		&#125;)<br>		var vm &#x3D; new Vue(&#123;<br>			el:&quot;#div&quot;,<br>			data:&#123;<br>				items:[<br>				&#123;message:1&#125;,&#123;message:2&#125;,&#123;message:3&#125;<br>				]<br>			&#125;<br>		&#125;)<br>	&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>	&lt;div id&#x3D;&quot;div&quot;&gt;<br>		&lt;mycomponent&gt;&lt;&#x2F;mycomponent&gt;<br>	&lt;&#x2F;div&gt;<br>	&lt;script&gt;<br>		Vue.component(&quot;mycomponent&quot;,&#123;<br>			data:function()&#123;<br>				return &#123;<br>					count:0<br>				&#125;<br>			&#125;,<br>			template:&quot;&lt;button v-on:click&#x3D;&#39;count++&#39;&gt; click me &#123;&#123;count&#125;&#125; times &lt;&#x2F;button&gt;&quot;<br>		&#125;)<br>		var vm &#x3D; new Vue(&#123;<br>			el:&quot;#div&quot;,<br>			data:&#123;<br>				count:0<br>			&#125;<br>		&#125;)<br>	&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<h1 id="Axios异步通信"><a href="#Axios异步通信" class="headerlink" title="Axios异步通信"></a><strong>Axios异步通信</strong></h1><p>axios是一个开源的可以用在浏览器端和nodejs的异步通信框架，主要作用是实现ajax的异步通信</p>
<p>具有如下特性：</p>
<ol>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>从 node.js 发出 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防止 CSRF/XSRF</li>
</ol>
<p>使用Axios前，导入cdn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>	&lt;div id&#x3D;&quot;div&quot;&gt;<br>	&lt;&#x2F;div&gt;<br>	&lt;script&gt;<br>		var vm &#x3D; new Vue(&#123;<br>			el:&quot;#div&quot;,<br>			mounted()&#123;<br>				axios.get(&quot;data.json&quot;).then(response&#x3D;&gt;(console.log(response.data)));<br>			&#125;<br>		&#125;)<br>	&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<p>将json数据渲染在页面中，使用<code>data()&#123;return&#123;&#125;&#125;</code>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>	&lt;div id&#x3D;&quot;div&quot;&gt;<br>		&lt;li v-for&#x3D;&quot;i in info&quot;&gt;&#123;&#123;i&#125;&#125;&lt;&#x2F;li&gt;<br>	&lt;&#x2F;div&gt;<br>	&lt;script&gt;<br>		var vm &#x3D; new Vue(&#123;<br>			el:&quot;#div&quot;,<br>			data()&#123;<br>				return &#123;<br>					info:&#123;<br>						name:null,<br>						personalurl:null,<br>						title:null,<br>						content:null<br>					&#125;<br>				&#125;<br>			&#125;,<br>			mounted()&#123;<br>				axios.get(&quot;data.json&quot;).then(response&#x3D;&gt;(this.info&#x3D;response.data));<br>			&#125;<br>		&#125;)<br>	&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<h1 id="vue计算属性"><a href="#vue计算属性" class="headerlink" title="vue计算属性"></a><strong>vue计算属性</strong></h1><p>vue对象的计算属性computed其实是一个缓存机制，它是一个能够将计算结果缓存起来的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>	&lt;div id&#x3D;&quot;div&quot;&gt;<br>		gettime1 &#123;&#123;gettime1()&#125;&#125; &lt;br &#x2F;&gt;<br>		gettime2 &#123;&#123;gettime2&#125;&#125;<br>	&lt;&#x2F;div&gt;<br>	&lt;div&gt;<br>		<br>	&lt;&#x2F;div&gt;<br>	&lt;script&gt;<br>		var vm &#x3D; new Vue(&#123;<br>			el:&quot;#div&quot;,<br>			methods:&#123;<br>				gettime1:function()&#123;<br>					return Date.now();<br>				&#125;<br>			&#125;,<br>			computed:&#123;<br>				gettime2:function()&#123;<br>					return Date.now();<br>				&#125;<br>			&#125;<br>		&#125;)<br>	&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/29/vue/computed.jpg" alt="computed"></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm框架整合</title>
    <url>/2020/10/26/ssmintegration/</url>
    <content><![CDATA[<p>在学习完ssm三层架构之后，就要开始对这三大块进行整合了</p>
<p>下面以一个简单的例子，对ssm进行整合</p>
<p>创建数据库表书籍表book</p>
<p><img src="/2020/10/26/ssmintegration/booktable.jpg" alt="booktable"></p>
<p>创建maven项目，导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependencies&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;4.3.29.RELEASE&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;4.0.1&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;3.2.8.RELEASE&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;!--        单元测试--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;junit-jupiter-api&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;5.7.0&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;!--        数据库--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;8.0.22&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;!--        mybatis--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;3.5.6&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;!--        mybaits-spring--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;2.0.5&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;4.3.29.RELEASE&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;1.18.16&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;2.12.0-rc1&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;dependency&gt;<br>          &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;<br>          &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt;<br>          &lt;version&gt;2.8.1&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;dependency&gt;<br>          &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;<br>          &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;<br>          &lt;version&gt;2.8.1&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;dependency&gt;<br>          &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;<br>          &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt;<br>          &lt;version&gt;2.8.1&lt;&#x2F;version&gt;<br>        &lt;&#x2F;dependency&gt;<br><br>    &lt;&#x2F;dependencies&gt;<br></code></pre></td></tr></table></figure>

<p>进行资源过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;build&gt;<br>    &lt;resources&gt;<br>        &lt;resource&gt;<br>            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;<br>            &lt;includes&gt;<br>                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;<br>                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;<br>            &lt;&#x2F;includes&gt;<br>            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;<br>        &lt;&#x2F;resource&gt;<br>        &lt;resource&gt;<br>            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;<br>            &lt;includes&gt;<br>                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;<br>                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;<br>            &lt;&#x2F;includes&gt;<br>            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;<br>        &lt;&#x2F;resource&gt;<br>    &lt;&#x2F;resources&gt;<br>&lt;&#x2F;build&gt;<br><br></code></pre></td></tr></table></figure>


<p>连接数据库</p>
<p>配置spring、mybatis核心配置文件</p>
<p>applicationContext.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;<br><br><br>&lt;&#x2F;beans&gt;<br><br></code></pre></td></tr></table></figure>

<p>dbbase.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">driver&#x3D;com.mysql.cj.jdbc.Driver<br>url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmintegration?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;GMT%2B8&amp;useServerPrepStmts&#x3D;true&amp;cachePrepStmts&#x3D;true<br>username&#x3D;root<br>password&#x3D;111111<br></code></pre></td></tr></table></figure>


<p>mybatis-config.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE configuration<br>        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;<br>        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;<br>&lt;configuration&gt;<br>    &lt;properties resource&#x3D;&quot;dbbase.properties&quot;&gt;&lt;&#x2F;properties&gt;<br><br>    &lt;settings&gt;<br>        &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;<br>    &lt;&#x2F;settings&gt;<br><br>    &lt;typeAliases&gt;<br>        &lt;typeAlias type&#x3D;&quot;com.pojo.Book&quot; alias&#x3D;&quot;book&quot;&gt;&lt;&#x2F;typeAlias&gt;<br>    &lt;&#x2F;typeAliases&gt;<br><br><br>    &lt;environments default&#x3D;&quot;development&quot;&gt;<br>        &lt;environment id&#x3D;&quot;development&quot;&gt;<br>            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;<br>            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;<br>                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;<br>                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;<br>                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;<br>                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;<br>            &lt;&#x2F;dataSource&gt;<br>        &lt;&#x2F;environment&gt;<br>    &lt;&#x2F;environments&gt;<br><br><br>    &lt;mappers&gt;<br>        &lt;!--资源文件的路径--&gt;<br>        &lt;package name&#x3D;&quot;com.dao&quot;&#x2F;&gt;<br>    &lt;&#x2F;mappers&gt;<br><br>&lt;&#x2F;configuration&gt;<br></code></pre></td></tr></table></figure>

<p>创建实体类com.pojo.Book</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package com.pojo;<br><br><br>import lombok.AllArgsConstructor;<br>import lombok.Data;<br>import lombok.NoArgsConstructor;<br><br>@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>public class Book &#123;<br>    private int bookId;<br>    private String bookName;<br>    private int bookCounts;<br>    private String detail;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>创建dao接口和对应的.xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface BookMapper &#123;<br><br>    public int insertBook(Book book);<br><br>    public int deleteBookById(int bookId);<br><br>    public Book queryBookById(@Param(&quot;bookId&quot;) int bookId);<br><br>    public int updateBook(Map map);<br><br>    public List&lt;Book&gt; queryAllBooks();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>BookMapper.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE mapper<br>        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;<br>        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;<br>&lt;mapper namespace&#x3D;&quot;com.dao.BookMapper&quot;&gt;<br><br>    &lt;insert id&#x3D;&quot;insertBook&quot; parameterType&#x3D;&quot;book&quot;&gt;<br>        insert into books values(#&#123;bookId&#125;,#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;);<br>    &lt;&#x2F;insert&gt;<br><br>    &lt;delete id&#x3D;&quot;deleteBookById&quot; &gt;<br>        delete from books where bookId &#x3D; #&#123;bookId&#125;;<br>    &lt;&#x2F;delete&gt;<br><br>    &lt;update id&#x3D;&quot;updateBook&quot; parameterType&#x3D;&quot;map&quot;&gt;<br>        update books set bookName &#x3D; #&#123;bookName&#125;,bookCounts &#x3D; #&#123;bookCounts&#125;,detail &#x3D; #&#123;datail&#125;;<br>    &lt;&#x2F;update&gt;<br>    <br>    &lt;select id&#x3D;&quot;queryBookById&quot; resultType&#x3D;&quot;book&quot;&gt;<br>        select * from books where bookId &#x3D; #&#123;bookId&#125;;<br>    &lt;&#x2F;select&gt;<br>    <br>    &lt;select id&#x3D;&quot;queryAllBooks&quot; resultType&#x3D;&quot;book&quot;&gt;<br>        select * from books;<br>    &lt;&#x2F;select&gt;<br><br>&lt;&#x2F;mapper&gt;<br></code></pre></td></tr></table></figure>

<p>创建业务接口和实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface BookService &#123;<br><br>    public int insertBook(Book book);<br><br>    public int deleteBookById(int bookId);<br><br>    public Book queryBookById(int bookId);<br><br>    public int updateBook(Map map);<br><br>    public List&lt;Book&gt; queryAllBooks();<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>public class BookServiceImpl implements BookService &#123;<br><br>&#x2F;&#x2F;    service 通过 dao 调用dao层<br>    private BookMapper bookMapper;<br><br>    @Override<br>    public int insertBook(Book book) &#123;<br>        return bookMapper.insertBook(book);<br>    &#125;<br><br>    @Override<br>    public int deleteBookById(int bookId) &#123;<br>        return bookMapper.deleteBookById(bookId);<br>    &#125;<br><br>    @Override<br>    public Book queryBookById(int bookId) &#123;<br>        return bookMapper.queryBookById(bookId);<br>    &#125;<br><br>    @Override<br>    public int updateBook(Map map) &#123;<br>        return bookMapper.updateBook(map);<br>    &#125;<br><br>    @Override<br>    public List&lt;Book&gt; queryAllBooks() &#123;<br>        return bookMapper.queryAllBooks();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，mybatis层和service业务已经搭建完毕，现在搭建spring层与mybatis层的连接</p>
<p>将MyBatis与Spring进行整合，主要解决的问题就是将SqlSessionFactory对象交由Spring容器来管理，所以该整合只需要将SqlSessionFactory的对象生成器SqlSessionFactoryBean注册在Spring容器中，再将其注入给Dao的实现类即可完成整合。</p>
<p>编写spring-dao.xml文件，将SqlSessionFactory交给spring容器管理</p>
<p>spring-dao.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;<br><br>    &lt;!--    关联数据库配置文件--&gt;<br>    &lt;context:property-placeholder location&#x3D;&quot;classpath:dbbase.properties&quot;&#x2F;&gt;<br><br>    &lt;!--    &lt;context:component-scan base-package&#x3D;&quot;com.dao&quot;&gt;&lt;&#x2F;context:component-scan&gt;--&gt;<br><br><br>    &lt;!--    数据库连接池--&gt;<br>    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;<br>        &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br><br>    &lt;!--    配置sqlSessionFactory--&gt;<br>    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;<br>        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;!--        绑定mybatis的配置文件--&gt;<br>        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br><br><br>    &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;<br>        &lt;!--        注入sqlSessionFactory--&gt;<br>        &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;!--        要扫描的dao包--&gt;<br>        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.dao&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>

<p>编写spring-service.xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;<br><br>    &lt;!--    扫描service下的包--&gt;<br>    &lt;context:component-scan base-package&#x3D;&quot;com.service&quot;&gt;&lt;&#x2F;context:component-scan&gt;<br>    &lt;!--将业务类注入spring--&gt;<br>    &lt;bean id&#x3D;&quot;BookServiceImpl&quot; class&#x3D;&quot;com.service.BookServiceImpl&quot;&gt;<br>        &lt;property name&#x3D;&quot;bookMapper&quot; ref&#x3D;&quot;bookMapper&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br>&lt;!--    声明事务--&gt;<br>    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;<br>&lt;!--        注入数据源--&gt;<br>        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br><br></code></pre></td></tr></table></figure>

<p>至此，spring-mybatis的整合完毕</p>
<p>下面开始整合spring-springmvc</p>
<p>添加web支持</p>
<p><img src="/2020/10/26/ssmintegration/mvc.jpg" alt="mvc"></p>
<p>编写spring-mvc.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans<br>       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd<br>        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc<br>        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd<br>        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context<br>        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;<br><br>    &lt;!--        注解驱动--&gt;<br>    &lt;mvc:annotation-driven&#x2F;&gt;<br><br>    &lt;!--    扫描controller包--&gt;<br><br>    &lt;context:component-scan base-package&#x3D;&quot;com.controller&quot;&#x2F;&gt;<br>    &lt;!--    试图解析器--&gt;<br><br>    &lt;bean id&#x3D;&quot;internalResourceViewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;<br>        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br><br>    &lt;mvc:annotation-driven&gt;<br>        &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;<br>            &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;<br>                &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;<br>            &lt;&#x2F;bean&gt;<br>            &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;<br>                &lt;property name&#x3D;&quot;objectMapper&quot;&gt;<br>                    &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;<br>                        &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;<br>                    &lt;&#x2F;bean&gt;<br>                &lt;&#x2F;property&gt;<br>            &lt;&#x2F;bean&gt;<br>        &lt;&#x2F;mvc:message-converters&gt;<br>    &lt;&#x2F;mvc:annotation-driven&gt;<br><br><br><br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>

<p>修改applicationContext.xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;<br>    &lt;import resource&#x3D;&quot;classpath:spring-dao.xml&quot;&gt;&lt;&#x2F;import&gt;<br>    &lt;import resource&#x3D;&quot;classpath:spring-service.xml&quot;&gt;&lt;&#x2F;import&gt;<br>    &lt;import resource&#x3D;&quot;classpath:spring-mvc.xml&quot;&gt;&lt;&#x2F;import&gt;<br>&lt;&#x2F;beans&gt;<br><br></code></pre></td></tr></table></figure>

<p><strong>注：这四个xml文件要关联在一起</strong></p>
<p><img src="/2020/10/26/ssmintegration/applicationContext.xml.jpg" alt="applicationContext.xml"></p>
<p>编写web.xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;<br>         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;<br>         version&#x3D;&quot;4.0&quot;&gt;<br><br>    &lt;servlet&gt;<br>        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;<br>        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;<br>        &lt;init-param&gt;<br>            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;<br>            &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;<br>        &lt;&#x2F;init-param&gt;<br>    &lt;&#x2F;servlet&gt;<br><br>    &lt;servlet-mapping&gt;<br>        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;<br>        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;<br>    &lt;&#x2F;servlet-mapping&gt;<br>    &lt;filter&gt;<br>        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;<br>        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;<br>        &lt;init-param&gt;<br>            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;<br>            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;<br>        &lt;&#x2F;init-param&gt;<br>    &lt;&#x2F;filter&gt;<br>    &lt;filter-mapping&gt;<br>        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;<br>        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;<br>    &lt;&#x2F;filter-mapping&gt;<br><br>&lt;&#x2F;web-app&gt;<br><br></code></pre></td></tr></table></figure>

<p>至此，三层架构整合完毕</p>
<p>编写BookController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class BookController &#123;<br><br>    @Autowired<br>    private BookService bookService;<br><br>    @RequestMapping(&quot;&#x2F;result&quot;)<br>    public String list()&#123;<br>        return &quot;result&quot;;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>进行测试，此时出现异常，发现bookservice注入失败</p>
<p><img src="/2020/10/26/ssmintegration/beanwrong1.jpg" alt="beanwrong1"></p>
<p><img src="/2020/10/26/ssmintegration/beanwrong2.jpg" alt="beanwrong2"></p>
<p>进行排查：</p>
<ol>
<li>发现此时BookService的实现类是手动配置，排除注入注入失败的问题！</li>
</ol>
<p><img src="/2020/10/26/ssmintegration/dealbeanwrong.jpg" alt="dealbeanwrong"></p>
<ol start="2">
<li>进行单元测试，查看是否能查出数据库中的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>    public void test()&#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);<br><br>        BookService bookServiceImpl &#x3D; (BookService) applicationContext.getBean(&quot;BookServiceImpl&quot;);<br><br>        Book book &#x3D; bookServiceImpl.queryBookById(1);<br><br>        System.out.println(book);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>输出成功</p>
<ol start="3">
<li><p>由于是在controller中调用的BookService，检查spring-mvc.xml，发现没有配置BookService的实现类</p>
</li>
<li><p>最终检查出原因，原因是因为在web.xml文件中，前端控制器绑定的是spring-mvc.xml文件，而spring-mvc.xml文件中没有注册这个bean，所以出现错误</p>
</li>
</ol>
<p>解决方案：</p>
<p>修改web.xml文件的绑定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;servlet&gt;<br>    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;<br>    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;<br>    &lt;init-param&gt;<br>        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;<br>        &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;<br>    &lt;&#x2F;init-param&gt;<br>&lt;&#x2F;servlet&gt;<br></code></pre></td></tr></table></figure>

<p>再次进行测试：成功解决异常</p>
<p><img src="/2020/10/26/ssmintegration/success.jpg" alt="success"></p>
]]></content>
      <tags>
        <tag>SSM框架</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybaits异常解决</title>
    <url>/2020/10/25/mybatiswrong/</url>
    <content><![CDATA[<p>org.springframework.jdbc.BadSqlGrammarException</p>
<p>解决方案：检查表的字段是否正确</p>
<p>org.apache.ibatis.binding.BindingException</p>
<p>解决方案：</p>
<ul>
<li><p>检查mapper接口是否和.xml在同一目录下</p>
</li>
<li><p>检查.xml文件的namespace是否跟mapper接口一样</p>
</li>
<li><p>检查接口的返回值和xml中的是否一致</p>
</li>
<li><p>检查是否为pom.xml的资源导出问题</p>
</li>
</ul>
<p><img src="/2020/10/25/mybatiswrong/pom.jpg" alt="pom"></p>
<p>在pom.xml中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;build&gt;<br>    &lt;resources&gt;<br>        &lt;resource&gt;<br>            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;<br>            &lt;includes&gt;<br>                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;<br>                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;<br>            &lt;&#x2F;includes&gt;<br>            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;<br>        &lt;&#x2F;resource&gt;<br>        &lt;resource&gt;<br>            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;<br>            &lt;includes&gt;<br>                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;<br>                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;<br>            &lt;&#x2F;includes&gt;<br>            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;<br>        &lt;&#x2F;resource&gt;<br>    &lt;&#x2F;resources&gt;<br>&lt;&#x2F;build&gt;<br></code></pre></td></tr></table></figure>

<p>解决资源导出问题</p>
<p>c3p0异常：</p>
<p><img src="/2020/10/25/mybatiswrong/c3p0wrong.jpg" alt="c3p0wrong"></p>
<p>原来的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>



<p>Cannot find class [com.mchange.v2.c3p0.ComboPooledDataSource] for bean with name ‘dataSource’ defined in class path resource [spring-dao.xml]</p>
<p>解决方案：</p>
<p><img src="/2020/10/25/mybatiswrong/c3p0wrong2.jpg" alt="c3p0wrong2"></p>
]]></content>
      <tags>
        <tag>异常解决</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis之分页</title>
    <url>/2020/10/24/mybatisPaging/</url>
    <content><![CDATA[<p>当从数据库中根据查找条件查出数据时，返回的数据量可能非常大，我们都不会希望一次性的将所有的数据一起性读取出来，并且显示在界面上，常用的操作就是对查找到的数据进行分页，每次处理小部分数据，从而减少对数据的处理量</p>
<h2 id="利用集合-数组实现分页"><a href="#利用集合-数组实现分页" class="headerlink" title="利用集合/数组实现分页"></a><strong>利用集合/数组实现分页</strong></h2><p>studentMapper接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface studentMapper &#123;<br>    public List&lt;student&gt; getStudentList();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>studentMapper.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentList&quot; resultMap&#x3D;&quot;studentMap&quot; &gt;<br>    select * from dbtest01.stu;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>@Test<br>public void test1()&#123;<br><br>    SqlSession sqlSession &#x3D; myBatisUtil.getSqlSession();<br><br>    studentMapper studentMapper &#x3D; sqlSession.getMapper(studentMapper.class);<br><br>    List&lt;student&gt; list &#x3D;  studentMapper.getStudentList().subList(0,2);<br><br>    for(student stu:list)&#123;<br>        System.out.println(stu);<br>    &#125;<br><br>    sqlSession.close();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="在sql中实现分页"><a href="#在sql中实现分页" class="headerlink" title="在sql中实现分页"></a><strong>在sql中实现分页</strong></h2><p>在studentMapper接口中添加getStudentByLimit方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public List&lt;student&gt; getStudentByLimit(Map&lt;String,Integer&gt;map);<br></code></pre></td></tr></table></figure>

<p>Mapper.xml中配置getStudentByLimit的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentByLimit&quot; parameterType&#x3D;&quot;map&quot; resultMap&#x3D;&quot;studentMap&quot;&gt;<br>	select * from dbtest01.stu limit $&#123;startIndex&#125;,$&#123;pageSize&#125;;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<p>单元测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void getStudentByLimit()&#123;<br>    SqlSession sqlSession &#x3D; myBatisUtil.getSqlSession();<br><br>    studentMapper studentMapper &#x3D; sqlSession.getMapper(mybatis.dao.studentMapper.class);<br><br>    Map&lt;String,Integer&gt; map &#x3D; new HashMap&lt;String, Integer&gt;();<br><br>    map.put(&quot;startIndex&quot;,0);<br><br>    map.put(&quot;pageSize&quot;,2);<br><br>    List&lt;student&gt; list &#x3D; studentMapper.getStudentByLimit(map);<br><br>    for (student student : list) &#123;<br>        System.out.println(student);<br>    &#125;<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="RowBounds分页"><a href="#RowBounds分页" class="headerlink" title="RowBounds分页"></a><strong>RowBounds分页</strong></h2><p>接口添加方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public List&lt;student&gt; getStudentByRowBound();<br></code></pre></td></tr></table></figure>

<p>xml配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentByRowBound&quot; resultMap&#x3D;&quot;studentMap&quot;&gt;<br>	select * from dbtest01.stu;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<p>测试方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void getStudentByRowBound()&#123;<br>    SqlSession sqlSession &#x3D; myBatisUtil.getSqlSession();<br><br>    List&lt;student&gt; students &#x3D; sqlSession.selectList(<br>            &quot;mybatis.dao.studentMapper.getStudentByRowBound&quot;,<br>            null, new RowBounds(1, 2));<br>    for (student student : students) &#123;<br>        System.out.println(student);<br>    &#125;<br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a><strong>分页插件</strong></h2><p>文档传送门： <a href="https://pagehelper.github.io/docs/howtouse/">https://pagehelper.github.io/docs/howtouse/</a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>java日志使用</title>
    <url>/2020/10/24/javarecord/</url>
    <content><![CDATA[<h1 id="什么是日志"><a href="#什么是日志" class="headerlink" title="什么是日志"></a><strong>什么是日志</strong></h1><p>通常，在平时写代码出现错误的时候，习惯使用debug或者sout来调试错误，但有时候错误很难找，这时候需要排错就显得很困难了，这时候我们就可以使用日志来帮助我们更有效地排错。日志记录了程序的运行轨迹日志，方便查找关键信息，也方便快速定位解决问题，是应用软件中不可缺少的部分</p>
<h1 id="常用的日志框架"><a href="#常用的日志框架" class="headerlink" title="常用的日志框架"></a><strong>常用的日志框架</strong></h1><p>log4j、log4j2、Logging、commons-logging、slf4j、logback等，重点介绍log4j</p>
<h1 id="什么是log4j"><a href="#什么是log4j" class="headerlink" title="什么是log4j"></a><strong>什么是log4j</strong></h1><p>log4j是一个日志框架，是apache的一个开源项目，通过log4j可以控制日志信息的输出位置，控制每一条日志的输出格式，还定义每一条日志信息的级别，而且这些操作都可以通过一个配置文件来灵活地进行配置。</p>
<h2 id="log4j入门实例"><a href="#log4j入门实例" class="headerlink" title="log4j入门实例"></a><strong>log4j入门实例</strong></h2><p>导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.2.16&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>在resources目录下创建 log4j.properties文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码中<br>log4j.rootLogger&#x3D;DEBUG,console,file<br><br>#控制台输出的相关设置<br>log4j.appender.console &#x3D; org.apache.log4j.ConsoleAppender<br>log4j.appender.console.Target &#x3D; System.out<br>log4j.appender.console.Threshold&#x3D;DEBUG<br>log4j.appender.console.layout &#x3D; org.apache.log4j.PatternLayout<br>log4j.appender.console.layout.ConversionPattern&#x3D;[%c]-%m%n<br><br>#文件输出的相关配置<br>log4j.appender.file &#x3D; org.apache.log4j.RollingFileAppender<br>log4j.appender.file.File&#x3D;.&#x2F;log&#x2F;loginfo.log<br>log4j.appender.file.MaxFileSize&#x3D;10mb<br>log4j.appender.file.Threshold&#x3D;DEBUG<br>log4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout<br>log4j.appender.file.layout.ConversionPattern&#x3D;[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n<br><br>#日志输出级别<br>log4j.logger.org.mybatis&#x3D;DEBUG<br>log4j.logger.java.sql&#x3D;DEBUG<br>log4j.logger.java.sql.Statement&#x3D;DEBUG<br>log4j.logger.java.sql.ResultSet&#x3D;DEBUG<br>log4j.logger.java.sql.PreparedStatement&#x3D;DEBUG<br></code></pre></td></tr></table></figure>


<p>如果是在mybatis层，则要在mybatis-config.xml中配置settings</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;settings&gt;<br>	&lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;LOG4J&quot;&#x2F;&gt;<br>&lt;&#x2F;settings&gt;<br></code></pre></td></tr></table></figure>

<p>测试类中导入org.apache.log4j.logger类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import org.apache.log4j.Logger;<br></code></pre></td></tr></table></figure>

<p>设置静态变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">static Logger logger &#x3D; Logger.getLogger(studentMapperTest.class);<br><br></code></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void test()&#123;<br>    Logger logger &#x3D; Logger.getLogger(userTest.class);<br>    logger.info(&quot;info userTest&quot;);<br>    logger.debug(&quot;debug userTest&quot;);<br>    logger.error(&quot;error userTest&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出</p>
<p>[pojo.userTest]-info userTest<br>[pojo.userTest]-debug userTest<br>[pojo.userTest]-error userTest</p>
<p>同时，项目目录下生成log目录，log目录下生成loginfo.log文件</p>
<p><img src="/2020/10/24/javarecord/log.jpg" alt="log"></p>
<p><img src="/2020/10/24/javarecord/loginfo.jpg" alt="loginfo"></p>
<h2 id="log4j的基本使用方法"><a href="#log4j的基本使用方法" class="headerlink" title="log4j的基本使用方法"></a><strong>log4j的基本使用方法</strong></h2><p>Log4j由三个重要的组件构成：</p>
<ul>
<li><p>日志信息的优先级<br>日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG，分别用来指定这条日志信息的重要程度</p>
</li>
<li><p>日志信息的输出目的地<br>日志信息的输出目的地指定了日志将打印到控制台还是文件中；</p>
</li>
<li><p>日志信息的输出格式。<br>输出格式则控制了日志信息的显 示内容。</p>
</li>
</ul>
<h3 id="定义log4j的配置文件"><a href="#定义log4j的配置文件" class="headerlink" title="定义log4j的配置文件"></a><strong>定义log4j的配置文件</strong></h3><p>Log4j支持两种配置文件格式，一种是XML格式的文件，一种是Java特性文件properties.xml文件，下面介绍使用properties.xml文件做为配置文件的方法</p>
<h4 id="配置rootLogger"><a href="#配置rootLogger" class="headerlink" title="配置rootLogger"></a><strong>配置rootLogger</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">log4j.rootLogger&#x3D;level(ERROR WARN INFO DEBUG) appenderName1,appenderName2,...<br></code></pre></td></tr></table></figure>
<p>level是日志记录的优先级，通过在这里定义的级别，可以控制应用程序中相应级别的日志信息的开关，如配置为INFO，则DEBUG级别的日志就不再输出，若配置为DEBUG，则ERROR WARN INFO DEBUG的信息都会输出</p>
<p>appenderName是指日志信息将要输出的地方，如console、file等等</p>
<h4 id="配置日志信息输出的位置"><a href="#配置日志信息输出的位置" class="headerlink" title="配置日志信息输出的位置"></a><strong>配置日志信息输出的位置</strong></h4><p>通过log4j.appender.appenderName = fully.qualified.name.of.appender.class 的方式指定输出目的地</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender<br><br>log4j.appender.console &#x3D; org.apache.log4j.ConsoleAppender<br><br>log4j.appender.file &#x3D; org.apache.log4j.RollingFileAppender<br></code></pre></td></tr></table></figure>

<h4 id="配置appenderName的输出门槛Threshold"><a href="#配置appenderName的输出门槛Threshold" class="headerlink" title="配置appenderName的输出门槛Threshold"></a><strong>配置appenderName的输出门槛Threshold</strong></h4><p>通过log4j.appender.appenderName.Threshold = level(ERROR WARN INFO DEBUG)的方式设置门槛，低于门槛的信息将不再输出</p>
<h4 id="配置日志信息的布局layout"><a href="#配置日志信息的布局layout" class="headerlink" title="配置日志信息的布局layout"></a><strong>配置日志信息的布局layout</strong></h4><p>通过log4j.appender.appenderName.layout的方式设置布局</p>
<p>log4j提供的layout有：</p>
<ul>
<li>org.apache.log4j.HTMLLayout（以HTML表格形式布局），  </li>
<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式），  </li>
<li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），  </li>
<li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</li>
</ul>
<h4 id="配置日志打印信息的具体格式"><a href="#配置日志打印信息的具体格式" class="headerlink" title="配置日志打印信息的具体格式"></a><strong>配置日志打印信息的具体格式</strong></h4><p>通过log4j.appender.appenderName.layout.ConversionPattern的方式提供具体格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">%m 输出代码中指定的消息<br><br>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL<br><br>%r 输出自应用启动到输出该log信息耗费的毫秒数<br><br>%c 输出所属的类目，通常就是所在类的全名<br><br>%t 输出产生该日志事件的线程名<br><br>%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”<br><br>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921<br><br>%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。<br><br></code></pre></td></tr></table></figure>
<p>如上面配置中的 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">log4j.appender.console.layout.ConversionPattern&#x3D;[%c]-%m%n<br></code></pre></td></tr></table></figure>

<h4 id="当输出目的地为文件的时候"><a href="#当输出目的地为文件的时候" class="headerlink" title="当输出目的地为文件的时候"></a><strong>当输出目的地为文件的时候</strong></h4><p>此时要配置</p>
<ul>
<li><p>log4j.appender.file<br>通常为 org.apache.log4j.RollingFileAppender</p>
</li>
<li><p>log4j.appender.file.File<br>这个的含义为输出文件的路径，通常取当前项目目录下，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">log4j.appender.file.File&#x3D;.&#x2F;log&#x2F;loginfo.log<br></code></pre></td></tr></table></figure>
</li>
<li><p>log4j.appender.file.MaxFileSize<br>设置文件大小</p>
</li>
</ul>
<h2 id="一个简单的log4j配置文件"><a href="#一个简单的log4j配置文件" class="headerlink" title="一个简单的log4j配置文件"></a><strong>一个简单的log4j配置文件</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码中<br>log4j.rootLogger&#x3D;DEBUG,console,file<br><br>#控制台输出的相关设置<br>log4j.appender.console &#x3D; org.apache.log4j.ConsoleAppender<br>log4j.appender.console.Target &#x3D; System.out<br>log4j.appender.console.Threshold&#x3D;DEBUG<br>log4j.appender.console.layout &#x3D; org.apache.log4j.PatternLayout<br>log4j.appender.console.layout.ConversionPattern&#x3D;[%c]-%m%n<br><br>#文件输出的相关配置<br>log4j.appender.file &#x3D; org.apache.log4j.RollingFileAppender<br>log4j.appender.file.File&#x3D;.&#x2F;log&#x2F;loginfo.log<br>log4j.appender.file.MaxFileSize&#x3D;10mb<br>log4j.appender.file.Threshold&#x3D;DEBUG<br>log4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout<br>log4j.appender.file.layout.ConversionPattern&#x3D;[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n<br><br>#日志输出级别<br>log4j.logger.org.mybatis&#x3D;DEBUG<br>log4j.logger.java.sql&#x3D;DEBUG<br>log4j.logger.java.sql.Statement&#x3D;DEBUG<br>log4j.logger.java.sql.ResultSet&#x3D;DEBUG<br>log4j.logger.java.sql.PreparedStatement&#x3D;DEBUG<br><br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>lombok的使用</title>
    <url>/2020/10/23/lombok/</url>
    <content><![CDATA[<h1 id="什么是lombok"><a href="#什么是lombok" class="headerlink" title="什么是lombok"></a><strong>什么是lombok</strong></h1><p>lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码，它是一个java类库，lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法。</p>
<p>有了lombok，就不用再写setter getter等其他方法，通过一个注释，就可实现相同的功能。</p>
<p>说白了，使用lombok的目的就是为了偷懒</p>
<h1 id="lombok的使用"><a href="#lombok的使用" class="headerlink" title="lombok的使用"></a><strong>lombok的使用</strong></h1><h2 id="安装lombok"><a href="#安装lombok" class="headerlink" title="安装lombok"></a><strong>安装lombok</strong></h2><p>要使用lombok，首先要安装lombok</p>
<p><img src="/2020/10/23/lombok/settup.jpg" alt="settup"></p>
<h2 id="lombok的注解"><a href="#lombok的注解" class="headerlink" title="lombok的注解"></a><strong>lombok的注解</strong></h2><p>lombok的注解：</p>
<p><img src="/2020/10/23/lombok/annonation.jpg" alt="annonation"></p>
<p>其中，@Data、@Getter、@Setter、ToString、@xxxConstructor、@EqualsAndHashCode这几个注释是最常用的</p>
<p>@Data = NoArgsConstructor + getter + setter + ToString + EqualsAndHashCode</p>
<p>其中，@Getter和@Setter可作用于类或属性，作用于类则自动生成全部getter和setter，属性上则生成属性的getter和setter</p>
<h2 id="lombok的简单使用"><a href="#lombok的简单使用" class="headerlink" title="lombok的简单使用"></a><strong>lombok的简单使用</strong></h2><p>导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.18.12&lt;&#x2F;version&gt;<br>    &lt;scope&gt;provided&lt;&#x2F;scope&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>在pojo包下创建User类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package pojo;<br><br>public class User &#123;<br>    private String username;<br>    private String password;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>pojo类添加@Data注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>public class User &#123;<br>    private String username;<br>    private String password;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时User的结构中自动生成了一些方法</p>
<p><img src="/2020/10/23/lombok/@Data.jpg" alt="@Data"></p>
<p>其他方法也一样，添加哪个注释，就会自动生成对应的方法</p>
<p>@Getter和@Setter作用于属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class User &#123;<br>    <br>    @Getter<br>    @Setter<br>    private String username;<br>    private String password;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时为username自动生成getter和setter</p>
<p><img src="/2020/10/23/lombok/gs.jpg" alt="gs"></p>
<p>使用@NoArgsConstructor和@AllArgsConstructor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@NoArgsConstructor<br>@AllArgsConstructor<br>public class User &#123;<br>    private String username;<br>    private String password;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/23/lombok/na.jpg" alt="na"></p>
<p>不过，lombok只能生成无参和全参的构造器，不能生成某个属性或者多个属性的构造器，此时要自己手动生成这类的构造器，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@NoArgsConstructor<br>@AllArgsConstructor<br>public class User &#123;<br>    private String username;<br>    private String password;<br>    public User(String username) &#123;<br>        this.username &#x3D; username;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/23/lombok/naa.jpg" alt="naa"></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门</title>
    <url>/2020/10/22/mybatis/</url>
    <content><![CDATA[<h1 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a><strong>什么是MyBatis</strong></h1><p>MyBatis(iBatis)是一款优秀的<strong>持久层</strong>框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO 为数据库中的记录。</p>
<p>MyBatis的核心是SqlSession对象，sqlsession是一个连接器，它会读取mybatis中的所有配置信息</p>
<h1 id="第一个MyBatis程序"><a href="#第一个MyBatis程序" class="headerlink" title="第一个MyBatis程序"></a><strong>第一个MyBatis程序</strong></h1><p>创建数据库dbtest01，并创建学生表stu</p>
<p><img src="/2020/10/22/mybatis/stu.jpg" alt="stu"></p>
<p>步骤：</p>
<p><img src="/2020/10/22/mybatis/sequence.jpg" alt="sequence"></p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a><strong>配置环境</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;8.0.22&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<h2 id="编写pojo类和dao接口"><a href="#编写pojo类和dao接口" class="headerlink" title="编写pojo类和dao接口"></a><strong>编写pojo类和dao接口</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package mybatis.pojo;<br><br>public class student &#123;<br>    private int sno;<br>    private String sname;<br>    private int sage;<br>    private String ssex;<br>    private String sdept;<br>    ...省略getter、setter 、constructor 和 tostring方法...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在dao包下创建studentMapper接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package mybatis.dao;<br><br>import mybatis.pojo.student;<br><br>import java.util.List;<br><br>public interface studentMapper &#123;<br>    public List&lt;student&gt; getStudentList();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="创建studentMapper-xml文件"><a href="#创建studentMapper-xml文件" class="headerlink" title="创建studentMapper.xml文件"></a><strong>创建studentMapper.xml文件</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE mapper<br>        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;<br>        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;<br>&lt;!--namespace: 绑定一个mapper接口 包名.--&gt;<br>&lt;mapper namespace&#x3D;&quot;mybatis.dao.studentMapper&quot;&gt;<br>&lt;!--    &lt;insert&#x2F;delete&#x2F;select&#x2F;update 为对应的操作--&gt;<br><br>&lt;!--    id 为mapper接口中的方法名    resultType为sql语句返回的类型--&gt;<br>&lt;!--    相当于实现了Mapper接口并重写了某个方法，然后用这个方法去实现jdbc操作--&gt;<br>&lt;!--    &lt;select标签表示接口中的方法要执行选择操作，返回的结果为student类型--&gt;<br>    &lt;select id&#x3D;&quot;getStudentList&quot; resultType&#x3D;&quot;mybatis.pojo.student&quot;&gt;<br>    select * from dbtest01.stu;<br>  &lt;&#x2F;select&gt;<br><br>&lt;!-- 注：为每个接口生成了对应的Mapper.xml文件后，要到config.xml文件中配置 映射    --&gt;<br>&lt;&#x2F;mapper&gt;<br></code></pre></td></tr></table></figure>

<p><strong>注：resulttype中的类类型要写全名，即package…类名</strong>    </p>
<p>studentMapper.xml配置文件为studentMapper接口省去了jdbc的操作</p>
<p>标签是为接口中的方法服务的，xml文件相当于接口的实现类</p>
<p><strong>注：为每个接口生成了对应的Mapper.xml文件后，要到config.xml文件中配置映射</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mappers&gt;<br>	&lt;!--资源文件的路径--&gt;<br>    &lt;mapper resource&#x3D;&quot;mybatis&#x2F;dao&#x2F;studentMapper.xml&quot;&#x2F;&gt;<br>&lt;&#x2F;mappers&gt;<br></code></pre></td></tr></table></figure>

<p>若不进行配置，则会出现异常信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">org.apache.ibatis.binding.BindingException: Type interface mybatis.dao.studentMapper is not known to the MapperRegistry.<br></code></pre></td></tr></table></figure>
<h2 id="编写核心配置文件"><a href="#编写核心配置文件" class="headerlink" title="编写核心配置文件"></a><strong>编写核心配置文件</strong></h2><p>在resources文件夹下配置mybatis-config.xml核心文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE configuration<br>        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;<br>        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;<br>&lt;configuration&gt;<br>    &lt;environments default&#x3D;&quot;development&quot;&gt;<br>&lt;!--        可以配置多个environment环境--&gt;<br>        &lt;environment id&#x3D;&quot;development&quot;&gt;<br>            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;<br>            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;<br>                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;<br>                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC&amp;useServerPrepStmts&#x3D;true&amp;cachePrepStmts&#x3D;true&quot;&#x2F;&gt;<br>                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;<br>                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;111111&quot;&#x2F;&gt;<br>            &lt;&#x2F;dataSource&gt;<br>        &lt;&#x2F;environment&gt;<br>    &lt;&#x2F;environments&gt;<br>    &lt;mappers&gt;<br>    	&lt;!--资源文件的路径--&gt;<br>        &lt;mapper resource&#x3D;&quot;mybatis&#x2F;dao&#x2F;studentMapper.xml&quot;&#x2F;&gt;<br>    &lt;&#x2F;mappers&gt;<br><br>&lt;&#x2F;configuration&gt;<br></code></pre></td></tr></table></figure>

<p><strong>要注意：核心配置文件中的&amp;必须转意为 &amp;amp;</strong></p>
<h2 id="编写mybatisUtil类"><a href="#编写mybatisUtil类" class="headerlink" title="编写mybatisUtil类"></a><strong>编写mybatisUtil类</strong></h2><p>创建myBatisUtil封装类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package mybatis.utils;<br><br>import org.apache.ibatis.io.Resources;<br>import org.apache.ibatis.session.SqlSession;<br>import org.apache.ibatis.session.SqlSessionFactory;<br>import org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><br>import java.io.IOException;<br>import java.io.InputStream;<br><br>public class myBatisUtil &#123;<br>    private static SqlSessionFactory sqlSessionFactory;<br>    static &#123;<br>        try &#123;<br>&#x2F;&#x2F;            固定代码<br>            String resource &#x3D; &quot;mybatis-config.xml&quot;;<br>            <br>            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);<br>            <br>&#x2F;&#x2F;            首先先获取sqlsessionfactroy对象 通过这个对象获取sqlsession对象<br>            sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);<br>            <br>        &#125; catch (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#x2F;&#x2F;    获取sqlsession对象<br>    public static SqlSession getSqlSession()&#123;<br>        return sqlSessionFactory.openSession();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注：这里的Resources要选择iBatis中的</strong></p>
<p><img src="/2020/10/22/mybatis/resource.png" alt="resources"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p>在单元测试中进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">class studentMapperTest &#123;<br><br>    @Test<br>    public void test1()&#123;<br><br>        SqlSession sqlSession &#x3D; myBatisUtil.getSqlSession();<br><br>        &#x2F;&#x2F;通过getMapper获得接口<br>        studentMapper studentMapper &#x3D; sqlSession.getMapper(studentMapper.class);<br><br>        List&lt;student&gt; list &#x3D;  studentMapper.getStudentList();<br><br>        for(student stu:list)&#123;<br>            System.out.println(stu);<br>        &#125;<br><br>        sqlSession.close();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时发现出现错误</p>
<p><img src="/2020/10/22/mybatis/wrong.png" alt="wrong"></p>
<p>提示初始化失败，找不到studentMapper.xml文件，原因是maven的资源导出问题，发现maven的target生成目录中没有生成这个.xml文件，此时可以选择将dao中的xml文件复制到target的dao文件中，此时解决问题，但是要移动太麻烦了，可以往pom.xml文件中加上如下代码手动配置资源过滤，解决问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;build&gt;<br>    &lt;resources&gt;<br>        &lt;resource&gt;<br>            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;<br>            &lt;includes&gt;<br>                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;<br>                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;<br>            &lt;&#x2F;includes&gt;<br>            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;<br>        &lt;&#x2F;resource&gt;<br>        &lt;resource&gt;<br>            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;<br>            &lt;includes&gt;<br>                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;<br>                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;<br>            &lt;&#x2F;includes&gt;<br>            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;<br>        &lt;&#x2F;resource&gt;<br>    &lt;&#x2F;resources&gt;<br>&lt;&#x2F;build&gt;<br></code></pre></td></tr></table></figure>

<p>再次进行测试</p>
<p>student{sno=201215121, sname=’李勇’, sage=20, ssex=’男’, sdept=’cs’}<br>student{sno=201215122, sname=’刘晨’, sage=19, ssex=’女’, sdept=’cs’}<br>student{sno=201215123, sname=’王敏’, sage=18, ssex=’女’, sdept=’ma’}<br>student{sno=201215125, sname=’张立’, sage=19, ssex=’男’, sdept=’is’}</p>
<p>成功输出数据库中的结果</p>
<p>结构目录如下：</p>
<p><img src="/2020/10/22/mybatis/con.jpg" alt="结构目录"></p>
<h2 id="增删改查的实现"><a href="#增删改查的实现" class="headerlink" title="增删改查的实现"></a><strong>增删改查的实现</strong></h2><h3 id="查"><a href="#查" class="headerlink" title="查"></a><strong>查</strong></h3><p>在studentMapper接口中添加方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public student getStudentById(int sno);<br></code></pre></td></tr></table></figure>

<p>在studentMapper.xml文件中添加相应配置项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentById&quot; resultType&#x3D;&quot;mybatis.pojo.student&quot; parameterType&#x3D;&quot;int&quot;&gt;<br>    select * from dbtest01.stu where sno &#x3D; #&#123;sno&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<p>执行单元测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void test2()&#123;<br><br>    SqlSession sqlSession &#x3D; myBatisUtil.getSqlSession();<br><br>    studentMapper studentMapper &#x3D; sqlSession.getMapper(studentMapper.class);<br><br>    student stu &#x3D; studentMapper.getStudentById(201215121);<br><br>    System.out.println(stu);<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>成功输出</p>
<p>student{sno=201215121, sname=’李勇’, sage=20, ssex=’男’, sdept=’cs’}</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a><strong>增</strong></h3><p>studentMapper接口中添加方法  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void addStudent(student stu);<br></code></pre></td></tr></table></figure>

<p>studentMapper.xml配置文件中添加相应配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;insert id&#x3D;&quot;addStudent&quot; parameterType&#x3D;&quot;mybatis.pojo.student&quot;&gt;<br>&lt;!-- 直接使用对象的属性名称就可以 能自动获取 --&gt;<br>    insert into dbtest01.stu values(#&#123;sno&#125;,#&#123;sname&#125;,#&#123;sage&#125;,#&#123;ssex&#125;,#&#123;sdept&#125;);<br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>
<p>执行单元测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void test3()&#123;<br>    SqlSession sqlSession &#x3D; myBatisUtil.getSqlSession();<br><br>    studentMapper studentMapper &#x3D; sqlSession.getMapper(studentMapper.class);<br><br>    studentMapper.addStudent(<br>            new student(20185625,&quot;zl&quot;,21,&quot;男&quot;,&quot;cs&quot;)<br>    );<br><br>    System.out.println(studentMapper.getStudentById(20185625));<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时查看数据库，数据库中并没有新插入的元组</p>
<p>原因为：<strong>对数据库的 增 删 改 操作都需要进行事务提交的操作</strong></p>
<p>在sqlSession.close()前执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sqlSession.commit();<br></code></pre></td></tr></table></figure>

<p>再次进行单元测试，成功插入</p>
<p>或者可以使用openSession(boolean)的重载方法设置自动提交事务</p>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a><strong>删</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void deleteStudent(int sno);<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;delete id&#x3D;&quot;deleteStudent&quot; parameterType&#x3D;&quot;int&quot;&gt;<br>    delete from dbtest01.stu where sno &#x3D; #&#123;sno&#125;;<br>&lt;&#x2F;delete&gt;<br></code></pre></td></tr></table></figure>

<h3 id="改"><a href="#改" class="headerlink" title="改"></a><strong>改</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void updateStudent();<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;update id&#x3D;&quot;updateStudent&quot;&gt;<br>    update dbtest01.stu set sname &#x3D; &quot;handsomeboy&quot; where sno &#x3D; 20185625;<br>&lt;&#x2F;update&gt;<br></code></pre></td></tr></table></figure>

<p>若数据库表中字段较多，但要修改的字段比较少，参数使用对象类型的话很麻烦，可以考虑使用map传入参数，此时，map可以为属性取任意名字，或者使用<strong>注解</strong></p>
<p>如：</p>
<p>接口中添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void updateStudent1(Map&lt;String,Object&gt; map);<br></code></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;update id&#x3D;&quot;updateStudent1&quot; parameterType&#x3D;&quot;map&quot;&gt;<br>    update dbtest01.stu set sname &#x3D; #&#123;name&#125; where sno &#x3D; 201215125;<br>&lt;&#x2F;update&gt;<br></code></pre></td></tr></table></figure>

<p>单元测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void Test6()&#123;<br>    SqlSession sqlSession &#x3D; myBatisUtil.getSqlSession();<br>    Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();<br>    map.put(&quot;name&quot;,&quot;张&quot;);<br>    studentMapper studentMapper &#x3D; sqlSession.getMapper(mybatis.dao.studentMapper.class);<br>    studentMapper.updateStudent1(map);<br>    System.out.println(studentMapper.getStudentById(201215125));<br>    sqlSession.commit();<br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<p>student{sno=201215125, sname=’张’, sage=19, ssex=’男’, sdept=’is’}</p>
<h1 id="Mybatis的执行流程"><a href="#Mybatis的执行流程" class="headerlink" title="Mybatis的执行流程"></a><strong>Mybatis的执行流程</strong></h1><p><img src="/2020/10/22/mybatis/process.jpg" alt="process"></p>
<h1 id="MyBatis配置解析"><a href="#MyBatis配置解析" class="headerlink" title="MyBatis配置解析"></a><strong>MyBatis配置解析</strong></h1><p>MyBatis的核心配置文件为 mybatis-config.xml</p>
<p>下图列出了配置文件中的重要配置项</p>
<p><img src="/2020/10/22/mybatis/config.jpg" alt="config"></p>
<h2 id="配置环境（environments）"><a href="#配置环境（environments）" class="headerlink" title="配置环境（environments）"></a><strong>配置环境（environments）</strong></h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中</p>
<p><strong>注：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>
<p>所以，如果想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。</p>
<p>一个环境配置如下：</p>
<p><img src="/2020/10/22/mybatis/environments.jpg" alt="environments"></p>
<p><strong>environments</strong></p>
<p>表示可以配置多个环境项，defalut为默认选中的环境</p>
<p><strong>environment 环境项</strong></p>
<p>environment配置环境项，id为其标识符</p>
<p><strong>transactionManager 事务管理器</strong></p>
<p>默认的事务管理器为JDBC</p>
<p><strong>dataSource 数据源</strong><br>使用标准的jdbc数据源接口配置jdbc连接对象的资源 dataSource中重要的type有两种：POOLED、UNPOOLED</p>
<p>POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间</p>
<p>UNPOOLED：这个数据源的实现会每次请求时打开和关闭连接。</p>
<h2 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a><strong>属性（properties）</strong></h2><p>可以通过properties属性实现引用配置文件，这些属性可以在外部进行配置，并可以进行动态替换，可以在典型的 Java 属性文件中配置这些属性</p>
<p>如：</p>
<p>在resources目录下创建java属性文件 db.properties，里面配置了jdbc连接数据库的四个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">driver&#x3D;com.mysql.cj.jdbc.Driver<br>url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC&amp;useServerPrepStmts&#x3D;true&amp;cachePrepStmts&#x3D;true<br>username&#x3D;root<br>password&#x3D;111111<br></code></pre></td></tr></table></figure>

<p>将环境项改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;environment id&#x3D;&quot;development&quot;&gt;<br>    &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;<br>    &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;<br>        &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;<br>        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;<br>        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;<br>        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;<br>    &lt;&#x2F;dataSource&gt;<br>&lt;&#x2F;environment&gt;<br></code></pre></td></tr></table></figure>

<p>在config配置文件中的&lt; configuration&gt;标签的最开始引入db.properties外部配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;properties resource&#x3D;&quot;db.properties&quot;&gt;&lt;&#x2F;properties&gt;<br></code></pre></td></tr></table></figure>

<p>如果不在最开始引入，则会提示错误</p>
<p><img src="/2020/10/22/mybatis/properties_wrong.jpg" alt="properties_wrong"></p>
<p>提示在configuration配置下 必须按照 properties -&gt; … -&gt; mappers 的顺序进行配置</p>
<p>对Test1进行测试：</p>
<p>student{sno=201215121, sname=’李勇’, sage=20, ssex=’男’, sdept=’cs’}<br>student{sno=201215122, sname=’刘晨’, sage=19, ssex=’女’, sdept=’cs’}<br>student{sno=201215123, sname=’王敏’, sage=18, ssex=’女’, sdept=’ma’}<br>student{sno=201215124, sname=’张三’, sage=20, ssex=’男’, sdept=’cs’}<br>student{sno=201215125, sname=’张’, sage=19, ssex=’男’, sdept=’is’}<br>student{sno=201215126, sname=’张四’, sage=21, ssex=’女’, sdept=’ma’}</p>
<hr>
<p>另外，还可以在properties标签下通过&lt; property name=”” value=””&gt; 添加愿properties文件中没有的属性</p>
<p>如：把db.properties中的user属性和password属性删除</p>
<p>将properties标签改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;properties resource&#x3D;&quot;db.properties&quot;&gt;<br>    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;<br>    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;111111&quot;&#x2F;&gt;<br>&lt;&#x2F;properties&gt;<br></code></pre></td></tr></table></figure>

<hr>
<p>如果此时外部properties文件中与&lt; property&gt;配置项拥有相同的属性，此时，优先使用外部文件中的属性</p>
<p>如：</p>
<p>db.properties文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">driver&#x3D;com.mysql.cj.jdbc.Driver<br>url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC&amp;useServerPrepStmts&#x3D;true&amp;cachePrepStmts&#x3D;true<br>username&#x3D;root<br>password&#x3D;111111<br></code></pre></td></tr></table></figure>
<p>&lt; properties&gt;标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!--引入外部配置文件--&gt;<br>&lt;properties resource&#x3D;&quot;db.properties&quot;&gt;<br>    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;<br>    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot;&#x2F;&gt;<br>&lt;&#x2F;properties&gt;<br></code></pre></td></tr></table></figure>

<p>测试时，发现连接数据库成功，则说明优先使用的是外部文件中的属性</p>
<h2 id="设置（settings）"><a href="#设置（settings）" class="headerlink" title="设置（settings）"></a><strong>设置（settings）</strong></h2><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>
<table>
<thead>
<tr>
<th>设置名</th>
<th>描述</th>
<th>有效值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>cacheEnabled</td>
<td>全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td>
<td>true、false</td>
<td>true</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。</td>
<td>true、false</td>
<td>false</td>
</tr>
<tr>
<td>useGeneratedKeys</td>
<td>允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。</td>
<td>true、false</td>
<td>False</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td>true、false</td>
<td>False</td>
</tr>
<tr>
<td>logImpl</td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td>SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING</td>
<td>未设置</td>
</tr>
</tbody></table>
<p>下面是一个完整的settings配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;settings&gt;<br>  &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;autoMappingUnknownColumnBehavior&quot; value&#x3D;&quot;WARNING&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;defaultFetchSize&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt;<br>  &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;<br>&lt;&#x2F;settings&gt;<br></code></pre></td></tr></table></figure>


<h2 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a><strong>类型别名（typeAliases）</strong></h2><p>类型别名可为 Java 类型设置一个缩写名字，它仅用于 XML 配置，意在降低冗余的全限定类名书写</p>
<p>如：在studentMapper.xml配置文件下，查询语句的返回结果为：</p>
<p><img src="/2020/10/22/mybatis/resulttype.jpg" alt="resulttype"></p>
<p>返回结果的全称为 mybatis.pojo.student ，类名太长，如果想缩短全称，如直接返回 student ，可使用类型别名</p>
<p>在config核心配置文件中添加配置项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;typeAliases&gt;<br>    &lt;typeAlias type&#x3D;&quot;mybatis.pojo.student&quot; alias&#x3D;&quot;student&quot;&gt;&lt;&#x2F;typeAlias&gt;<br>&lt;&#x2F;typeAliases&gt;<br></code></pre></td></tr></table></figure>

<p>修改Mapper.xml中的返回类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentList&quot; resultType&#x3D;&quot;student&quot; &gt;<br>   select * from dbtest01.stu;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<p>执行Test1，此时执行成功，说明类型别名生效</p>
<hr>
<p>另外，在配置类型别名的时候不用为每个类都配置一个别名，可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，每一个包中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;typeAliases&gt;<br>    &lt;package name&#x3D;&quot;mybatis.pojo&quot;&#x2F;&gt;<br>&lt;&#x2F;typeAliases&gt;<br></code></pre></td></tr></table></figure>

<p>再次测试，返回相同结果</p>
<hr>
<p>也可以使用 @Alias 注解的方式为某个类取别名</p>
<p>如： @Alias(“hello”) 注解作用于student类中，此时在Mapper.xml文件下修改返回类型为hello，则方法执行成功</p>
<hr>
<p>下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody></table>
<h2 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a><strong>映射器（mappers）</strong></h2><p>映射器是核心文件配置的最后一项，在为每个dao接口生成了对应的Mapper.xml文件后，要到config.xml文件中配置 映射，告诉mybatis到哪里去找到这些语句</p>
<h3 id="使用相对于类路径的资源引用"><a href="#使用相对于类路径的资源引用" class="headerlink" title="使用相对于类路径的资源引用"></a><strong>使用相对于类路径的资源引用</strong></h3><p>绑定xml文件</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mappers&gt;<br>    &lt;mapper resource&#x3D;&quot;mybatis&#x2F;dao&#x2F;studentMapper.xml&quot;&#x2F;&gt;<br>&lt;&#x2F;mappers&gt;<br></code></pre></td></tr></table></figure>

<h3 id="使用class文件绑定注册"><a href="#使用class文件绑定注册" class="headerlink" title="使用class文件绑定注册"></a><strong>使用class文件绑定注册</strong></h3><p>绑定接口</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mappers&gt;<br>    &lt;mapper class&#x3D;&quot;mybatis.dao.studentMapper&quot;&gt;&lt;&#x2F;mapper&gt;<br>&lt;&#x2F;mappers&gt;<br></code></pre></td></tr></table></figure>

<p><strong>注：接口和他的Mapper配置文件必须同名，并在同一个包下</strong></p>
<h3 id="使用扫描包进行注入绑定"><a href="#使用扫描包进行注入绑定" class="headerlink" title="使用扫描包进行注入绑定"></a><strong>使用扫描包进行注入绑定</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mappers&gt;<br>    &lt;package name&#x3D;&quot;mybatis.dao&quot;&#x2F;&gt;<br>&lt;&#x2F;mappers&gt;<br></code></pre></td></tr></table></figure>

<p><strong>注：接口和他的Mapper配置文件必须同名，并在同一个包下</strong></p>
<h2 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a><strong>生命周期和作用域</strong></h2><p><strong>SqlSessionFactoryBuilder</strong></p>
<p>这个类可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了，因此SqlSessionFactoryBuilder实例的最佳作用域是方法作用域</p>
<p><strong>SqlSessionFactory</strong></p>
<p><strong>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在</strong>，没有任何理由丢弃它或重新创建另一个实例。多次重建 SqlSessionFactory 被视为一种代码“坏习惯”，因此 SqlSessionFactory 的最佳作用域是应用作用域，最简单的实现方法就是使用单例模式或者静态单例模式。</p>
<p><strong>SqlSession</strong></p>
<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。使用完之后需要关闭</p>
<h1 id="ResultMap结果映射集"><a href="#ResultMap结果映射集" class="headerlink" title="ResultMap结果映射集"></a><strong>ResultMap结果映射集</strong></h1><p>上面所写的pojo类的字段与数据库表中的字段是完全对应的。<br><img src="/2020/10/22/mybatis/stu_.jpg" alt="stu_"></p>
<p><img src="/2020/10/22/mybatis/pojo.jpg" alt="pojo"></p>
<p>考虑以下情况，若pojo类的字段名与数据库的字段名不一样，会出现什么情况？</p>
<p>如：</p>
<p>将pojo类的sname字段改为name，进行test1测试，此时输出</p>
<p>student{sno=201215121, name=’null’, sage=20, ssex=’男’, sdept=’cs’}<br>student{sno=201215122, name=’null’, sage=19, ssex=’女’, sdept=’cs’}<br>student{sno=201215123, name=’null’, sage=18, ssex=’女’, sdept=’ma’}<br>student{sno=201215124, name=’null’, sage=20, ssex=’男’, sdept=’cs’}<br>student{sno=201215125, name=’null’, sage=19, ssex=’男’, sdept=’is’}<br>student{sno=201215126, name=’null’, sage=21, ssex=’女’, sdept=’ma’}</p>
<p>发现name字段的值全为null</p>
<p>原因是查询语句中查询结果的字段为 sno、sname、sage、ssex、sdept，无法找到name这个字段，怎么样处理这个问题呢？</p>
<h2 id="在sql语句中起别名"><a href="#在sql语句中起别名" class="headerlink" title="在sql语句中起别名"></a><strong>在sql语句中起别名</strong></h2><p>回顾数据库的查询语句中的as关键字，它的作用是为某个字段子别名，此时在sql语句中为sname起别名为name，进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentList&quot; resultType&#x3D;&quot;student&quot; &gt;<br>select sno,sname as name,sage,ssex,sdept from dbtest01.stu;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<p>此时，成功输出name属性的值</p>
<p>student{sno=201215121, name=’李勇’, sage=20, ssex=’男’, sdept=’cs’}<br>student{sno=201215122, name=’刘晨’, sage=19, ssex=’女’, sdept=’cs’}<br>student{sno=201215123, name=’王敏’, sage=18, ssex=’女’, sdept=’ma’}<br>student{sno=201215124, name=’张三’, sage=20, ssex=’男’, sdept=’cs’}<br>student{sno=201215125, name=’张’, sage=19, ssex=’男’, sdept=’is’}<br>student{sno=201215126, name=’张四’, sage=21, ssex=’女’, sdept=’ma’}</p>
<h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a><strong>ResultMap</strong></h2><p>resultmap是一个结果集映射，resultmap元素是mybatis中最重要最强大的元素。resultmap的设计思想是，对简单的语句做到零配置，对于复杂一点的语句只需要描述语句之间的关系就行了。</p>
<p>回到上面的问题，使用resultmap将结果映射为pojo类中的属性，即可解决这个问题</p>
<p>在studentMapper.xml文件中添加resultMap标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!--    resultmap结果集映射--&gt;<br>&lt;!--    id为sql标签中的resultmap type为返回类型--&gt;<br>&lt;resultMap id&#x3D;&quot;studentMap&quot; type&#x3D;&quot;student&quot;&gt;<br>&lt;!--        column为数据库表中的字段 property为pojo类中的属性名--&gt;<br>    &lt;result column&#x3D;&quot;sname&quot; property&#x3D;&quot;name&quot;&gt;&lt;&#x2F;result&gt;<br>&lt;&#x2F;resultMap&gt;<br><br></code></pre></td></tr></table></figure>

<p>并将sql标签改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentList&quot; resultMap&#x3D;&quot;studentMap&quot; &gt;<br>select * from dbtest01.stu;<br>&lt;&#x2F;select&gt;<br><br></code></pre></td></tr></table></figure>

<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h1><p>通常，在平时写代码出现错误的时候，习惯使用debug或者sout来调试错误，但有时候错误很难找，这时候需要排错就显得很困难了，这时候我们就可以使用日志来帮助我们更有效地排错</p>
<h2 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a><strong>日志工厂</strong></h2><p>回顾config配置文件中的settings配置项，有logImpl这样一个属性，logImpl是一个日志框架，实现方式有SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING</p>
<p>其中最常用的有LOG4J、STDOUT_LOGGING</p>
<p><strong>以STDOUT_LOGGING为例</strong></p>
<p>这个日志的实现不用任何导包或者依赖的配置，直接就可以使用</p>
<p>配置setting配置项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;settings&gt;<br>    &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;<br>&lt;&#x2F;settings&gt;<br></code></pre></td></tr></table></figure>

<p>此时idea的输出端就会输出一大串东西</p>
<p><img src="/2020/10/22/mybatis/adapter.jpg" alt="adapter"></p>
<p>表示使用的日志工厂</p>
<p><img src="/2020/10/22/mybatis/deal.jpg" alt="deal"></p>
<p>表示idea进行的一些操作</p>
<p><img src="/2020/10/22/mybatis/jdbc.jpg" alt="jdbc"></p>
<p>这是真正的日志部分，记录了对数据库的每一个操作</p>
<p><strong>关于java日志，可以参考另外一篇博客，传送门：<a href="https://zleo-bug.github.io/2020/10/24/javarecord/">https://zleo-bug.github.io/2020/10/24/javarecord/</a></strong></p>
<h1 id="mybatis实现分页"><a href="#mybatis实现分页" class="headerlink" title="mybatis实现分页"></a><strong>mybatis实现分页</strong></h1><p>传送门：<strong><a href="https://zleo-bug.github.io/2020/10/24/mybatisPaging/">https://zleo-bug.github.io/2020/10/24/mybatisPaging/</a></strong></p>
<h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a><strong>注解开发</strong></h1><p>在一些简单的sql语句中，使用注解开发能够简化开发的步骤，利用一个简单的注释即可，不再需要配置接口对应的xml文件，注解的本质是通过反射实现的</p>
<p>如：</p>
<p>在studentMapper中添加新方法，并添加注释@Select</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Select(&quot;select * from dbtest01.stu&quot;)<br>public List&lt;student&gt; getStudents();<br></code></pre></td></tr></table></figure>

<p>核心xml文件中绑定studentMapper接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mappers&gt;<br>    &lt;mapper class&#x3D;&quot;mybatis.dao.studentMapper&quot;&gt;&lt;&#x2F;mapper&gt;<br>&lt;&#x2F;mappers&gt;<br></code></pre></td></tr></table></figure>

<p>测试方法进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void getStudentByAnnotation()&#123;<br>    SqlSession sqlSession &#x3D; myBatisUtil.getSqlSession();<br><br>    studentMapper mapper &#x3D; sqlSession.getMapper(studentMapper.class);<br><br>    List&lt;student&gt; students &#x3D; mapper.getStudents();<br><br>    for (student student : students) &#123;<br>        System.out.println(student);<br>    &#125;<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时发现console端成功输出数据库中的所有元组，同时也发现name的字段为空值</p>
<p><img src="/2020/10/22/mybatis/annonation.jpg" alt="annonation"></p>
<p>这是因为，使用注解并不能进行resultMap的映射，数据库的字段sname无法找到pojo类相对应的属性</p>
<p>因此，使用注解是有局限性的，只能适用于简单的sql语句</p>
<h2 id="基于注解的增删查改"><a href="#基于注解的增删查改" class="headerlink" title="基于注解的增删查改"></a><strong>基于注解的增删查改</strong></h2><p>关于@Param()注解：</p>
<p>在使用基于注解的sql语句时，要用到@Param()这个注解，它作用在方法参数上，绑定某个属性或多个属性</p>
<p>当参数为基本类型或者String类型时，要加上@Param()注解，当我们在写sql语句时，sql语句中引用的值就是@Param()里面指定的属性名</p>
<p>如果是引用类型，则可以不用添加此注释，sql语句中会根据引用类型中的属性名获取到相应的值</p>
<ul>
<li><p>增</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Insert(&quot;insert into dbtest01.stu values(#&#123;sno&#125;,#&#123;name&#125;,#&#123;sage&#125;,#&#123;ssex&#125;,#&#123;sdept&#125;);&quot;)<br>    public void add(student student);<br></code></pre></td></tr></table></figure></li>
<li><p>删</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Delete(&quot;delete from stu where id &#x3D; #&#123;id&#125;&quot;)<br>    public void delete(@Param(&quot;id&quot;) int id);<br></code></pre></td></tr></table></figure>
</li>
<li><p>查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Select(&quot;select * from stu where sno &#x3D; #&#123;sno&#125;&quot;)<br>    public student select(@Param(&quot;sno&quot;) int sno);<br></code></pre></td></tr></table></figure>
</li>
<li><p>改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Update(&quot;update stu set sname &#x3D; #&#123;sname&#125; where sno &#x3D; #&#123;sno&#125;&quot;)<br>    public void update(@Param(&quot;sno&quot;) int sno,@Param(&quot;sname&quot;) String sname);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="mybatis复杂查询"><a href="#mybatis复杂查询" class="headerlink" title="mybatis复杂查询"></a><strong>mybatis复杂查询</strong></h1><p>创建学生表student 教师表teacher</p>
<p><img src="/2020/10/22/mybatis/student.jpg" alt="student"></p>
<p><img src="/2020/10/22/mybatis/teacher.jpg" alt="teacher"></p>
<h2 id="多对一处理"><a href="#多对一处理" class="headerlink" title="多对一处理"></a><strong>多对一处理</strong></h2><p>创建两个pojo类 Student Teacher</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@NoArgsConstructor<br>@AllArgsConstructor<br>@Data<br>public class Student &#123;<br>    private int sno;<br>    private String sname;<br>    private Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@NoArgsConstructor<br>@AllArgsConstructor<br>@Data<br>public class Teacher &#123;<br>    private int tno;<br>    private String tname;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建Student\TeacherMapper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface StudentMapper &#123;<br>    <br>    public List&lt;Student&gt; getStudentInfo();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface TeacherMapper &#123;<br><br>    public List&lt;Teacher&gt; getTeacherList();<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>并进行相应配置</p>
<p>现在有一个需求：获得学生的学号、姓名、以及对应老师的信息</p>
<p>根据需求，很容易写出sql语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentInfo&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    select student.*,teacher.* from student,teacher<br>    where student.tno &#x3D; teacher.tno;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<p>此时进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void getStudentInfo()&#123;<br>    SqlSession sqlSession &#x3D; myBatisUtils.getSqlSession();<br><br>    StudentMapper studentMapper &#x3D; sqlSession.getMapper(StudentMapper.class);<br><br>    List&lt;Student&gt; students &#x3D; studentMapper.getStudentInfo();<br><br>    for (Student student : students) &#123;<br>        System.out.println(student);<br>    &#125;<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>查询结果：</p>
<p><img src="/2020/10/22/mybatis/stresult.jpg" alt="stresult"></p>
<p>结果发现teacher项为空</p>
<p>很容易理解，为什么teacher项是为空，因为没有与teacher项对应的字段，那这时候应该怎么办呢</p>
<p>此时的teacher属性比较复杂（属性为对象），需要进行单独处理，使用resultMap中的&lt;assocation&gt;标签对teacher属性进行单独处理，解决此类问题的答案就是：<strong>复杂的属性单独处理</strong></p>
<h3 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a><strong>按照查询嵌套处理</strong></h3><p>先查询出所有的学生信息，然后由学生信息中的字段tno到teacher表中找出相应的教师（相当于嵌套查询）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentInfo&quot; resultMap&#x3D;&quot;StudentTeacher&quot;&gt;<br>    select * from dbtest01.student;<br>&lt;&#x2F;select&gt;<br><br>&lt;resultMap id&#x3D;&quot;StudentTeacher&quot; type&#x3D;&quot;Student&quot;&gt;<br>    &lt;result property&#x3D;&quot;sno&quot; column&#x3D;&quot;sno&quot;&gt;&lt;&#x2F;result&gt;<br>    &lt;result property&#x3D;&quot;sname&quot; column&#x3D;&quot;sname&quot;&gt;&lt;&#x2F;result&gt;<br>&lt;!--        对于复杂的属性，单独处理--&gt;<br>    &lt;association property&#x3D;&quot;teacher&quot; column&#x3D;&quot;tno&quot; javaType&#x3D;&quot;Teacher&quot; select&#x3D;&quot;getTeacherInfo&quot;&gt;&lt;&#x2F;association&gt;<br>&lt;&#x2F;resultMap&gt;<br><br>&lt;select id&#x3D;&quot;getTeacherInfo&quot; resultType&#x3D;&quot;Teacher&quot;&gt;<br>    select * from teacher where tno &#x3D; #&#123;tno&#125;;<br>&lt;&#x2F;select&gt;<br><br></code></pre></td></tr></table></figure>

<p>&lt;assocation&gt;标签中，select属性为嵌套查询，通过column将tno的值传递给嵌套查询，javaType为嵌套查询中的结果类型，最后再有嵌套查询的结果与property匹配</p>
<h3 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a><strong>按照结果嵌套处理</strong></h3><p>先由连表查询查询出所有的信息，然后再对属性进行一一处理，此时相当于sql中的连表查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getStudentInfo&quot; resultMap&#x3D;&quot;StudentTeacher&quot;&gt;<br>    select * from student,teacher where student.tno &#x3D; teacher.tno;<br>&lt;&#x2F;select&gt;<br><br>&lt;resultMap id&#x3D;&quot;StudentTeacher&quot; type&#x3D;&quot;Student&quot;&gt;<br>    &lt;result property&#x3D;&quot;sno&quot; column&#x3D;&quot;sno&quot;&gt;&lt;&#x2F;result&gt;<br>    &lt;result property&#x3D;&quot;sname&quot; column&#x3D;&quot;sname&quot;&gt;&lt;&#x2F;result&gt;<br>&lt;!--        对于复杂的属性，单独处理--&gt;<br>    &lt;association property&#x3D;&quot;teacher&quot; javaType&#x3D;&quot;Teacher&quot; &gt;<br>        &lt;result property&#x3D;&quot;tno&quot; column&#x3D;&quot;tno&quot;&gt;&lt;&#x2F;result&gt;<br>        &lt;result property&#x3D;&quot;tname&quot; column&#x3D;&quot;tname&quot;&gt;&lt;&#x2F;result&gt;<br>    &lt;&#x2F;association&gt;<br>&lt;&#x2F;resultMap&gt;<br></code></pre></td></tr></table></figure>

<h2 id="一对多处理"><a href="#一对多处理" class="headerlink" title="一对多处理"></a><strong>一对多处理</strong></h2><p>当属性为集合的时候，使用/<collection>标签，并使用ofType代表集合中范型类型</collection></p>
<p>修改pojo类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@NoArgsConstructor<br>@AllArgsConstructor<br>@Data<br>public class Teacher &#123;<br>    private int tno;<br>    private String tname;<br>    private List&lt;Student&gt; studentList;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@NoArgsConstructor<br>@AllArgsConstructor<br>@Data<br>public class Student &#123;<br>    private int sno;<br>    private String sname;<br>&#x2F;&#x2F;    private Teacher teacher;<br>    private int tno;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在有如下需求：</p>
<p>获取指定教师的信息以及对应的学生信息</p>
<h3 id="根据结果嵌套处理"><a href="#根据结果嵌套处理" class="headerlink" title="根据结果嵌套处理"></a><strong>根据结果嵌套处理</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getTeacherInfo&quot; resultMap&#x3D;&quot;TeacherStudent&quot;&gt;<br>    select * from teacher,student where teacher.tno &#x3D; #&#123;tno&#125; and student.tno &#x3D; teacher.tno;<br>&lt;&#x2F;select&gt;<br><br>&lt;resultMap id&#x3D;&quot;TeacherStudent&quot; type&#x3D;&quot;Teacher&quot;&gt;<br>    &lt;result property&#x3D;&quot;tno&quot; column&#x3D;&quot;tno&quot;&gt;&lt;&#x2F;result&gt;<br>    &lt;result property&#x3D;&quot;tname&quot; column&#x3D;&quot;tname&quot;&gt;&lt;&#x2F;result&gt;<br>&lt;!--        ofType为studentList中的范型信息--&gt;<br>    &lt;collection property&#x3D;&quot;studentList&quot; ofType&#x3D;&quot;Student&quot;&gt;<br>        &lt;result property&#x3D;&quot;sno&quot; column&#x3D;&quot;sno&quot;&gt;&lt;&#x2F;result&gt;<br>        &lt;result property&#x3D;&quot;sname&quot; column&#x3D;&quot;sname&quot;&gt;&lt;&#x2F;result&gt;<br>        &lt;result property&#x3D;&quot;tno&quot; column&#x3D;&quot;tno&quot;&gt;&lt;&#x2F;result&gt;<br>    &lt;&#x2F;collection&gt;<br>&lt;&#x2F;resultMap&gt;<br><br></code></pre></td></tr></table></figure>

<p>返回如下信息：<br>Teacher(tno=1, tname=老张, studentList=[Student(sno=123, sname=张三, tno=1), Student(sno=124, sname=李四, tno=1), Student(sno=125, sname=王五, tno=1), Student(sno=126, sname=赵六, tno=1)])</p>
<h3 id="根据查询嵌套处理"><a href="#根据查询嵌套处理" class="headerlink" title="根据查询嵌套处理"></a><strong>根据查询嵌套处理</strong></h3><p>与多对一的情况一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getTeacherInfo&quot; resultMap&#x3D;&quot;TeacherStudent&quot;&gt;<br>    select * from teacher where tno &#x3D; #&#123;tno&#125;;<br>&lt;&#x2F;select&gt;<br><br>&lt;resultMap id&#x3D;&quot;TeacherStudent&quot; type&#x3D;&quot;Teacher&quot;&gt;<br>    &lt;result property&#x3D;&quot;tno&quot; column&#x3D;&quot;tno&quot;&gt;&lt;&#x2F;result&gt;<br>    &lt;result property&#x3D;&quot;tname&quot; column&#x3D;&quot;tname&quot;&gt;&lt;&#x2F;result&gt;<br>    &lt;collection property&#x3D;&quot;studentList&quot; column&#x3D;&quot;tno&quot;javaType&#x3D;&quot;ArrayList&quot; ofType&#x3D;&quot;Student&quot; select&#x3D;&quot;getStudentInfo&quot;&gt;&lt;&#x2F;collection&gt;<br>&lt;&#x2F;resultMap&gt;<br><br>&lt;select id&#x3D;&quot;getStudentInfo&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    select * from student where tno &#x3D; #&#123;tno&#125;;<br>&lt;&#x2F;select&gt;<br><br></code></pre></td></tr></table></figure>

<h1 id="动态sql语句"><a href="#动态sql语句" class="headerlink" title="动态sql语句"></a><strong>动态sql语句</strong></h1><p>动态sql就是指根据不同的条件生成不同的sql语句</p>
<p>pojo包下创建Blog类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Data<br>@AllArgsConstructor<br>public class Blog &#123;<br><br>    private String id;<br>    private String title;<br>    private String author;<br>    private Date createTime;<br>    private int views;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建blog表</p>
<p><img src="/2020/10/22/mybatis/blog.jpg" alt="blog"></p>
<p>其中的id用java中的UUID类实现</p>
<h2 id="常用的标签"><a href="#常用的标签" class="headerlink" title="常用的标签"></a><strong>常用的标签</strong></h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a><strong>if</strong></h3><p>if标签用来进行条件判断，例如：有一个需求，查询博客的时候，如果不给定某个字段，则查询数据库中的所有信息，若给定某个字段，则根据这个字段去查找相应的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;selectBlog&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt;<br>    select * from blog where 1&#x3D;1<br>    &lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;<br>        and author &#x3D; #&#123;author&#125;<br>    &lt;&#x2F;if&gt;<br><br>    &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;<br>        and title &#x3D; #&#123;title&#125;<br>    &lt;&#x2F;if&gt;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<p>其中，test=””为判断的条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void selectBlog()&#123;<br>    SqlSession sqlSession &#x3D; myBatisUtils.getSqlSession();<br><br>    BlogMapper mapper &#x3D; sqlSession.getMapper(BlogMapper.class);<br><br>    HashMap map &#x3D; new HashMap();<br><br>    map.put(&quot;author&quot;,&quot;睡什么睡&quot;);<br><br>    map.put(&quot;title&quot;,&quot;学习使我快乐&quot;);<br><br>    List&lt;Blog&gt; blogs &#x3D; mapper.selectBlog(map);<br><br>    for (Blog blog : blogs) &#123;<br>        System.out.println(blog);<br>    &#125;<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="where"><a href="#where" class="headerlink" title="where"></a><strong>where</strong></h3><p>在上面的if标签中，我们写了一个不规范的sql语句，那个语句只是为了测试方便才引入的，下面将sql语句改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from blog where<br>&lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;<br>    author &#x3D; #&#123;author&#125;<br>&lt;&#x2F;if&gt;<br>&lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;<br>	and title &#x3D; #&#123;title&#125;<br>&lt;&#x2F;if&gt;<br></code></pre></td></tr></table></figure>
<p>如果在测试的时候，参数map没有author对应的映射，此时的sql语句变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from blog where and title &#x3D; #&#123;title&#125;<br></code></pre></td></tr></table></figure>

<p>就会出现报错信息</p>
<p><strong>为了应付这种情况，在MyBatis中可以使用where标签来解决</strong></p>
<p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;selectBlog&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt;<br>    select * from blog<br>    &lt;where&gt;<br>        &lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;<br>            author &#x3D; #&#123;author&#125;<br>        &lt;&#x2F;if&gt;<br><br>        &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;<br>            and title &#x3D; #&#123;title&#125;<br>        &lt;&#x2F;if&gt;<br>    &lt;&#x2F;where&gt;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<h3 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose(when otherwise)"></a><strong>choose(when otherwise)</strong></h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;where&gt;<br>    &lt;choose&gt;<br>        &lt;when test&#x3D;&quot;author!&#x3D;null&quot;&gt;<br>            and author &#x3D; #&#123;author&#125;<br>        &lt;&#x2F;when&gt;<br>        &lt;when test&#x3D;&quot;title!&#x3D;null&quot;&gt;<br>            and title &#x3D; #&#123;title&#125;<br>        &lt;&#x2F;when&gt;<br>        &lt;otherwise&gt;&lt;&#x2F;otherwise&gt;<br><br>    &lt;&#x2F;choose&gt;<br>&lt;&#x2F;where&gt;<br></code></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h3><p>有时候在写sql语句的时候，比如更新操作，很容易因为多加或者少加一个逗号导致出错</p>
<p>set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;update id&#x3D;&quot;updateBlog&quot; parameterType&#x3D;&quot;Blog&quot;&gt;<br>    update blog<br>    &lt;set&gt;<br>        &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;<br>            title &#x3D; #&#123;title&#125;,<br>        &lt;&#x2F;if&gt;<br>        &lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;<br>            author &#x3D; #&#123;author&#125;,<br>        &lt;&#x2F;if&gt;<br>        &lt;if test&#x3D;&quot;createTime!&#x3D;null&quot;&gt;<br>            create_time &#x3D; #&#123;createTime&#125;,<br>        &lt;&#x2F;if&gt;<br>        views &#x3D; #&#123;views&#125;,<br>    &lt;&#x2F;set&gt;<br>    where id &#x3D; #&#123;id&#125;;<br>&lt;&#x2F;update&gt;<br><br></code></pre></td></tr></table></figure>
<h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a><strong>sql</strong></h3><p>有时，我们需要将一些公共的sql语句抽取出来，这时候就要用到sql标签喝include标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;sql id&#x3D;&quot;if-author-title&quot;&gt;<br>    &lt;where&gt;<br>        &lt;choose&gt;<br>            &lt;when test&#x3D;&quot;author!&#x3D;null&quot;&gt;<br>                and author &#x3D; #&#123;author&#125;<br>            &lt;&#x2F;when&gt;<br>            &lt;when test&#x3D;&quot;title!&#x3D;null&quot;&gt;<br>                and title &#x3D; #&#123;title&#125;<br>            &lt;&#x2F;when&gt;<br>            &lt;otherwise&gt;&lt;&#x2F;otherwise&gt;<br>        &lt;&#x2F;choose&gt;<br>    &lt;&#x2F;where&gt;<br>&lt;&#x2F;sql&gt;<br>&lt;select id&#x3D;&quot;selectBlog&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt;<br>    select * from blog<br>    &lt;include refid&#x3D;&quot;if-author-title&quot;&gt;&lt;&#x2F;include&gt;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a><strong>foreach</strong></h3><p>foreach标签的功能非常强大，它允许指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。</p>
<p>可以将任何可迭代对象（如List、Set等）、Map对象或者数组对象作为集合参数传递给foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p>
<p>如：当我们需要查询筛选出在某个集合中的blog时，就可以使用foreach标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;selectBlogForeach&quot; resultType&#x3D;&quot;Blog&quot; parameterType&#x3D;&quot;map&quot;&gt;<br>    select * from blog<br>    &lt;where&gt;<br>        &lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;id&quot; open&#x3D;&quot;and (&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;or&quot;&gt;<br>            id &#x3D; #&#123;id&#125;<br>        &lt;&#x2F;foreach&gt;<br>    &lt;&#x2F;where&gt;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<p>其中，collection为map中的键，item为collection中的元素类型，separator为分隔符</p>
<h1 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a><strong>Mybatis缓存</strong></h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a><strong>什么是缓存</strong></h2><p>缓存是临时存在内存中的数据，将用户经常查询的且不经常改变的数据放在缓存中，用户区查询数据就不用从磁盘上查询，而是从缓存中查询</p>
<h2 id="为什么使用缓存"><a href="#为什么使用缓存" class="headerlink" title="为什么使用缓存"></a><strong>为什么使用缓存</strong></h2><p>连接数据库非常消耗资源，为了减少和数据库的交互次数，减少系统开销，提高查询效率</p>
<h2 id="Mybatis缓存-1"><a href="#Mybatis缓存-1" class="headerlink" title="Mybatis缓存"></a><strong>Mybatis缓存</strong></h2><p>Mybatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存</p>
<p>Mybatis中默认定义了两级缓存：<strong>一级缓存</strong> 和 <strong>二级缓存</strong></p>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a><strong>一级缓存</strong></h3><p>默认情况下开启一级缓存（sqlsession级别），sqlsession在open和close之间有效</p>
<p>对于selectBlogById查询语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void selectBlogById()&#123;<br><br>    SqlSession sqlSession &#x3D; myBatisUtils.getSqlSession();<br><br>    BlogMapper mapper &#x3D; sqlSession.getMapper(BlogMapper.class);<br><br>    Blog blog &#x3D; mapper.selectBlogById(1);<br><br>    Blog blog1 &#x3D; mapper.selectBlogById(1);<br><br>    System.out.println(blog&#x3D;&#x3D;blog1);<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/22/mybatis/cache1.jpg" alt="cache1"></p>
<p>从创建连接池到关闭连接池，只执行了一次sql语句</p>
<p>缓存失效的情况：</p>
<ul>
<li>查询不同的信息</li>
<li>进行增删改操作会刷新原来的缓存，原因是增删改操作可能会改变原有数据</li>
</ul>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a><strong>二级缓存</strong></h3><p>二级缓存需要手动开启和配置，它是基于namespace级别的缓存</p>
<p>要使用二级缓存，先要在核心配置文件中显示开启缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;settings&gt;<br>    &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;<br>    &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;<br>    &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;<br>&lt;&#x2F;settings&gt;<br></code></pre></td></tr></table></figure>

<p>要在xxxMapper.xml文件中加上配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;cache&gt;<br>	properties...<br>&lt;cache&#x2F;&gt;<br></code></pre></td></tr></table></figure>
<p>当某个sqlsession.close的时候，一级缓存会进入二级缓存中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Test<br>public void selectBlogById()&#123;<br><br>    SqlSession sqlSession &#x3D; myBatisUtils.getSqlSession();<br><br>    SqlSession sqlSession1 &#x3D; myBatisUtils.getSqlSession();<br><br>    BlogMapper mapper &#x3D; sqlSession.getMapper(BlogMapper.class);<br><br>    Blog blog &#x3D; mapper.selectBlogById(1);<br><br>    sqlSession.close();<br><br>    BlogMapper mapper1 &#x3D; sqlSession1.getMapper(BlogMapper.class);<br><br>    Blog blog1 &#x3D; mapper1.selectBlogById(1);<br><br>    System.out.println(blog&#x3D;&#x3D;blog1);<br><br>    sqlSession1.close();<br><br>    &#125;<br> &#96;&#96;&#96; <br><br>![cache2wrong](cache2wrong.jpg)<br><br>此时发现执行了两次查询操作<br><br>若将查询语句放在xml文件中配置<br><br>![cache2true](cache2true.jpg)<br><br>发现二级缓存配置成功<br><br>**原因是：使用基于注解的二级缓存要在 需要开启二级缓存的dao接口中添加如下注释**<br><br></code></pre></td></tr></table></figure>
<p>@CacheNamespace(blocking = true)</p>
<pre><code>
</code></pre>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>SSM框架</tag>
        <tag>数据库</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>常用sql语句</title>
    <url>/2020/10/21/dboperator/</url>
    <content><![CDATA[<p>掌握sql语句是后端程序员与数据库打交道的必备技能，下面简单回顾一下一些常用的sql语句</p>
<h1 id="对数据库的操作"><a href="#对数据库的操作" class="headerlink" title="对数据库的操作"></a><strong>对数据库的操作</strong></h1><h2 id="终端进入数据库："><a href="#终端进入数据库：" class="headerlink" title="终端进入数据库："></a><strong>终端进入数据库：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mysql -u root -p<br></code></pre></td></tr></table></figure>
<h2 id="查看所有的数据库："><a href="#查看所有的数据库：" class="headerlink" title="查看所有的数据库："></a><strong>查看所有的数据库：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">show databases;<br></code></pre></td></tr></table></figure>
<h2 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a><strong>创建数据库：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">create database dbname;<br></code></pre></td></tr></table></figure>
<h2 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a><strong>删除数据库：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">drop database dbname;<br></code></pre></td></tr></table></figure>
<h2 id="选择数据库："><a href="#选择数据库：" class="headerlink" title="选择数据库："></a><strong>选择数据库：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">use dbname;<br></code></pre></td></tr></table></figure>
<h2 id="查看当前数据库中的所有表："><a href="#查看当前数据库中的所有表：" class="headerlink" title="查看当前数据库中的所有表："></a><strong>查看当前数据库中的所有表：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">show tables;<br></code></pre></td></tr></table></figure>
<h1 id="对表结构的操作"><a href="#对表结构的操作" class="headerlink" title="对表结构的操作"></a><strong>对表结构的操作</strong></h1><h2 id="查看表的结构："><a href="#查看表的结构：" class="headerlink" title="查看表的结构："></a><strong>查看表的结构：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">desc tablename;<br></code></pre></td></tr></table></figure>
<h2 id="查看表的创建语句："><a href="#查看表的创建语句：" class="headerlink" title="查看表的创建语句："></a><strong>查看表的创建语句：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">show create table newtable;<br></code></pre></td></tr></table></figure>
<h2 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a><strong>创建表：</strong></h2><pre><code>create table table_name(
字段名1 数据类型1 可选的约束条件1,
字段名2 数据类型2 可选的约束条件2,
...
）；</code></pre>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">create table newtable(<br>id int primary key not null,<br>name varchar(10) not null,<br>age int<br>);<br></code></pre></td></tr></table></figure>
<h2 id="删除表："><a href="#删除表：" class="headerlink" title="删除表："></a><strong>删除表：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">drop table newtable;<br></code></pre></td></tr></table></figure>
<h2 id="修改表："><a href="#修改表：" class="headerlink" title="修改表："></a><strong>修改表：</strong></h2><p>添加字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">alter table newtable add address varchar(10);<br></code></pre></td></tr></table></figure>
<p>重命名字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">alter table newtable change address addr varchar(10);<br></code></pre></td></tr></table></figure>
<p>修改字段类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">alter table newtable modify id varchar(10);<br></code></pre></td></tr></table></figure>
<p>修改字段约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">alter table newtable modify id int;<br></code></pre></td></tr></table></figure>
<p>删除字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">alter table newtable drop addr;<br></code></pre></td></tr></table></figure>
<p>设置默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">alter table newtable alter age set default 0;<br></code></pre></td></tr></table></figure>
<p>删除默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">alter table newtable alter age drop default;<br></code></pre></td></tr></table></figure>
<h1 id="对表内容的增删查改"><a href="#对表内容的增删查改" class="headerlink" title="对表内容的增删查改"></a><strong>对表内容的增删查改</strong></h1><h2 id="基本查询语句"><a href="#基本查询语句" class="headerlink" title="基本查询语句"></a><strong>基本查询语句</strong></h2><p><strong>查询表的所有字段：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from tablename;<br></code></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable<br></code></pre></td></tr></table></figure>
<p><strong>查询指定的字段：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select n1,n2,n3,... from tablename;	<br></code></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select id,name from newtable<br></code></pre></td></tr></table></figure>
<p><strong>as关键字：</strong></p>
<p>给字段起别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select id as 学号,name as 姓名 from newtable<br></code></pre></td></tr></table></figure>
<p>给表起别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select t.id,t.name from newtable as t;<br></code></pre></td></tr></table></figure>
<h2 id="条件查询语句"><a href="#条件查询语句" class="headerlink" title="条件查询语句"></a><strong>条件查询语句</strong></h2><h3 id="使用比较运算符进行查询"><a href="#使用比较运算符进行查询" class="headerlink" title="使用比较运算符进行查询"></a><strong>使用比较运算符进行查询</strong></h3><p>比较运算符：= &gt; ≥ &lt; ≤ !=</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select id,name from newtable where age&gt;&#x3D;18<br><br>select id,name from newtable where name&#x3D;&quot;张三&quot;<br></code></pre></td></tr></table></figure>
<h3 id="使用逻辑运算符进行查询"><a href="#使用逻辑运算符进行查询" class="headerlink" title="使用逻辑运算符进行查询"></a><strong>使用逻辑运算符进行查询</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select id,name from newtable where id&gt;1235 and age&gt;18<br><br>select * from newtable where age&gt;18 or sex&#x3D;&#39;男&#39;<br></code></pre></td></tr></table></figure>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a><strong>模糊查询</strong></h3><p>模糊查询使用like进行查询，%代表任意多个关键字 下划线_ 表示任意一个字符</p>
<p>一般模糊查询语句如：SELECT 字段 FROM 表 WHERE 某字段 [not]Like 条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable where name like &quot;张%&quot;<br><br>select * from newtable where name like &quot;_一&quot;<br></code></pre></td></tr></table></figure>
<p>如果字段名字中存在 下划线_ 或者 百分号%，此时要进将字符转义，转义要在语句后面加上 escape’’</p>
<p>如，表中字段存在下划线，则查询为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable where addr like &#39;%&#x2F;_%&#39; escape &#39;&#x2F;&#39;<br></code></pre></td></tr></table></figure>
<p>[]：表示匹配括号中所列字符的任意一个，类似正则表达式</p>
<p> 如果[ ] 内有一系列字符（01234、abcde之类的）则可略写为“0-4”、“a-e” </p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable where name like &#39;张[三七八]&#39;;<br></code></pre></td></tr></table></figure>
<p>[^ ]表示表示不在括号所列之内的单个字符。</p>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a><strong>范围查询</strong></h3><p>范围查询分为连续查询和非连续查询</p>
<p>in关键字表示一个非连续的范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable where age in(18,19,20);<br></code></pre></td></tr></table></figure>
<p>between and 表示在一个连续的范围内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable where age between 17 and 22;<br></code></pre></td></tr></table></figure>

<h3 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a><strong>空判断</strong></h3><p>判断字段是否为空： is null</p>
<p>不为空：is not null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable where addr is not null<br></code></pre></td></tr></table></figure>
<h3 id="exists语句"><a href="#exists语句" class="headerlink" title="exists语句"></a><strong>exists语句</strong></h3><p>使用exists判断某行是否存在</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h3><p>排序的查询语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]<br></code></pre></td></tr></table></figure>
<p>asc为升序，desc为降序，默认为asc</p>
<p>order by 语句只能对最终结果进行排序</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable order by id asc,age desc;<br></code></pre></td></tr></table></figure>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a><strong>分页</strong></h3><p>获取所有数据的前n-m条：select * from 表名 limit start=n,count=m，start默认为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select * from newtable limit 1,5;<br></code></pre></td></tr></table></figure>
<h3 id="取字段值唯一"><a href="#取字段值唯一" class="headerlink" title="取字段值唯一"></a><strong>取字段值唯一</strong></h3><p>distinct 关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select distinct age from newtable<br></code></pre></td></tr></table></figure>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a><strong>聚合函数</strong></h3><h4 id="求总数："><a href="#求总数：" class="headerlink" title="求总数："></a><strong>求总数：</strong></h4><p>count( * )：统计元组个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select count(*) from newtable<br></code></pre></td></tr></table></figure>
<p>count([distinct|all]列名)：统计某列值的个数</p>
<h4 id="求最大值："><a href="#求最大值：" class="headerlink" title="求最大值："></a><strong>求最大值：</strong></h4><p>max(某列)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select max(age) from newtable<br></code></pre></td></tr></table></figure>
<h4 id="求最小值："><a href="#求最小值：" class="headerlink" title="求最小值："></a><strong>求最小值：</strong></h4><p>min(某列)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select min(age) from newtable<br></code></pre></td></tr></table></figure>
<h4 id="求和："><a href="#求和：" class="headerlink" title="求和："></a><strong>求和：</strong></h4><p>sum(某列)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select sum(age) from newtable<br></code></pre></td></tr></table></figure>
<h4 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a><strong>平均值</strong></h4><p>avg(某列)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select avg(age) from newtable<br></code></pre></td></tr></table></figure>
<h3 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a><strong>分组操作</strong></h3><p>分组操作使用group by，将查询返回的结果集进行一个分组，并展示各个分组中排在第一个的记录，将分组中其余成员隐藏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select avg(age) from newtable group by sex<br></code></pre></td></tr></table></figure>
<h3 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a><strong>having子句</strong></h3><p>HAVING 子句是一个高配版的 where 子句，无论是我们的分组或是排序，都是基于以返回的结果集，也就是说 where 子句的筛选已经结束。<br>如果我们对排序、分组后的数据集依然有筛选需求，就要用到 HAVING 子句了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select avg(age) as avg_age from newtable group by sex<br>having avg_age &gt; 20;<br></code></pre></td></tr></table></figure>
<h2 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a><strong>插入语句</strong></h2><p>插入语句的一般格式为：insert into tablename(…) values(…);</p>
<p>全列插入：值的顺序与表结构字段的顺序完全一一对应</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">insert into newtable values (1241,&quot;张三&quot;,22,&quot;男&quot;,&quot;北京市_&quot;);<br></code></pre></td></tr></table></figure>
<p>部分列插入：值的顺序与给出的列顺序对应，此时需要根据实际的数据的特点 填写对应字段列表</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">insert into newtable(id,name,sex) values (1242,&quot;张三&quot;,&quot;男&quot;);<br></code></pre></td></tr></table></figure>
<p>全列多行插入：</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">insert into newtable values (1245,&quot;张三&quot;,22,&quot;男&quot;,&quot;北京市_&quot;),(1246,&quot;张三&quot;,22,&quot;男&quot;,&quot;北京市_&quot;);<br></code></pre></td></tr></table></figure>
<p>部分列多行插入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">insert into newtable(id,name,age) values(1222,&quot;li&quot;,21),(1223,&quot;zhang&quot;,22);<br></code></pre></td></tr></table></figure>
<h2 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a><strong>删除语句</strong></h2><p>删除语句的一般格式为：delete from tablename where 条件</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">delete from newtable where id&#x3D;1242 or id&#x3D;1241<br></code></pre></td></tr></table></figure>
<h2 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a><strong>修改语句</strong></h2><p>修改语句的一般格式为：update tablename set 列1=值1,列2=值2… where 条件</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">update newtable set name&#x3D;&quot;菜逼&quot;,age&#x3D;21 where id&#x3D;1246;<br></code></pre></td></tr></table></figure>
<h1 id="多表查询操作"><a href="#多表查询操作" class="headerlink" title="多表查询操作"></a><strong>多表查询操作</strong></h1><p>创建学生表stu、课程表course、学生选课表sc</p>
<p>stu:</p>
<p><img src="/2020/10/21/dboperator/stu.png" alt="stu"></p>
<p>course:</p>
<p><img src="/2020/10/21/dboperator/course.png" alt="course"></p>
<p>sc:</p>
<p><img src="/2020/10/21/dboperator/sc.png" alt="sc"></p>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a><strong>连接查询</strong></h2><p>连接查询的where子句中用来连接两个表的条件称为 连接条件</p>
<p>主要的连接条件为比较运算符，主要有 = &gt; &lt; ≥ ≤ !=等</p>
<p>一般格式为：[table1] c1 比较运算符 [table2] c2</p>
<p>如：</p>
<p>查询每个学生及其选修课程的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select sum(ccredit)<br>from sc,course<br>where sc.sno&#x3D;&#39;201215121&#39; and sc.cno&#x3D;course.cno<br></code></pre></td></tr></table></figure>

<p>查询选修2号课程且成绩在80分以上的所有学生的学号和姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select stu.sno,stu.sname<br>from stu,sc<br>where stu.sno&#x3D;sc.sno and sc.cno&#x3D;&#39;2&#39; and sc.grade&gt;80;<br><br></code></pre></td></tr></table></figure>
<h2 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a><strong>自身连接</strong></h2><p>如：</p>
<p>查询每一门课的间接先修课</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select first.cno,second.cpno<br>from course first,course second<br>where first.cpno &#x3D; second.cno;<br></code></pre></td></tr></table></figure>

<h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a><strong>多表连接</strong></h2><p>如：</p>
<p>查询每个学生的学号、姓名、选修的课程名及成绩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select stu.sno,stu.sname,course.cno,sc.grade<br>from stu,course,sc<br>where stu.sno&#x3D;sc.sno and course.cno &#x3D; sc.cno<br><br></code></pre></td></tr></table></figure>
<h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a><strong>嵌套查询</strong></h2><p>一个select-from-where语句称为一个查询块，将一个查询块放在另一个查询块的where子句或having短语的条件中称为嵌套查询</p>
<p>嵌套查询中，子查询的结果往往是一个集合，所以谓词in是嵌套查询中最常使用的谓词</p>
<p>如：</p>
<p>查询与“刘晨”在同一个系的学生</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select *<br>from stu<br>where sdept in <br>(select sdept<br>from stu<br>where sname&#x3D;&quot;刘晨&quot;);<br></code></pre></td></tr></table></figure>

<p>查询选修了课程名为“信息系统”的学生学号和姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select sno,sname<br>from stu<br>where sno in <br>	(select sno<br>	from sc<br>	where sc.cno in<br>		(select course.cno<br>		from course<br>		where course.cname&#x3D;&quot;信息系统&quot;));<br></code></pre></td></tr></table></figure>

<p>若采用连接查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select stu.sno,stu.sname<br>from stu,sc,course<br>where course.cname&#x3D;&quot;信息系统&quot; and course.cno &#x3D; sc.cno and stu.sno &#x3D; sc.sno;<br></code></pre></td></tr></table></figure>
<p>在实际应用中，能使用连接查询尽量使用连接查询</p>
<h3 id="带有any、all谓词的子查询"><a href="#带有any、all谓词的子查询" class="headerlink" title="带有any、all谓词的子查询"></a><strong>带有any、all谓词的子查询</strong></h3><blockquote>
<p>any 大于子查询中任何一个<br>&lt; any 小于子查询中任何一个<br>all 大于子查询中所有<br>&lt; all 小于子查询中所有<br>…</p>
</blockquote>
<p>如：</p>
<p>查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select sname,sage<br>from stu<br>where sage &lt; any<br>(<br>	select sage<br>	from stu<br>	where sdept&#x3D;&#39;cs&#39;) and sdept!&#x3D;&#39;cs&#39;;<br></code></pre></td></tr></table></figure>
<h3 id="带有exists谓词的子查询"><a href="#带有exists谓词的子查询" class="headerlink" title="带有exists谓词的子查询"></a>带有exists谓词的子查询</h3><p>exists表示存在量词，带有exists谓词的子查询只返回逻辑值，exists的作用域为子查询</p>
<p>流程为：取出外层查询的元组，根据它进行内层查询，如果返回值为真，则存入结果集</p>
<p>如：</p>
<p>查询所有选修了1号课程的学生姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select sname<br>from stu<br>where exists<br>(select sno<br>from sc<br>where sc.sno &#x3D; stu.sno and cno&#x3D;&#39;1&#39;);<br><br></code></pre></td></tr></table></figure>
<p>与exists对应的是not exists</p>
<p>如：</p>
<p>查询没有选修1号课程的学生姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select sname<br>from stu<br>where not exists<br>(select *<br>from sc<br>where stu.sno&#x3D;sc.sno and cno&#x3D;&#39;1&#39;);<br></code></pre></td></tr></table></figure>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a><strong>集合查询</strong></h3><p>select语句的查询结果为元组的集合，所以多个select语句的结果可进行集合操作</p>
<p>集合操作主要有 并操作union、交操作intersect、差操作except</p>
<p><strong>注：参加集合操作的各查询结果的列数必须相同，对应的数据类型也必须相同</strong></p>
<p>如：</p>
<p>查询计算机科学系的学生及年龄不大于19岁的学生</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select *<br>from stu<br>where sdept&#x3D;&#39;cs&#39;<br><br>union<br><br>select *<br>from stu<br>where sage&lt;&#x3D;19<br></code></pre></td></tr></table></figure>
<p>查询计算机科学系的学生与年龄不大于19岁的学生的交集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select *<br>from stu<br>where sdept&#x3D;&#39;cs&#39;<br><br>intersect<br><br>select *<br>from stu<br>where sage&lt;&#x3D;19;<br></code></pre></td></tr></table></figure>
<p>查询计算机科学系的学生与年龄不大于19岁的学生的差集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">select *<br>from stu<br>where sdept&#x3D;&#39;cs&#39;<br><br>except<br><br>select *<br>from stu<br>where sage&lt;&#x3D;19;<br></code></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>java jdbc的基本使用</title>
    <url>/2020/10/20/javadb/</url>
    <content><![CDATA[<p>今天在做java实验的时候用到了jdbc，现在顺便复习一下jdbc的操作。</p>
<h1 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC"></a><strong>什么是JDBC</strong></h1><p>JDBC全称为 Java Database Connectivity ，jdbc可以通过载入不同的数据库的驱动程序与不同的数据库进行连接</p>
<h1 id="jdbc的使用"><a href="#jdbc的使用" class="headerlink" title="jdbc的使用"></a><strong>jdbc的使用</strong></h1><p>要想使用jdbc，首先要导入对应数据库的驱动类：</p>
<p><img src="/2020/10/20/javadb/jar.jpg" alt="jar"></p>
<p>jdbc的使用流程为：</p>
<p>1.注册驱动<br>2.获取连接<br>3.执行SQL语句<br>4.获取结果<br>5.关闭连接</p>
<h2 id="注册驱动"><a href="#注册驱动" class="headerlink" title="注册驱动"></a><strong>注册驱动</strong></h2><p>注册驱动的语句为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Class.forName(JDBC_DRIVER);<br></code></pre></td></tr></table></figure>
<p>JDBC_DRIVER为对应的数据库驱动，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">String JDBC_DRIVER &#x3D; &quot;com.mysql.cj.jdbc.Driver&quot;;<br></code></pre></td></tr></table></figure>
<p>值得注意的是Class.forName为反射中的知识，若找不到相应的类名，它会抛出一个异常，所以必须使用try-catch处理异常或者声明异常</p>
<h2 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a><strong>获取连接</strong></h2><p>获取连接的目的是获取Connection对象，可通过DriverManager类的getConnection方法获取</p>
<p>其中getConnection方法中有三个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">getConnection(url,user,pwd);<br></code></pre></td></tr></table></figure>
<p>url为连接数据库的路径，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">String DB_URL &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC&amp;useServerPrepStmts&#x3D;true&amp;cachePrepStmts&#x3D;true&quot;;<br></code></pre></td></tr></table></figure>
<p>其中，detest01为路径上的某个数据库</p>
<p>characterEncoding=utf-8设置为中文</p>
<p>serverTimezone=UTC表示当前时区</p>
<p>useServerPrepStmts=true 表示preparedstatement进行预编译，默认preparedstatement不会进行预编译</p>
<p>cachePrepStmts=true表示缓存，当使用不同的PreparedStatement对象来执行相同的SQL语句时，还是会出现编译两次的现象，这是因为驱动没有缓存编译后的函数key，导致二次编译。</p>
<p>user和pwd分别为数据库用户名和密码</p>
<p>获取连接的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">private static final String user &#x3D; &quot;root&quot;;<br><br>   private static final String password &#x3D; &quot;111111&quot;;<br><br>   private static final String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbtest01?characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC&amp;useServerPrepStmts&#x3D;true&amp;cachePrepStmts&#x3D;true&quot;;<br><br>   private static final String jdbc_driver &#x3D; &quot;com.mysql.cj.jdbc.Driver&quot;;<br><br>   ...<br><br>   Class.forName(jdbc_driver);<br><br>   connection &#x3D; DriverManager.getConnection(url,user,password);<br></code></pre></td></tr></table></figure>
<h2 id="执行sql语句"><a href="#执行sql语句" class="headerlink" title="执行sql语句"></a><strong>执行sql语句</strong></h2><p>JDBC执行sql语句的方式主要使用Statement对象或PreparedStatement对象</p>
<h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a><strong>Statement</strong></h3><p>要获取Statement对象，要使用Connection对象的createStatement(sql)方法</p>
<p>statement对象中有几种对数据库操作的方法：</p>
<ul>
<li>statement.execute()</li>
</ul>
<p>execute()方法返回一个boolean值，表示sql语句执行成功或者失败</p>
<ul>
<li>statement.executeQuery()</li>
</ul>
<p>对于查询类的sql语句，通常使用executeQuery()方法，该方法返回一个ResultSet结果集</p>
<ul>
<li>statement.executeUpdate()</li>
</ul>
<p>对于更新类的sql语句，通常使用executeUpdate()方法，返回结果是一个整数,表示受影响的行数</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">statement &#x3D; connection.createStatement(&quot;select * from table&quot;);<br>ResultSet resultSet &#x3D; statement.executeQuery();<br></code></pre></td></tr></table></figure>
<p><strong>要注意statement中的sql语句要将所有的数据都填充好才可以</strong></p>
<p>如执行插入语句，String sql = “insert into stu values(1,2,3);”</p>
<p>必须把数据给提前写好才可以</p>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a><strong>PreparedStatement</strong></h3><p>要获取PreparedStatement对象，使用Connection对象的prepareStatement(sql)方法</p>
<p>PrepareStatement的功能与Statement相似，但不同的是，PrepareStatement可以使用占位符,它是由占位符标识需要输入数据的位置，然后再逐一填入数据。当然，PreparedStatement也可以执行没有占位符的sql语句</p>
<p>如执行插入语句，String sql = “insert into stu values(?,?,?);”</p>
<p>使用占位符后便可以在sql语句执行前再填充数据</p>
<p>要填充数据，要使用PreparedStatement对象的setXX方法</p>
<p>setXXX方法中，XXX是要填充的数据类型</p>
<p>setXXX方法中有两个参数，第一个参数是参数在表中的位置，第二个参数是参数的值</p>
<p><strong>注：第一个参数中，参数下表是从1开始的</strong></p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">String sql &#x3D; &quot;insert into stu values(?,?,?);&quot;;<br><br>PreparedStatement statement &#x3D; connection.prepareStatement(sql);<br><br>statement.setInt(1,no);<br><br>statement.setString(2,name);<br><br>statement.setInt(3,age);<br></code></pre></td></tr></table></figure>
<p>在获取了statement对象后，便可调用想使用的执行方法执行sql语句</p>
<h2 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a><strong>获取结果</strong></h2><p>sql语句的返回结果是一个结果集，ResultSet主要用于存储结果集，可以通过next()方法由前向后逐个获取结果集中的数据</p>
<p>在resultset中，可以使用getXXX(index)获得下标为index的值，或者使用getXXX(“property_name”)通过属性名获得相应的值，其中XXX为数据类型</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">statement.executeQuery();<br>ResultSet resultSet &#x3D; statement.getResultSet();<br>while(resultSet.next())&#123;<br>       int sno &#x3D; resultSet.getInt(&quot;sno&quot;);<br>       String sname &#x3D; resultSet.getString(&quot;sname&quot;);<br>       System.out.println(sno + sname);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><strong>注：要想获得resultSet中的数据，首先要使用resultSet.next()方法，否则会报错</strong></p>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h2><p>在执行完数据库操作后，通常要关闭和数据库的连接</p>
<p>使用.close()关闭连接，通常放在finally中执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">resultSet.close();<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h1><p>把一系列要执行的操作称为事务，而事务管理就是管理这些操作要么完全执行，要么完全不执行，所有命令全部成功执行才意味着该事务的成功，任何一个命令失败都意味着该事务的失败。</p>
<h2 id="事务管理的特性"><a href="#事务管理的特性" class="headerlink" title="事务管理的特性"></a><strong>事务管理的特性</strong></h2><p>原子性：事务的整个操作是一个整体，不可以分割，要么都做，要么都不做。</p>
<p>一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>隔离性：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>持久性：事务一旦被提交了，那么对数据库中的数据的改变就是永久性的</p>
<h2 id="JDBC中事务管理操作"><a href="#JDBC中事务管理操作" class="headerlink" title="JDBC中事务管理操作"></a><strong>JDBC中事务管理操作</strong></h2><p>JDBC中，Connection有三个方法与事务操作有关</p>
<ul>
<li>setAutoCommit(boolean)</li>
</ul>
<p>要想进行事务管理，在进行相应的sql操作之前，要执行：</p>
<pre><code>connection.setAutoCommit(false);</code></pre>
<p>取消事务的自动提交，setAutoCommit的默认值为true</p>
<ul>
<li>commit()</li>
</ul>
<p>commit表示提交事务</p>
<ul>
<li>rollback()</li>
</ul>
<p>rollbakc表示回滚，通常在处理异常或出现错误的时候进行</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>数据库</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax简介</title>
    <url>/2020/10/13/ajax/</url>
    <content><![CDATA[<h1 id="什么是ajax"><a href="#什么是ajax" class="headerlink" title="什么是ajax"></a><strong>什么是ajax</strong></h1><p>Ajax即“Asynchronous Javascript And XML”(异步JavaScript 和XML)，是指一种创建交互式网页应用的网页开发技术。通过在后台与服务器进行少量数据交换，Ajax可以使用网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新（无刷新技术）。传统的网页（不使用Ajax）如果需要更新内容，必须重载整个网页页面。</p>
<p>使用ajax，要在html或jsp文件中加上对ajax的引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;s3.pstatp.com&#x2F;cdn&#x2F;expire-1-M&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<p>一个完整的ajax常用请求如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>       function uservalidator() &#123;<br>           $.ajax(&#123;<br>           	&#x2F;&#x2F;请求的url地址<br>               url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;test&quot;,<br>               &#x2F;&#x2F;参数值 可以传递Json字符串类型 也可以传递对象类型<br>               data:&#123;&quot;name&quot;:$(&quot;#user&quot;).val(),&quot;passwords&quot;:$(&quot;#passwords&quot;).val()&#125;,<br>               &#x2F;&#x2F;参数类型<br>               &#x2F;&#x2F;dataType:&quot;json&quot;,<br>               &#x2F;&#x2F;请求方式<br>               type:&quot;GET&quot;,<br>               &#x2F;&#x2F;回调函数<br>               success:function (data) &#123;<br>                   $(&quot;#usermsg&quot;).html(data)<br>               &#125;<br>           &#125;)<br>       &#125;<br>   &lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
<p>也可以将ajax换成相应的请求方法    $.get({…})、$.post({…}) 等等</p>
<p>ajax与mvc的交互过程如下：</p>
<p><img src="/2020/10/13/ajax/process.jpg" alt="process"></p>
<h1 id="ajax和jsp"><a href="#ajax和jsp" class="headerlink" title="ajax和jsp"></a><strong>ajax和jsp</strong></h1><p>为什么现在前后端的数据交互基本上不用jsp而使用html+ajax？</p>
<p>首先要理解jsp的原理和ajax的原理</p>
<ul>
<li>jsp原理：</li>
</ul>
<p>jsp的本质是servlet，服务器通过相应的请求找到jsp页面并将jsp页面转换成java程序（servlet），后台把返回的数据通过这段java代码将结果按照html的格式输出给前端浏览器显示。在jsp中，html和java代码相结合</p>
<ul>
<li>ajax原理：</li>
</ul>
<p>服务器通过json直接把数据返回给前端浏览器，而浏览器中使用js解析数据，并改变浏览器中的内容</p>
<ul>
<li>jsp的缺点：</li>
</ul>
<p>1.动态和静态资源放在一起，一旦服务器出现状况，前后台一起玩完，用户体验极差。</p>
<p>2.一旦jsp出现了问题，就需要前端后端发开人员一块来分析解决，效率低。</p>
<p>3.jsp无法使用nginx等。</p>
<p>4.jsp页面复杂，难以修改。</p>
<p>5.第一次加载jsp需要编译成servlet，时间久，而且业务量大的时候，jsp负担太大。</p>
<p>6.jsp技术无法动态的展示数据，返回数据的时候都是整个页面一起返回，没有办法做到前后端分离</p>
<p>由于jsp的这些缺点，前后端分离的思想很快就开始流行了</p>
<p>** 项目开发的趋势：实现前后端的真正解耦**</p>
<p>以前的老项目中：</p>
<p>客户端请求 -&gt; 服务端处理请求 -&gt; 业务逻辑 -&gt; 解析jsp文件 -&gt; 返回jsp</p>
<p>新的方式：</p>
<p>客户端请求 -&gt; html页面调用接口产生数据（ajax、json） -&gt; html动态改变内容</p>
<p>前后端各管各，要进行数据交互的时候，只要使用前后端约定好的接口进行交互即可</p>
<p><strong>但是jsp和ajax并不冲突，很多网站往往将两者结合，比如，首屏的渲染使用jsp，数据的交互使用ajax</strong></p>
<h1 id="ajax与mvc交互实例"><a href="#ajax与mvc交互实例" class="headerlink" title="ajax与mvc交互实例"></a><strong>ajax与mvc交互实例</strong></h1><h2 id="模仿注册页面中账号和密码的有效性检验"><a href="#模仿注册页面中账号和密码的有效性检验" class="headerlink" title="模仿注册页面中账号和密码的有效性检验"></a><strong>模仿注册页面中账号和密码的有效性检验</strong></h2><p>User类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class User &#123;<br><br>    @NotBlank(message &#x3D; &quot;用户名不能为空&quot;)<br>    private String name;<br>    @NotBlank(message &#x3D; &quot;密码不能为空&quot;)<br>    @Length(min &#x3D; 3,max &#x3D; 8,message &#x3D; &quot;密码位数为3-8位&quot;)<br>    private String passwords;<br><br>    public String getPasswords() &#123;<br>        return passwords;<br>    &#125;<br><br>    public String getName() &#123;<br>        return name;<br>    &#125;<br><br>    public void setPasswords(String passwords) &#123;<br><br>        this.passwords &#x3D; passwords;<br>    &#125;<br><br>    public void setName(String name) &#123;<br>        this.name &#x3D; name;<br>    &#125;<br><br>    public String toString()&#123;<br>        return &quot;[name&#x3D;&quot;+name+&quot;,passwords&#x3D;&quot;+passwords+&quot;]&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>UserController：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class UserController &#123;<br><br>    @RequestMapping(&quot;&#x2F;test&quot;)<br>    @ResponseBody<br>    public String test(User user)&#123;<br>&#x2F;&#x2F;        System.out.println(user+&quot; &quot;+passwords);<br>        System.out.println(user);<br>        String msg &#x3D; &quot;&quot;;<br>        if(user.getName()!&#x3D;null)&#123;<br>            if(user.getName().equals(&quot;123&quot;))&#123;<br>                msg &#x3D;  &quot;ok&quot;;<br>            &#125;else&#123;<br>                msg &#x3D;  &quot;failed&quot;;<br>            &#125;<br>        &#125;<br>        if(user.getPasswords()!&#x3D;null)&#123;<br>            if(user.getPasswords().equals(&quot;1233&quot;))&#123;<br>                msg &#x3D;  &quot;ok&quot;;<br>            &#125;else&#123;<br>                msg &#x3D; &quot;failed&quot;;<br>            &#125;<br>        &#125;<br>        return msg;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>jsp文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;&#x2F;title&gt;<br>    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;s3.pstatp.com&#x2F;cdn&#x2F;expire-1-M&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>    &lt;script&gt;<br>        function uservalidator() &#123;<br>            $.ajax(&#123;<br>                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;test&quot;,<br>                data:&#123;&quot;name&quot;:$(&quot;#user&quot;).val(),&quot;passwords&quot;:$(&quot;#passwords&quot;).val()&#125;,<br>                success:function (data) &#123;<br>                    $(&quot;#usermsg&quot;).html(data)<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &lt;&#x2F;script&gt;<br>    &lt;script&gt;<br>        function passwordsvalidator() &#123;<br>            $.ajax(&#123;<br>                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;test&quot;,<br>                data:&#123;&quot;name&quot;:$(&quot;#user&quot;).val(),&quot;passwords&quot;:$(&quot;#passwords&quot;).val()&#125;,<br>                success:function (data) &#123;<br>                    $(&quot;#pswmsg&quot;).html(data)<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &lt;&#x2F;script&gt;<br>    &lt;form&gt;<br>        用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;user&quot; id&#x3D;&quot;user&quot; onblur&#x3D;&quot;uservalidator()&quot;&gt;&lt;br&gt;<br>        &lt;p id&#x3D;&quot;usermsg&quot;&gt;&lt;&#x2F;p&gt;<br>        密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;passwords&quot; id&#x3D;&quot;passwords&quot; onblur&#x3D;&quot;passwordsvalidator()&quot;&gt;<br>        &lt;p id&#x3D;&quot;pswmsg&quot;&gt;&lt;&#x2F;p&gt;<br>    &lt;&#x2F;form&gt;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>


<h2 id="ajax传递数组"><a href="#ajax传递数组" class="headerlink" title="ajax传递数组"></a><strong>ajax传递数组</strong></h2><p>前端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">var args &#x3D;<br>    [<br>    &#123;pname:&quot;一&quot;,priority:$(&quot;#priority1&quot;).val(),<br>        runtime:$(&quot;#runtime1&quot;).val()&#125;,<br>    &#123;pname:&quot;二&quot;,priority:$(&quot;#priority2&quot;).val(),<br>        runtime:$(&quot;#runtime2&quot;).val()&#125;,<br>    &#123;pname:&quot;三&quot;,priority:$(&quot;#priority3&quot;).val(),<br>        runtime:$(&quot;#runtime3&quot;).val()&#125;,<br>    &#123;pname:&quot;四&quot;,priority:$(&quot;#priority4&quot;).val(),<br>        runtime:$(&quot;#runtime4&quot;).val()&#125;,<br>    &#123;pname:&quot;五&quot;,priority:$(&quot;#priority5&quot;).val(),<br>        runtime:$(&quot;#runtime5&quot;).val()&#125;<br>        ]<br><br>$.ajax(&#123;<br><br>    type:&quot;post&quot;,<br>    url:&quot;&#x2F;show&quot;,<br>    dataType:&quot;json&quot;,<br>    contentType: &quot;application&#x2F;json&quot;,<br>    data: JSON.stringify(args),<br>    traditional: true,<br>    error:function (data) &#123;<br>        $(&quot;#queue&quot;).text(data);<br>    &#125;<br><br>&#125;)<br><br>&#96;&#96;&#96;			<br><br>Controller：<br><br></code></pre></td></tr></table></figure>
<p>@RequestMapping(value = “/show”,produces=”text/html;charset=UTF-8”)<br>@ResponseBody<br>public String show(@RequestBody process[] args){<br>    queue = new process().CreateQueue(new LinkedList&lt;&gt;(Arrays.asList(args)));<br>    System.out.println(queue.getNext().toString());<br>    return queue.getNext().toString();<br>}</p>
<pre><code>
</code></pre>
]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC 异常解决</title>
    <url>/2020/10/12/mvcwrong/</url>
    <content><![CDATA[<p>注解驱动异常：</p>
<p>在新建的MVC项目中，要想使用注解驱动，出现异常信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">12-Oct-2020 17:43:10.828 警告 [RMI TCP Connection(21)-127.0.0.1] org.springframework.web.context.support.XmlWebApplicationContext.refresh Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;org.springframework.cache.interceptor.CacheInterceptor#0&#39;: Cannot resolve reference to bean &#39;cacheManager&#39; while setting bean property &#39;cacheManager&#39;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &#39;cacheManager&#39; available<br>12-Oct-2020 17:43:10.830 严重 [RMI TCP Connection(21)-127.0.0.1] org.springframework.web.servlet.DispatcherServlet.initServletBean Context initialization failed<br>	org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;org.springframework.cache.interceptor.CacheInterceptor#0&#39;: Cannot resolve reference to bean &#39;cacheManager&#39; while setting bean property &#39;cacheManager&#39;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &#39;cacheManager&#39; available<br>		at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:342)<br>		at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:113)<br>		at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1699)<br>		at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1444)<br>		at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594)<br>		at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)<br>		at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)<br>		at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)<br>		at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)<br>		at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)<br>		at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:879)<br>		at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878)<br>		at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550)<br>		at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:702)<br>		at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:668)<br>		at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:716)<br>		at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:591)<br>		at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:530)<br>		at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:170)<br>		at javax.servlet.GenericServlet.init(GenericServlet.java:158)<br>		at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1134)<br>		at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1089)<br>		at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:983)<br>		at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4864)<br>		at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5173)<br>		at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)<br>		at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:717)<br>		at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:690)<br>		at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:706)<br>		at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1727)<br>		at java.base&#x2F;jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>		at java.base&#x2F;jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>		at java.base&#x2F;jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>		at java.base&#x2F;java.lang.reflect.Method.invoke(Method.java:564)<br>		at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:288)<br>		at java.management&#x2F;com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:809)<br>		at java.management&#x2F;com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)<br>		at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:456)<br>		at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:405)<br>		at java.base&#x2F;jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>		at java.base&#x2F;jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>		at java.base&#x2F;jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>		at java.base&#x2F;java.lang.reflect.Method.invoke(Method.java:564)<br>		at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:288)<br>		at java.management&#x2F;com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:809)<br>		at java.management&#x2F;com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)<br>		at java.management&#x2F;com.sun.jmx.remote.security.MBeanServerAccessController.invoke(MBeanServerAccessController.java:468)<br>		at java.management.rmi&#x2F;javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1466)<br>		at java.management.rmi&#x2F;javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1307)<br>		at java.base&#x2F;java.security.AccessController.doPrivileged(AccessController.java:691)<br>		at java.management.rmi&#x2F;javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1406)<br>		at java.management.rmi&#x2F;javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:827)<br>		at java.base&#x2F;jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>		at java.base&#x2F;jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>		at java.base&#x2F;jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>		at java.base&#x2F;java.lang.reflect.Method.invoke(Method.java:564)<br>		at java.rmi&#x2F;sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:359)<br>		at java.rmi&#x2F;sun.rmi.transport.Transport$1.run(Transport.java:200)<br>		at java.rmi&#x2F;sun.rmi.transport.Transport$1.run(Transport.java:197)<br>		at java.base&#x2F;java.security.AccessController.doPrivileged(AccessController.java:691)<br>		at java.rmi&#x2F;sun.rmi.transport.Transport.serviceCall(Transport.java:196)<br>		at java.rmi&#x2F;sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:587)<br>		at java.rmi&#x2F;sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:828)<br>		at java.rmi&#x2F;sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:705)<br>		at java.base&#x2F;java.security.AccessController.doPrivileged(AccessController.java:391)<br>		at java.rmi&#x2F;sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:704)<br>		at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)<br>		at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)<br>		at java.base&#x2F;java.lang.Thread.run(Thread.java:832)<br>	Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &#39;cacheManager&#39; available<br>		at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:805)<br>		at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1278)<br>		at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:297)<br>		at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:276)<br>		at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)<br>		at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:330)<br>		... 68 more<br></code></pre></td></tr></table></figure>
<p>解决方案：</p>
<p>在配置Dispatcher的xml文件中，   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mvc:annotation-driven&gt;&lt;&#x2F;mvc:annotation-driven&gt;<br></code></pre></td></tr></table></figure>
<p>使用错误</p>
<p>因为annotation-driven有几个同名的</p>
<p><img src="/2020/10/12/mvcwrong/driven.jpg" alt="driven"></p>
<p>如果要选择注解驱动，要选择第三个</p>
<ol>
<li><p>一个或多个listeners启动失败：</p>
</li>
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">04-Nov-2020 10:55:18.460 严重 [RMI TCP Connection(2)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal 一个或多个筛选器启动失败。完整的详细信息将在相应的容器日志文件中找到<br>04-Nov-2020 10:55:18.461 严重 [RMI TCP Connection(2)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal 由于之前的错误，Context[]启动失败<br></code></pre></td></tr></table></figure>

<p><img src="/2020/10/12/mvcwrong/listener.jpg" alt="listener"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file<br></code></pre></td></tr></table></figure>

<ol>
<li>修改maven</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;properties&gt;<br>    &lt;maven.compiler.source&gt;1.7&lt;&#x2F;maven.compiler.source&gt;<br>    &lt;maven.compiler.target&gt;1.7&lt;&#x2F;maven.compiler.target&gt;<br>&lt;&#x2F;properties&gt;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p><img src="/2020/10/12/mvcwrong/dispatcher.jpg" alt="dispatcher"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>异常解决</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb之Servlet</title>
    <url>/2020/10/04/Servlet/</url>
    <content><![CDATA[<p>最近在使用SpringMVC的时候有是要用到Servlet中的方法，也借此机会复习一波Servlet</p>
<h1 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a><strong>什么是Servlet</strong></h1><p>Servlet的全称是JavaServlet，是运行在Web服务器或应用服务器上的程序，由Servlet容器统一管理，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。</p>
<p>Servlet的本质是一个独立的Java类，编写一个Servlet，其实就是按照相应的规范编写一个Java类</p>
<h1 id="servlet容器"><a href="#servlet容器" class="headerlink" title="servlet容器"></a><strong>servlet容器</strong></h1><p>上面说到servlet是运行在web服务器或应用服务器上的程序，由servlet容器统一管理，servlet容器是web服务器或应用服务器的一部分，Servlet不能独立运行，它必须被部署到Servlet容器中，由容器来实例化和调用Servlet的方法，servlet是由servlet容器统一管理的，它负责管理servlet的生命周期。</p>
<h1 id="servlet的工作流程"><a href="#servlet的工作流程" class="headerlink" title="servlet的工作流程"></a><strong>servlet的工作流程</strong></h1><p><img src="/2020/10/04/Servlet/servlet.jpg" alt="servlet"></p>
<h1 id="servlet的使用方法和原理"><a href="#servlet的使用方法和原理" class="headerlink" title="servlet的使用方法和原理"></a><strong>servlet的使用方法和原理</strong></h1><h2 id="servlet的使用"><a href="#servlet的使用" class="headerlink" title="servlet的使用"></a><strong>servlet的使用</strong></h2><p>Servlet技术的核心是Servlet接口，它是所有Servlet类必须直接或者间接实现的一个接口。要想使用servlet，就必须实现servlet接口或者继承实现了servlet接口的类。</p>
<h2 id="servlet的工作原理"><a href="#servlet的工作原理" class="headerlink" title="servlet的工作原理"></a><strong>servlet的工作原理</strong></h2><p>当客户端有请求时，Servlet容器实例化相对应的servlet，并调用它的service()方法，传入ServletRequest对象和ServletResponse对象，这两个对象是由servlet容器封装好的，ServletRequest对象封装了http的请求，ServletResponse则封装了对http请求的响应。</p>
<p>对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。</p>
<h1 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a><strong>servlet的生命周期</strong></h1><p>servlet的生命周期分为init()、service()和destroy()三个过程</p>
<ul>
<li>init()</li>
</ul>
<p>当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会再被Servlet容器调用，可以利用init()方法对servlet进行初始化工作</p>
<ul>
<li>service()</li>
</ul>
<p>每当请求Servlet时，Servlet容器就会调用这个方法</p>
<ul>
<li>destroy()</li>
</ul>
<p>当要销毁Servlet时，Servlet容器就会调用这个方法，在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。</p>
<h1 id="Servlet、ServletRequest、ServletResponse接口"><a href="#Servlet、ServletRequest、ServletResponse接口" class="headerlink" title="Servlet、ServletRequest、ServletResponse接口"></a><strong>Servlet、ServletRequest、ServletResponse接口</strong></h1><h2 id="Servlet接口："><a href="#Servlet接口：" class="headerlink" title="Servlet接口："></a><strong>Servlet接口：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface Servlet &#123;<br>    void init(ServletConfig var1) throws ServletException;<br> <br> &#x2F;&#x2F; 获取配置信息<br>    ServletConfig getServletConfig();<br> <br>    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;<br> <br> &#x2F;&#x2F; 获取servlet信息 传给init（）方法的ServletConfig对象<br>    String getServletInfo();<br> <br>    void destroy();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ServletRequest接口"><a href="#ServletRequest接口" class="headerlink" title="ServletRequest接口"></a><strong>ServletRequest接口</strong></h2><p>ServletRequest接口中最常用的一个方法是getParameter方法，用于返回请求参数的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">String getParameter(String var1);&#x2F;&#x2F;返回请求参数的值<br></code></pre></td></tr></table></figure>
<h2 id="ServletResponse接口"><a href="#ServletResponse接口" class="headerlink" title="ServletResponse接口"></a><strong>ServletResponse接口</strong></h2><p> javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service()方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface ServletResponse &#123;<br><br>    String getCharacterEncoding();<br> <br>    String getContentType();<br> <br>    PrintWriter getWriter() throws IOException;<br> <br>    void setCharacterEncoding(String var1);<br> <br>    void setContentLength(int var1);<br> <br> 	&#x2F;&#x2F; ....省略一些方法<br>    void setContentType(String var1);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中最常用的方法是： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">PrintWriter getWriter() throws IOException;<br><br>void setContentType(String var1);<br></code></pre></td></tr></table></figure>
<p>在响应客户端请求时，都先应调用setContentType方法，设置响应的内容类型，并将“text/html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。</p>
<p>getWriter方法返回一个可以向客户端发送文本的java对象，可以在客户端页面中输出信息</p>
<h1 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a><strong>ServletContext对象</strong></h1><p>ServletContext对象表示Servlet应用程序。每个Web应用程序都只有一个ServletContext对象。有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中。保存在ServletContext中的对象被称作属性。</p>
<p>servletcontext对象中的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Object getAttribute(String var1);<br> <br>Enumeration&lt;String&gt; getAttributeNames();<br> <br>void setAttribute(String var1, Object var2);<br> <br>void removeAttribute(String var1);<br></code></pre></td></tr></table></figure>
<h1 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a><strong>ServletConfig接口</strong></h1><p>当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init()方式传入一个ServletConfig对象。一些方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">String getInitParameter(String name) &#x2F;&#x2F;根据初始化参数名，返回对应的初始化参数值<br><br>Enumeration getInitParameterNames()	&#x2F;&#x2F;返回一个Enumeration对象，其中包含所有的初始化参数名<br><br>ServletContext getServletContext()	&#x2F;&#x2F;返回一个代表当前Web应用的，ServletContext对象<br><br>String getServletName()	&#x2F;&#x2F;返回Servlet的名字，即web.xml中元素的值<br></code></pre></td></tr></table></figure>
<h1 id="HttpServlet、HttpServletRequest、HttpServlelResponse"><a href="#HttpServlet、HttpServletRequest、HttpServlelResponse" class="headerlink" title="HttpServlet、HttpServletRequest、HttpServlelResponse"></a><strong>HttpServlet、HttpServletRequest、HttpServlelResponse</strong></h1><p>在实际应用中，最常用的Servlet类HttpServlet抽象类<br>常用的接口是ServletRequest的子接口HttpServletRequest 和 ServletResponse的子接口HttpServletResponse </p>
<p>继承关系如下图：</p>
<p><img src="/2020/10/04/Servlet/relationship.jpg" alt="relationship"></p>
<h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a><strong>HttpServlet</strong></h2><p>常用Servlet对象是javax.servlet.http包下的HttpServlet抽象类</p>
<p>HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象</p>
<p>继承HttpServlet的Servlet类中要实现doXX方法，分别用于客户端的不同请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;<br>&#125;<br><br>...<br><br>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>HttpServlet类中重写了service()方法，根据客户端请求类型的不同而调用相应的doXX方法</p>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a><strong>HttpServletRequest</strong></h2><p>HttpServletRequest接口中添加了几个重要方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Cookie[] getCookies();&#x2F;&#x2F;返回一个cookie对象数组<br><br>String getHeader(String var1);&#x2F;&#x2F;返回指定HTTP标题的值<br><br>HttpSession getSession();&#x2F;&#x2F;返回与这个请求相关的会话对象<br></code></pre></td></tr></table></figure>
<h2 id="HttpServlelResponse"><a href="#HttpServlelResponse" class="headerlink" title="HttpServlelResponse"></a><strong>HttpServlelResponse</strong></h2><p>HttpServlelResponse中添加的重要方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void addCookie(Cookie var1);&#x2F;&#x2F;给这个响应添加一个cookie<br><br>void addHeader(String var1, String var2);&#x2F;&#x2F;给这个请求添加一个响应头<br><br>void sendRedirect(String var1) throws IOException;&#x2F;&#x2F;发送一条响应码，讲浏览器跳转到指定的位置<br><br>void setStatus(int var1);&#x2F;&#x2F;设置响应行的状态码<br></code></pre></td></tr></table></figure>

<h1 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a><strong>cookie和session</strong></h1><p>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><strong>cookie</strong></h2><p>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。要跟踪该会话，必须引入一种机制。而cookie就是这样一种机制。</p>
<p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response对象的addCookie方法向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<p>Cookie类在javax.servlet.http.Cookie包下</p>
<p>Cookie对象中常用的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void setDomain(String pattern)	&#x2F;&#x2F;该方法设置 cookie 适用的域，例如 xxx.com<br><br>public String getDomain()	&#x2F;&#x2F;该方法获取 cookie 适用的域，例如 xxx.com。<br><br>&#x2F;&#x2F;该方法设置cookie有效时间（以秒为单位）。如果不这样设置，cookie只会在当前session会话中持续有效。<br>public void setMaxAge(int expiry)<br><br>&#x2F;&#x2F;该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。<br>public int getMaxAge()	<br><br>public String getName()	&#x2F;&#x2F;该方法返回 cookie 的名称。名称在创建后不能改变。<br><br>public void setValue(String newValue)	&#x2F;&#x2F;该方法设置与 cookie 关联的值。<br><br>public String getValue() &#x2F;&#x2F;该方法获取与 cookie 关联的值。<br><br>&#x2F;&#x2F;该方法设置 cookie 适用的路径。如果不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。<br>public void setPath(String uri)<br><br>public String getPath()	&#x2F;&#x2F;该方法获取 cookie 适用的路径。<br><br>&#x2F;&#x2F;该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。<br>public void setSecure(boolean flag)<br><br>public void setComment(String purpose)	&#x2F;&#x2F;设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。<br><br>public String getComment()	&#x2F;&#x2F;获取 cookie 的注释，如果 cookie 没有注释则返回 null。<br></code></pre></td></tr></table></figure>


<h2 id="session"><a href="#session" class="headerlink" title="session"></a><strong>session</strong></h2><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>Session对应的类为javax.servlet.http.HttpSession类</p>
<p>Servlet里通过request.getSession()方法获取该客户的Session</p>
<p>HttpSession对象中常用的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。<br>public Object getAttribute(String name)<br><br>&#x2F;&#x2F;该方法使用指定的名称绑定一个对象到该 session 会话。<br>public void setAttribute(String name, Object value)<br><br>&#x2F;&#x2F;该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。<br>public Enumeration getAttributeNames()<br><br>&#x2F;&#x2F;设置session的超时时间，以秒为单位。<br>public void setMaxInactiveInterval(int interval)<br><br>&#x2F;&#x2F;获取session的超时时间以秒为单位。<br>public int getMaxInactiveInterval()<br><br>&#x2F;&#x2F;该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。<br>public String getId()<br><br>&#x2F;&#x2F;该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。<br>public long getLastAccessedTime()<br><br>&#x2F;&#x2F;该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。<br>	public void invalidate()<br><br>&#x2F;&#x2F;如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。<br>	public boolean isNew()<br><br>&#x2F;&#x2F;该方法将从该 session 会话移除指定名称的对象。<br>	public void removeAttribute(String name)<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC入门</title>
    <url>/2020/10/04/SpringMVC/</url>
    <content><![CDATA[<h1 id="什么是MVC框架"><a href="#什么是MVC框架" class="headerlink" title="什么是MVC框架"></a><strong>什么是MVC框架</strong></h1><p>MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是在WEB模型中一种很流行的框架，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，是为了简化开发，增强开发人员间的配合，减少出错，MVC是一种分层工作的方法。</p>
<p>model 模型：一个或多个bean，负责存储数据和处理业务逻辑<br>view 视图：一个或多个jsp文件，负责显示信息<br>controller 控制器：一个或多个servlet，负责处理与用户间的交互</p>
<hr>
<h1 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a><strong>什么是SpringMVC</strong></h1><p>SpringMVC是Spring的一个子框架，拥有Spring的特性</p>
<h2 id="SpringMVC的组成"><a href="#SpringMVC的组成" class="headerlink" title="SpringMVC的组成"></a><strong>SpringMVC的组成</strong></h2><p>Spring MVC主要由 DispatcherServlet(前端控制器)、HandlerMapping(处理器映射)、Controller(处理器)、ViewResolver(视图解析器)、View(视图) 组成</p>
<ul>
<li><h3 id="DispatcherServlet接口："><a href="#DispatcherServlet接口：" class="headerlink" title="DispatcherServlet接口："></a>DispatcherServlet接口：</h3></li>
</ul>
<p>(Servlet)</p>
<p>DispatcherServlet是SpringMVC的核心，DispatcherServlet接口是前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping类定位到具体的Controller</p>
<ul>
<li><h3 id="HandlerMapping接口："><a href="#HandlerMapping接口：" class="headerlink" title="HandlerMapping接口："></a>HandlerMapping接口：</h3></li>
</ul>
<p>(Servlet-Mapping)</p>
<p>DispatcherServlet通过HandlerMapping定位具体的Controller，将客户端请求交给Controller</p>
<ul>
<li><h3 id="Controller接口："><a href="#Controller接口：" class="headerlink" title="Controller接口："></a>Controller接口：</h3></li>
</ul>
<p>(Servlet)</p>
<p>Controller将处理客户端发来的请求，一旦Controller处理完用户请求，将返回ModelAndView对象给 DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。</p>
<ul>
<li><h3 id="ViewResolver接口："><a href="#ViewResolver接口：" class="headerlink" title="ViewResolver接口："></a>ViewResolver接口：</h3></li>
</ul>
<p>Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</p>
<h2 id="SpringMVC的运行过程"><a href="#SpringMVC的运行过程" class="headerlink" title="SpringMVC的运行过程"></a>SpringMVC的运行过程</h2><p><img src="/2020/10/04/SpringMVC/SpringMVC.png"></p>
<p>SpringMVC的运行过程为：</p>
<p>客户端提交请求给DispatcherServlet，DispatcherServlet寻找一个或多个的处理器映射HandlerMapping，找到与请求相应的Controller，然后将请求交给Controller，Controller处理完毕请求之后返回ModelAndView对象给Dispatcher，Dispatcher通过ViewResolver找到ModelAndView中指定的视图后，将视图返回给客户端</p>
<hr>
<h1 id="SpringMVC入门之HelloWorld"><a href="#SpringMVC入门之HelloWorld" class="headerlink" title="SpringMVC入门之HelloWorld"></a><strong>SpringMVC入门之HelloWorld</strong></h1><p>在springmvc.controller包下创建HelloWorldController类，继承Controller接口：</p>
<p><strong>注：要选择org.springframework.web.servlet接口下的Controller子接口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package springmvc.controller;<br><br>import org.springframework.web.servlet.ModelAndView;<br>import org.springframework.web.servlet.mvc.Controller;<br><br>public class HelloWorldController implements Controller &#123;<br>    @Override<br>    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;<br>        ModelAndView mav &#x3D; new ModelAndView();<br>        mav.addObject(&quot;message&quot;,&quot;helloworld!&quot;);<br>        mav.setViewName(&quot;&#x2F;WEB-INF&#x2F;helloWorld.jsp&quot;);<br>        return mav;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中的helloWorld.jsp文件后面会创建</p>
<p>配置dispatcher-servlet.xml文件，为前端处理器添加处理器映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;<br>&lt;!DOCTYPE beans PUBLIC &quot;-&#x2F;&#x2F;SPRING&#x2F;&#x2F;DTD BEAN&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;dtd&#x2F;spring-beans.dtd&quot;&gt;<br>&lt;beans&gt;<br>    &lt;bean id&#x3D;&quot;simpleUrlHandlerMapping&quot;<br>          class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;<br>        &lt;property name&#x3D;&quot;mappings&quot;&gt;<br>            &lt;props&gt;<br>&lt;!--                这里HelloWorldController使用的是后边bean的id--&gt;<br>                &lt;prop key&#x3D;&quot;&#x2F;index&quot;&gt;HelloWorldController&lt;&#x2F;prop&gt;<br>            &lt;&#x2F;props&gt;<br>        &lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br>    &lt;bean id&#x3D;&quot;HelloWorldController&quot; class&#x3D;&quot;springmvc.controller.HelloWorldController&quot;&gt;&lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>

<p>绑定前端控制器，也可以使用如下方式：</p>
<p>在resources目录下编写xxx.xml文件，然后使用如下方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;servlet&gt;<br>    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;<br>    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;<br>    &lt;init-param&gt;<br>        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;<br>        &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;<br>    &lt;&#x2F;init-param&gt;<br>&lt;&#x2F;servlet&gt;<br></code></pre></td></tr></table></figure>

<p>配置web.xml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;web-app version&#x3D;&quot;2.4&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee&quot;<br>         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee<br>http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee&#x2F;web-app_2_4.xsd&quot;&gt;<br>    &lt;servlet&gt;<br><br>&lt;!--        会自动使用这个name到WEB-INF中找***-servlet.xml 的文件，所以xml文件名为dispatcher-servlet.xml，而这里的servlet-name为dispatcher--&gt;<br><br>        &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;<br>        &lt;servlet-class&gt;<br>            org.springframework.web.servlet.DispatcherServlet<br>        &lt;&#x2F;servlet-class&gt;<br>        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;<br>    &lt;&#x2F;servlet&gt;<br>    &lt;servlet-mapping&gt;<br>        &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;<br>        &lt;!--这里将url设置为&#x2F;，处理所有的url        --&gt;<br>        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;	<br>    &lt;&#x2F;servlet-mapping&gt;<br><br>    &#x2F;&#x2F;解决乱码<br>    &lt;filter&gt;<br>	    &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;<br>	    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;<br>	    &lt;init-param&gt;<br>	        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;<br>	        &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;<br>	    &lt;&#x2F;init-param&gt;<br>	&lt;&#x2F;filter&gt;<br>	&lt;filter-mapping&gt;<br>	    &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;<br>	    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;<br>	&lt;&#x2F;filter-mapping&gt;<br>&lt;&#x2F;web-app&gt;<br></code></pre></td></tr></table></figure>

<p>修改index.jsp文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;$Title$&lt;&#x2F;title&gt;<br>  &lt;&#x2F;head&gt;<br>  &lt;body&gt;<br>  &lt;h1&gt;welcome to login&lt;&#x2F;h1&gt;<br>  &lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>
<p>在WEB-INF下添加helloWorld.jsp文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;&#x2F;title&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>&lt;%--绑定处理器中添加的值--%&gt;<br><br>    &lt;h1&gt;$&#123;message&#125;&lt;&#x2F;h1&gt;	<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<p>项目的文件目录如下：</p>
<p><img src="/2020/10/04/SpringMVC/content.jpg" alt="content"></p>
<p>postman访问<a href="http://localhost:8080/">http://localhost:8080</a><br><img src="/2020/10/04/SpringMVC/8080.jpg" alt="8080"></p>
<p>访问<a href="http://localhost:8080/index">http://localhost:8080/index</a><br><img src="/2020/10/04/SpringMVC/index.jpg" alt="index"></p>
<p>SpringMVC中的数据绑定，只要在控制器中对数据模型进行相应的处理，如上面例子的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mav.addObject(&quot;message&quot;,&quot;helloworld!&quot;); <br></code></pre></td></tr></table></figure>
<p>或者Model类型对象的 addAttribute()方法处理数据，然后在相应的view层使用${}显示数据即可。</p>
<p>如果在Dispatcher中配置视图解析器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;internalResourceViewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;<br>    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
<p>则Controller中的返回对象ModelAndView中指定的视图不用添加前缀和后缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mav.setViewName(&quot;result&quot;);<br></code></pre></td></tr></table></figure>
<p>将返回同样的结果</p>
<hr>
<h1 id="Controller注解和-RequestMapping注解"><a href="#Controller注解和-RequestMapping注解" class="headerlink" title="@Controller注解和@RequestMapping注解"></a><strong>@Controller注解和@RequestMapping注解</strong></h1><p><strong>注：要使用注解，要在控制器的配置文件中加上如下语句</strong>    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;context: component-scan base-package&#x3D;&quot;package-name&quot;&gt;&lt;&#x2F;context: component-scan&gt;<br></code></pre></td></tr></table></figure>

<h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>使用@Controller注解将某类声明为控制器，使用@Controller就不用在Dispatcher配置文件中配置控制器了</p>
<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>使用@RequestMapping可以为每个请求编写对应的处理方法</p>
<h3 id="方法级别注解"><a href="#方法级别注解" class="headerlink" title="方法级别注解"></a>方法级别注解</h3><p>@RequestMapping作用于方法时，若客户端有相应的请求，则dispatcher将通过该请求找到对应的方法，从而找到方法所在的控制器，由控制器处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class LoginController &#123;<br>    @RequestMapping(&quot;&#x2F;login&quot;)<br>    public String login()&#123;<br>        return &quot;login&quot;;<br>    &#125;<br>    @RequestMapping(value &#x3D; &quot;&#x2F;result&quot;)<br>    public String result()&#123;<br>        return &quot;result&quot;;<br>    &#125;<br>&#125;<br><br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;$Title$&lt;&#x2F;title&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;welcome to login&lt;&#x2F;h1&gt;<br>&lt;form action&#x3D;&quot;&#x2F;result&quot;&gt;<br>    学号：&lt;input name&#x3D;&quot;id&quot;&gt;&lt;br&gt;<br>    姓名：&lt;input name&#x3D;&quot;name&quot;&gt;&lt;br&gt;<br>    年龄：&lt;input name&#x3D;&quot;age&quot;&gt;&lt;br&gt;<br>    &lt;button type&#x3D;&quot;sumbit&quot;&gt;提交&lt;&#x2F;button&gt;<br>&lt;&#x2F;form&gt;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>
<p><strong>注：此配置是基于视图处理器的配置</strong></p>
<p>此时，浏览器打开<a href="http://localhost:8080/login">http://localhost:8080/login</a> 将会成功显示登陆界面</p>
<h3 id="类级别注解"><a href="#类级别注解" class="headerlink" title="类级别注解"></a>类级别注解</h3><p>在类级别注解的情况下，控制器类中的所有方法都将映射为类级别的请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>@RequestMapping(&quot;&#x2F;init&quot;)<br>public class LoginController &#123;<br>    @RequestMapping(&quot;&#x2F;login&quot;)<br>    public String login()&#123;<br>        return &quot;login&quot;;<br>    &#125;<br>    @RequestMapping(value &#x3D; &quot;&#x2F;result&quot;)<br>    public String result()&#123;<br>        return &quot;result&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时，浏览器打开<a href="http://localhost:8080/init/login">http://localhost:8080/init/login</a> 将会成功显示登陆界面</p>
<h2 id="接收请求参数"><a href="#接收请求参数" class="headerlink" title="接收请求参数"></a><strong>接收请求参数</strong></h2><h3 id="直接把表单数据写在参数列表中"><a href="#直接把表单数据写在参数列表中" class="headerlink" title="直接把表单数据写在参数列表中"></a><strong>直接把表单数据写在参数列表中</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class LoginController &#123;<br>    @RequestMapping(&quot;&#x2F;login&quot;)<br>    public String login()&#123;<br>        return &quot;login&quot;;<br>    &#125;<br>    @RequestMapping(value &#x3D; &quot;&#x2F;result&quot;)<br>    public String result(String name,String id,int age,Model model)&#123;<br>        model.addAttribute(&quot;id&quot;,id);<br>        model.addAttribute(&quot;name&quot;,name);<br>        model.addAttribute(&quot;age&quot;,age);<br>        return &quot;result&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="HttpServletRequest获得参数"><a href="#HttpServletRequest获得参数" class="headerlink" title="HttpServletRequest获得参数"></a><strong>HttpServletRequest获得参数</strong></h3><p>如Model接口和javax.servlet.http.HttpServletRequest组合可以像ModelAndView那样返回客户端的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(value &#x3D; &quot;&#x2F;result&quot;)<br>public String result(Model model,javax.servlet.http.HttpServletRequest httpServletRequest)&#123;<br>    model.addAttribute(&quot;id&quot;,httpServletRequest.getParameter(&quot;id&quot;));<br>    model.addAttribute(&quot;name&quot;,httpServletRequest.getParameter(&quot;name&quot;));<br>    model.addAttribute(&quot;age&quot;,httpServletRequest.getParameter(&quot;age&quot;));<br>    return &quot;result&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="通过实体Bean接收请求参数"><a href="#通过实体Bean接收请求参数" class="headerlink" title="通过实体Bean接收请求参数"></a><strong>通过实体Bean接收请求参数</strong></h3><p>student类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class student &#123;<br>    private String id;<br>    private String name;<br>    private int age;<br>    &#x2F;&#x2F;省略getter和setter<br>    public String toString()&#123;<br>    	return &quot;[id&#x3D;&quot;+id+&quot;,name&#x3D;&quot;+name+&quot;,age&#x3D;&quot;+age+&quot;]&quot;;<br>	&#125;<br>&#125;<br><br>@RequestMapping(value &#x3D; &quot;&#x2F;result&quot;)<br>public String result(student stu,Model model)&#123;<br>    model.addAttribute(&quot;id&quot;,stu.getId());<br>    model.addAttribute(&quot;name&quot;,stu.getName());<br>    model.addAttribute(&quot;age&quot;,stu.getAge());<br>    return &quot;result&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><strong>@RequestParam</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(value &#x3D; &quot;&#x2F;result&quot;)<br>public String result(student stu, Model model, @RequestParam String name, @RequestParam String id)&#123;<br>        System.out.println(id + &quot; &quot; + name);<br>        model.addAttribute(&quot;id&quot;, stu.getId());<br>        model.addAttribute(&quot;name&quot;, stu.getName());<br>        model.addAttribute(&quot;age&quot;, stu.getAge());<br>    return &quot;result&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><strong>@ModelAttribute</strong></h3><p>当 @ModelAttribute 注解放在处理方法的形参上时，用于将多个请求参数封装到一个实体对象，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用。而“通过实体Bean接收请求参数”中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用 model.addAttribute 语句才能暴露为模型数据)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(value &#x3D; &quot;&#x2F;result&quot;)<br>public String result(@ModelAttribute(&quot;stu&quot;) student stu)&#123;<br>    System.out.println(stu.getId()+&quot; &quot;+stu.getName()+&quot; &quot;+stu.getAge());<br>    return &quot;result&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在result处理方法中，ModelAttribute(“stu”) student stu先将请求参数的输入封装到student对象中，然后再创建对象的实例，以键值为stu存储在Model对象中</p>
<p>此时，只要在相应的result.jsp中使用EL表达式¥{property}就可以将数据表示出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;&#x2F;title&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;登录成功&lt;&#x2F;h1&gt;<br>    &lt;p&gt;$&#123;id&#125;&lt;&#x2F;p&gt;<br>    &lt;p&gt;$&#123;name&#125;&lt;&#x2F;p&gt;<br>    &lt;p&gt;$&#123;age&#125;&lt;&#x2F;p&gt;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<p>ModelAttribute作用于无返回值的方法，被@ModelAttribute注释的方法会在此controller每个方法执行前被执行</p>
<p>在控制器中添加show方法，想要把请求参数显示在result.jsp中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@ModelAttribute<br>public void show(Model model,@RequestParam String name)&#123;<br>    model.addAttribute(&quot;name&quot;,name);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行发现，name请求参数成功显示在页面中</p>
<h1 id="Service和-AutoWired"><a href="#Service和-AutoWired" class="headerlink" title="@Service和@AutoWired"></a>@Service和@AutoWired</h1><p>在springmvc.controller包下创建ServiceInterface接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface ServiceInterface &#123;<br>    public void service(student stu);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>提供实现类ServiceImpl，该类标注为Service类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Service<br>public class ServiceImpl implements ServiceInterface&#123;<br>    public void service(student stu)&#123;<br>        System.out.println(&quot;service&quot;);<br>        System.out.println(stu.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在LoginController控制器中添加属性，标志为自动注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Autowired(required &#x3D; false)<br>ServiceInterface serviceInterface;<br></code></pre></td></tr></table></figure>
<p>修改result处理方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(value &#x3D; &quot;&#x2F;result&quot;)<br>public String result(@ModelAttribute(&quot;stu&quot;) student stu)&#123;<br>    serviceInterface.service(stu);<br>    return &quot;result&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在postman中提交请求，可以发现IDEA输出端成功显示表单信息</p>
<h1 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a><strong>转发和重定向</strong></h1><p>重定向是将用户从当前处理请求定向到另一个视图或处理请求，以前的请求（request）中存放的信息全部失效，并进入一个新的 request 作用域，如return “redirect:aview”;</p>
<p>转发是将用户对当前处理的请求转发给另一个视图或处理请求，以前的 request 中存放的信息不会失效。</p>
<p>转发是服务器行为，重定向是客户端行为。</p>
<p>在 Spring MVC 框架中，控制器类中处理方法的 return 语句默认就是转发实现，只不过实现的是转发到视图。</p>
<h1 id="SpringMVC与JSON的数据交互"><a href="#SpringMVC与JSON的数据交互" class="headerlink" title="SpringMVC与JSON的数据交互"></a>SpringMVC与JSON的数据交互</h1><h2 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a><strong>jackson</strong></h2><p>添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>  &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;<br>  &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt;<br>  &lt;version&gt;2.8.1&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;<br>  &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;<br>  &lt;version&gt;2.8.1&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;<br>  &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt;<br>  &lt;version&gt;2.8.1&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>
<p>在UserController中添加json方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(&quot;&#x2F;json&quot;)<br>@ResponseBody<br>public String json()&#123;<br>    return new student(&quot;123&quot;,&quot;张三&quot;,12).toString();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>或者使用ObjectMapper对象的writeValueAsString方法，将对象解析为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(value &#x3D; &quot;&#x2F;json&quot;)<br>@ResponseBody<br>public String json() throws IOException &#123;<br>    student stu &#x3D;  new student(&quot;123&quot;,&quot;张三&quot;,12);<br>    ObjectMapper objectMapper &#x3D; new ObjectMapper();<br>    String str &#x3D; objectMapper.writeValueAsString(stu);<br>    return str;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>另外，用@ResponseBody作用于方法返回字符串给请求，@RequestBody作用于参数用于接受Json对象字符串后自动转换为对象</p>
<p>postman测试，网页中出现[id=123,name=??,age=12]，出现乱码</p>
<p><strong>JSON乱码解决</strong></p>
<ul>
<li>@RequestMapping添加属性 produces=”application/json;charset=utf-8”</li>
</ul>
<p>此时返回[id=123,name=张三,age=12]</p>
<ul>
<li>在dispatcher-servlet中添加如下配置统一解决问题<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mvc:annotation-driven&gt;<br>    &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;<br>        &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;<br>            &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;<br>        &lt;&#x2F;bean&gt;<br>        &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;<br>            &lt;property name&#x3D;&quot;objectMapper&quot;&gt;<br>                &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;<br>                    &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;<br>                &lt;&#x2F;bean&gt;<br>            &lt;&#x2F;property&gt;<br>        &lt;&#x2F;bean&gt;<br>    &lt;&#x2F;mvc:message-converters&gt;<br>&lt;&#x2F;mvc:annotation-driven&gt;<br></code></pre></td></tr></table></figure></li>
<li>将控制器注解位@RestController</li>
</ul>
<p>此时控制器类的所有处理方法都返回一个JSON字符串，不再进行视图解析</p>
<h2 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a><strong>fastjson</strong></h2><p>添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.2.74&lt;&#x2F;version&gt;<br> &lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>fastjson中JSON类中有很多静态方法，只要返回字符串就好，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">String str &#x3D; JSON.toJSONString(stu);<br></code></pre></td></tr></table></figure>
<p>当然也有json字符串转换为java对象的方法</p>
<h2 id="ajax-json与MVC交互实例"><a href="#ajax-json与MVC交互实例" class="headerlink" title="ajax json与MVC交互实例"></a><strong>ajax json与MVC交互实例</strong></h2><p>模仿注册页面中账号和密码的有效性检验</p>
<p>User类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class User &#123;<br><br>    @NotBlank(message &#x3D; &quot;用户名不能为空&quot;)<br>    private String name;<br>    @NotBlank(message &#x3D; &quot;密码不能为空&quot;)<br>    @Length(min &#x3D; 3,max &#x3D; 8,message &#x3D; &quot;密码位数为3-8位&quot;)<br>    private String passwords;<br><br>    public String getPasswords() &#123;<br>        return passwords;<br>    &#125;<br><br>    public String getName() &#123;<br>        return name;<br>    &#125;<br><br>    public void setPasswords(String passwords) &#123;<br><br>        this.passwords &#x3D; passwords;<br>    &#125;<br><br>    public void setName(String name) &#123;<br>        this.name &#x3D; name;<br>    &#125;<br><br>    public String toString()&#123;<br>        return &quot;[name&#x3D;&quot;+name+&quot;,passwords&#x3D;&quot;+passwords+&quot;]&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>UserController：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class UserController &#123;<br><br>    @RequestMapping(&quot;&#x2F;test&quot;)<br>    @ResponseBody<br>    public String test(User user)&#123;<br>&#x2F;&#x2F;        System.out.println(user+&quot; &quot;+passwords);<br>        System.out.println(user);<br>        String msg &#x3D; &quot;&quot;;<br>        if(user.getName()!&#x3D;null)&#123;<br>            if(user.getName().equals(&quot;123&quot;))&#123;<br>                msg &#x3D;  &quot;ok&quot;;<br>            &#125;else&#123;<br>                msg &#x3D;  &quot;failed&quot;;<br>            &#125;<br>        &#125;<br>        if(user.getPasswords()!&#x3D;null)&#123;<br>            if(user.getPasswords().equals(&quot;1233&quot;))&#123;<br>                msg &#x3D;  &quot;ok&quot;;<br>            &#125;else&#123;<br>                msg &#x3D; &quot;failed&quot;;<br>            &#125;<br>        &#125;<br>        return msg;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>jsp文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;&#x2F;title&gt;<br>    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;s3.pstatp.com&#x2F;cdn&#x2F;expire-1-M&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>    &lt;script&gt;<br>        function uservalidator() &#123;<br>            $.ajax(&#123;<br>                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;test&quot;,<br>                data:&#123;&quot;name&quot;:$(&quot;#user&quot;).val(),&quot;passwords&quot;:$(&quot;#passwords&quot;).val()&#125;,<br>                success:function (data) &#123;<br>                    $(&quot;#usermsg&quot;).html(data)<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &lt;&#x2F;script&gt;<br>    &lt;script&gt;<br>        function passwordsvalidator() &#123;<br>            $.ajax(&#123;<br>                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;test&quot;,<br>                data:&#123;&quot;name&quot;:$(&quot;#user&quot;).val(),&quot;passwords&quot;:$(&quot;#passwords&quot;).val()&#125;,<br>                success:function (data) &#123;<br>                    $(&quot;#pswmsg&quot;).html(data)<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &lt;&#x2F;script&gt;<br>    &lt;form&gt;<br>        用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;user&quot; id&#x3D;&quot;user&quot; onblur&#x3D;&quot;uservalidator()&quot;&gt;&lt;br&gt;<br>        &lt;p id&#x3D;&quot;usermsg&quot;&gt;&lt;&#x2F;p&gt;<br>        密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;passwords&quot; id&#x3D;&quot;passwords&quot; onblur&#x3D;&quot;passwordsvalidator()&quot;&gt;<br>        &lt;p id&#x3D;&quot;pswmsg&quot;&gt;&lt;&#x2F;p&gt;<br>    &lt;&#x2F;form&gt;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><strong>拦截器</strong></h1><p>SpringMVC的拦截器和Servlet中的Filter相似，主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上</p>
<p>定义一个拦截器需要实现HandlerInterceptor接口，HandlerInterceptor接口中有三个方法</p>
<ul>
<li><p>preHandle：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。</p>
</li>
<li><p>postHandle：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型<br>和视图做进一步的修改。</p>
</li>
<li><p>afterCompletion：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。</p>
</li>
</ul>
<h2 id="拦截器的配置与使用"><a href="#拦截器的配置与使用" class="headerlink" title="拦截器的配置与使用"></a><strong>拦截器的配置与使用</strong></h2><p>在springmvc.controller包下定义一个MyInterceptor类，实现HandlerInterceptor接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyInterceptor implements HandlerInterceptor &#123;<br>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;<br>        System.out.println(&quot;preHandle&quot;);<br>        return true;<br>    &#125;<br><br>    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;<br>        System.out.println(&quot;postHandle&quot;);<br>    &#125;<br><br>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;<br>        System.out.println(&quot;afterCompletion&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在springmvc-dispatcher.xml中配置拦截器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mvc:interceptors&gt;<br>       &lt;bean class&#x3D;&quot;springmvc.controller.MyInterceptor&quot;&gt;&lt;&#x2F;bean&gt;<br>   &lt;&#x2F;mvc:interceptors&gt;<br></code></pre></td></tr></table></figure>
<p>&lt;mvc： interceptors&gt; 元素用于配置一组拦截器，其子元素 <bean> 定义的是全局拦截器，即拦截所有的请求。</bean></p>
<p>若还要定义其他拦截器，可在里面加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mvc:interceptor&gt;<br>    &lt;!-- 配置拦截器作用的路径 --&gt;<br>    &lt;mvc:mapping path&#x3D;&quot;&quot; &#x2F;&gt;<br>    &lt;!-- 配置不需要拦截作用的路径 --&gt;<br>    &lt;mvc:exclude-mapping path&#x3D;&quot;&quot; &#x2F;&gt;<br>    &lt;!-- 定义&lt;mvc:interceptor&gt;元素中，表示匹配指定路径的请求才进行拦截 --&gt;<br>    &lt;bean class&#x3D;&quot;&quot;&#x2F;&gt;<br>&lt;&#x2F;mvc:interceptor&gt;<br></code></pre></td></tr></table></figure>
<p>&lt;mvc： interceptor&gt; 元素的子元素必须按照 &lt;mvc： mapping…/&gt;、&lt;mvc： exclude-mapping…/&gt;、&lt;bean…/&gt; 的顺序配置。</p>
<p>运行程序，输出端输出：</p>
<p>preHandle<br>springmvc.controller.LoginController<br>postHandle<br>afterCompletion</p>
<h2 id="拦截器的执行流程"><a href="#拦截器的执行流程" class="headerlink" title="拦截器的执行流程"></a><strong>拦截器的执行流程</strong></h2><p>若配置文件中只定义了一个拦截器，则根据 preHandle -&gt; ControllerMethod -&gt; postHandle -&gt; afterCompletion执行</p>
<p>若配置了多个拦截器，则它们的 preHandle 方法将按照配置文件中拦截器的配置顺序执行，而它们的 postHandle 方法和 afterCompletion 方法则按照配置顺序的反序执行</p>
<p>定义一个类MyInterceptor1，和类MyInterceptor一样，MyInterceptor类中的三个方法输出1，MyInterceptor1的三个方法输出2，在springmvc配置文件中定义两个拦截器interceptor、interceptor1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mvc:interceptors&gt;<br>&lt;!--        &lt;bean class&#x3D;&quot;springmvc.controller.MyInterceptor&quot;&gt;&lt;&#x2F;bean&gt;--&gt;<br>    &lt;mvc:interceptor&gt;<br>        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;<br>        &lt;bean class&#x3D;&quot;springmvc.controller.MyInterceptor&quot;&gt;&lt;&#x2F;bean&gt;<br>    &lt;&#x2F;mvc:interceptor&gt;<br>    &lt;mvc:interceptor&gt;<br>        &lt;mvc:mapping path&#x3D;&quot;&#x2F;login&quot;&#x2F;&gt;<br>        &lt;bean class&#x3D;&quot;springmvc.controller.MyInterceptor1&quot;&gt;&lt;&#x2F;bean&gt;<br>    &lt;&#x2F;mvc:interceptor&gt;<br>&lt;&#x2F;mvc:interceptors&gt;<br></code></pre></td></tr></table></figure>

<p>输出端输出：</p>
<p>preHandle 1<br>preHandle 2<br>postHandle 2<br>postHandle 1<br>afterCompletion 2<br>afterCompletion 1</p>
<h2 id="拦截器实例：用户的登录权限验证"><a href="#拦截器实例：用户的登录权限验证" class="headerlink" title="拦截器实例：用户的登录权限验证"></a><strong>拦截器实例：用户的登录权限验证</strong></h2><p>这个WEB应用中，主要有tologin跳转登录页面、login登录页面、result结果页面，如果用户未登录直接进入到result页面，则显示用户未登录，如果用户账号或密码错误，则提示账号或密码错误</p>
<p>在springmvc.interceptor包下添加User类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class User &#123;<br><br>    private String users;<br><br>    private String passwords;<br><br>    &#x2F;&#x2F;省略getter和setter方法<br>&#125;<br></code></pre></td></tr></table></figure>
<p>UserController控制器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>public class UserController &#123;<br>    @RequestMapping(&quot;&#x2F;tologin&quot;)<br>    public String tologin()&#123;<br>        return &quot;login&quot;;<br>    &#125;<br>    @RequestMapping(&quot;&#x2F;login&quot;)<br>    public String login(User user, HttpSession session, Model model)&#123;<br>        System.out.println(user.getUsers()+&quot; &quot;+user.getPasswords());<br>        if(&quot;123&quot;.equals(user.getUsers())&amp;&amp;&quot;123&quot;.equals(user.getPasswords()))&#123;<br>            session.setAttribute(&quot;user&quot;,user);<br>            return &quot;redirect:result&quot;;<br>        &#125;<br>        model.addAttribute(&quot;msg&quot;,&quot;用户名或密码错误，请重新登录！&quot;);<br>        return &quot;login&quot;;<br>    &#125;<br>    @RequestMapping(&quot;&#x2F;result&quot;)<br>    public String result()&#123;<br>        return &quot;result&quot;;<br>    &#125;<br><br>    @RequestMapping(&quot;&#x2F;exit&quot;)<br>	public String exit(HttpServletRequest request,HttpSession session)&#123;<br>    session.invalidate();<br>    return &quot;login&quot;;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建拦截器loginInterceptor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class loginInterceptor implements HandlerInterceptor &#123;<br><br>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;<br>        System.out.println(&quot;123&quot;);<br>        StringBuffer url &#x3D; request.getRequestURL();<br>        if(url.indexOf(&quot;&#x2F;tologin&quot;)&gt;&#x3D;0||url.indexOf(&quot;&#x2F;login&quot;)&gt;&#x3D;0) return true;<br>        HttpSession session &#x3D; request.getSession();<br>        Object obj &#x3D; session.getAttribute(&quot;user&quot;);<br>        if(obj !&#x3D; null) return true;<br>        request.setAttribute(&quot;msg&quot;,&quot;请登录！&quot;);<br>        request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;login.jsp&quot;).forward(request,response);<br>        return false;<br>    &#125;<br><br>    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;<br><br>    &#125;<br><br>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置Dispatcher-servlet.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;<br>        &lt;context:component-scan base-package&#x3D;&quot;springmvc.interceptor&quot;&gt;&lt;&#x2F;context:component-scan&gt;<br>    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;<br>        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br>    &lt;mvc:interceptors&gt;<br>        &lt;mvc:interceptor&gt;<br>            &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;<br>            &lt;bean class&#x3D;&quot;springmvc.interceptor.loginInterceptor&quot;&gt;&lt;&#x2F;bean&gt;<br>        &lt;&#x2F;mvc:interceptor&gt;<br>    &lt;&#x2F;mvc:interceptors&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
<p>配置web.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;web-app version&#x3D;&quot;2.4&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee&quot;<br>         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee<br>http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee&#x2F;web-app_2_4.xsd&quot;&gt;<br>    &lt;servlet&gt;<br>        &lt;servlet-name&gt;interceptor&lt;&#x2F;servlet-name&gt;<br>        &lt;servlet-class&gt;<br>            org.springframework.web.servlet.DispatcherServlet<br>        &lt;&#x2F;servlet-class&gt;<br>        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;<br>    &lt;&#x2F;servlet&gt;<br>    &lt;servlet-mapping&gt;<br>        &lt;servlet-name&gt;interceptor&lt;&#x2F;servlet-name&gt;<br>        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;<br>    &lt;&#x2F;servlet-mapping&gt;<br>&lt;&#x2F;web-app&gt;<br></code></pre></td></tr></table></figure>
<p>login.jsp：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;$Title$&lt;&#x2F;title&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;$&#123;msg&#125;&lt;&#x2F;h1&gt;<br>&lt;form method&#x3D;&quot;get&quot; action&#x3D;&quot;&#x2F;login&quot;&gt;<br>    账号：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;users&quot; id&#x3D;&quot;users&quot;&gt;&lt;br&gt;<br>    密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;passwords&quot; id&#x3D;&quot;passwords&quot;&gt;&lt;br&gt;<br>    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &gt;<br>&lt;&#x2F;form&gt;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>
<p>result.jsp：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;&#x2F;title&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>    &lt;p&gt;当前用户：$&#123;user.users&#125;&lt;&#x2F;p&gt;<br>    &lt;form action&#x3D;&quot;&#x2F;exit&quot;&gt;<br>        &lt;button type&#x3D;&quot;submit&quot;&gt;退出&lt;&#x2F;button&gt;<br>    &lt;&#x2F;form&gt;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>
<p>直接进入result<br><img src="/2020/10/04/SpringMVC/1.png" alt="1"></p>
<p>输入账号密码<br><img src="/2020/10/04/SpringMVC/2.png" alt="2"></p>
<p>退出<br><img src="/2020/10/04/SpringMVC/3.png" alt="3"></p>
<p>再次直接进入result<br><img src="/2020/10/04/SpringMVC/4.png" alt="4"></p>
<h1 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a><strong>验证器</strong></h1><h2 id="Validator接口"><a href="#Validator接口" class="headerlink" title="Validator接口"></a><strong>Validator接口</strong></h2><p>创建自定义的验证器需要实现org.springframework.validation.Validator 接口，该接口有两个接口方法：</p>
<p>boolean supports(Class&lt;?&gt; klass)<br>void validate(Object object,Errors errors)</p>
<p>当supports返回true时，验证器可以处理指定的Class</p>
<p>validate 方法的功能是验证目标对象 object，并将验证错误消息存入 Errors 对象</p>
<p>往 Errors 对象存入错误消息的方法是 reject 或 rejectValue，这两个方法的部分重载方法如下：</p>
<p>void reject(String errorCode)<br>void reject(String errorCode,String defaultMessage)<br>void rejectValue(String filed,String errorCode)<br>void rejectValue(String filed,String errorCode,String defaultMessage)</p>
<h2 id="ValidationUtils类"><a href="#ValidationUtils类" class="headerlink" title="ValidationUtils类"></a><strong>ValidationUtils类</strong></h2><p>org.springframework.validation.ValidationUtils 是一个工具类</p>
<h2 id="验证器实例"><a href="#验证器实例" class="headerlink" title="验证器实例"></a>验证器实例</h2><p>引用上面用户登录的例子，当用户用户名或密码为空的时候，提示错误</p>
<p>在springmvc.validator包下创建MyValidator类，实现Validator接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class MyValidator implements Validator &#123;<br>    public boolean supports(Class&lt;?&gt; aClass) &#123;<br>        return User.class.isAssignableFrom(aClass);<br>    &#125;<br><br>    public void validate(Object o, Errors errors) &#123;<br>        User user &#x3D; (User)o;<br>        ValidationUtils.rejectIfEmpty(errors,&quot;users&quot;,&quot;user.users.required&quot;);<br>        ValidationUtils.rejectIfEmpty(errors,&quot;passwords&quot;,&quot;passwords.invalid&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在interceptor-servlet.xml中添加对validator包的自动扫描机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">    &lt;context:component-scan base-package&#x3D;&quot;springmvc.validator&quot;&gt;&lt;&#x2F;context:component-scan&gt;<br><br>修改UserController中的login处理方法<br><br>public String login(@ModelAttribute User user, HttpSession session, Model model, BindingResult result)&#123;<br>    MyValidator myValidator &#x3D; new MyValidator();<br>    if(myValidator.supports(User.class))&#123;<br>    	myValidator.validate(user,result);<br>        List&lt;ObjectError&gt; list &#x3D; result.getAllErrors();<br>        for(ObjectError error:list)&#123;<br>            System.out.println(error.getCode());<br>        &#125;<br>    &#125;<br>    if(result.hasErrors())  return &quot;redirect:tologin&quot;;<br>    if(&quot;123&quot;.equals(user.getUsers())&amp;&amp;&quot;123&quot;.equals(user.getPasswords()))&#123;<br>        session.setAttribute(&quot;user&quot;,user);<br>        return &quot;redirect:result&quot;;<br>    &#125;<br>    model.addAttribute(&quot;msg&quot;,&quot;用户名或密码错误，请重新登录！&quot;);<br>    return &quot;login&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时，若不输入账号密码直接登录，则终端输出</p>
<p>user.users.required<br>passwords.invalid</p>
<h2 id="Spring-MVC-JSR-303验证框架之Hibernate-Validator"><a href="#Spring-MVC-JSR-303验证框架之Hibernate-Validator" class="headerlink" title="Spring MVC JSR-303验证框架之Hibernate-Validator"></a><strong>Spring MVC JSR-303验证框架之Hibernate-Validator</strong></h2><p>JSR-303是一个数据验证的规范，JSR-303的校验是基于注解的，Spring中没有对这一规范进行实现，所以在SpringMVC中使用JSR-303的时候就需要提供一个对JSR-303规范的实现，而Hibernate-Validator是实现了这一规范的，使用Hibernate-Validator进行验证，不再需要实现Validator接口</p>
<p>Hibernate-Validator内部已经定义好了一系列的限制注解，我们只需要把这些注解标记在需要验证的实体类的属性上或是其对应的get方法上</p>
<p><strong>注：要使用Hibernate-Validator进行验证，需要在配置文件中加上</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mvc:annotation-driven&#x2F;&gt;  <br></code></pre></td></tr></table></figure>
<p><strong>并添加依赖：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>        &lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;hibernate-validator&lt;&#x2F;artifactId&gt;<br>        &lt;version&gt;6.1.6.Final&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>使用Hibernate-Validator进行验证，可以在要验证的 类的属性 或 getter方法加上相应的注解</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Nul</td>
<td>被注释的元素必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>被注释的元素必须不为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>被注释的元素必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>被注释的元素必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@Size(max, min)</td>
<td>被注释的元素的大小必须在指定的范围内，元素必须为集合，代表集合个数</td>
</tr>
<tr>
<td>@Digits (integer, fraction)</td>
<td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>
<tr>
<td>@Email</td>
<td>被注释的元素必须是电子邮箱地址</td>
</tr>
<tr>
<td>@Length(min=, max=)</td>
<td>被注释的字符串的大小必须在指定的范围内，必须为数组或者字符串，若微数组则表示为数组长度，字符串则表示为字符串长度</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>被注释的字符串的必须非空</td>
</tr>
<tr>
<td>@Range(min=, max=)</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>被注释的字符串的必须非空</td>
</tr>
<tr>
<td>@Pattern(regexp = )</td>
<td>正则表达式校验</td>
</tr>
<tr>
<td>@Valid</td>
<td>对象级联校验,即校验对象中对象的属性</td>
</tr>
</tbody></table>
<p>如：</p>
<p>在User的字段中添加标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class User &#123;<br><br>    @NotBlank(message &#x3D; &quot;用户名不能为空&quot;)<br>    private String users;<br><br>    @NotBlank(message &#x3D; &quot;密码不能为空&quot;)<br>	@Length(min &#x3D; 3,max &#x3D; 8,message &#x3D; &quot;密码位数为3-8位&quot;)<br>    private String passwords;<br><br>    &#x2F;&#x2F;省略getter和setter方法<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在UserController添加test处理方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(&quot;&#x2F;test&quot;)<br>public String test(@Valid User user,BindingResult result)&#123;<br>    if(result.hasErrors())&#123;<br>        for (ObjectError error:result.getAllErrors())&#123;<br>            System.out.println(error.getDefaultMessage());<br>        &#125;<br>    &#125;<br>    return &quot;test&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>test页面和login页面一样（省去拦截器）</p>
<p>部署项目，此时，如果账号密码都为空，直接登录，则输出</p>
<p>用户名不能为空<br>密码位数为3-8位<br>密码不能为空</p>
<h1 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a><strong>RESTful风格</strong></h1><p>RESTful风格是一个资源定位及操作的风格，它既不是标准也不是协议，仅仅只是一种风格，主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>使用RESTful风格可以通过相同的请求方式实现不同的效果，对于相同的请求方式，只要在表单元素中使用不同的method，然后在mvc的控制器相应的处理方法中使用不同的method作出回应，即可实现</p>
<p>原来的请求方式：</p>
<p><a href="http://localhost:8080/login?name=123&amp;passwords=123">http://localhost:8080/login?name=123&amp;passwords=123</a></p>
<p>使用RESTful风格：</p>
<p><a href="http://localhost:8080/login/123/123">http://localhost:8080/login/123/123</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(&quot;&#x2F;test&#x2F;&#123;name&#125;&#x2F;&#123;passwords&#125;&quot;)<br>public String login(@PathVariable int name,@PathVariable String passwords)&#123;<br>    System.out.println(name);<br>    System.out.println(passwords);<br>    return &quot;newresult&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>newresult页面为新jsp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;&#x2F;title&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;登录成功&lt;&#x2F;h1&gt;<br>    $&#123;name&#125;<br>    &lt;br&gt;<br>    $&#123;passwords&#125;<br>&lt;&#x2F;body&gt;<br>	&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<p>还可以使用对应于表单中的请求方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@RequestMapping(&quot;&#x2F;test&quot;,method &#x3D; RequestMethod.POST)<br>public String login(@PathVariable int name,@PathVariable String passwords)&#123;<br>    System.out.println(name);<br>    System.out.println(passwords);<br>    return &quot;newresult&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时，若表单中的请求方式为post，则会出现405方法不允许错误</p>
<p>也可以使用基于注解的请求方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@GetMapping(&quot;&#x2F;login&#x2F;&#123;name&#125;&#x2F;&#123;passwords&#125;&quot;)<br>public String login(@PathVariable int name, @PathVariable String passwords, Model model)&#123;<br>    model.addAttribute(&quot;name&quot;,name);<br>    model.addAttribute(&quot;passwords&quot;,passwords);<br>    return &quot;result&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP的API实现及SpringAOP实现原理</title>
    <url>/2020/10/02/AOP2/</url>
    <content><![CDATA[<h1 id="AOP的API实现"><a href="#AOP的API实现" class="headerlink" title="AOP的API实现"></a>AOP的API实现</h1><p>基于接口的aop实现一般为一下步骤：</p>
<!-- ## 基于动态代理的AOP实例 -->
<p>1.定义被代理者（被代理的类）</p>
<p>2.定义增强（切点几种执行状态中要做的动作）</p>
<p>3.定义切入点（给定规则 （正则表达式、AspectJ表达式），找出切入点位置）</p>
<p>4.定义切面（哪些切入点在执行过程中要做哪些动作 </p>
<p>与业务模块无关，但是却为被有模块所共同使用的逻辑块</p>
<p>5.设置代理 ：动态代理（代理接口）、CGLIB代理（代理具体类）<br>    配置被代理的对象<br>    配置切面<br>    配置被代理的接口</p>
<h2 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h2><p><img src="/2020/10/02/AOP2/pointcut.png" alt="Poingcut部分继承图"></p>
<p>其中最常使用的就是JdkRegexpMethodPointcut，根据一组表达式来匹配切入点</p>
<h2 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h2><p><img src="/2020/10/02/AOP2/advice.png" alt="Advice部分继承图"></p>
<p>需要为自己定义的增强实现这几种接口</p>
<h2 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h2><p>在基于API实现的AOP中，用Advisor表示Aspect</p>
<p><img src="/2020/10/02/AOP2/Advisor.png" alt="Advisor部分继承图"></p>
<p>其中最常用的是PointcutAdvisor接口的DefaultPointcutAdvisor实现类，它可以通过任意Pointcut和Advice定义一个切面</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>在Spring AOP中，根据一次创建代理的个数，可以分为创建单个代理的织入器和创建多个代理的织入器（即自动代理）。</p>
<p>Spring AOP中创建单个代理的织入器的类有：</p>
<ul>
<li>ProxyFactory</li>
<li>ProxyFactoryBean</li>
<li>AspectJProxyFactory</li>
</ul>
<p><img src="/2020/10/02/AOP2/singleproxy.png" alt="singleProxy"></p>
<p>默认情况下，SpringAOP会使用动态代理基于接口生成代理对象，当出现下列情况会使用CGLIB基于类生成代理对象。</p>
<ul>
<li>目标类没有实现任何接口</li>
<li>ProxyFactory的proxyTargetClass属性值被设置为true</li>
<li>ProxyFactory的optimize属性值被设置为true</li>
</ul>
<p>常用的自动代理类：</p>
<ul>
<li>BeanNameAutoProxyCreator</li>
<li>DefaultAdvisorAutoProxyCreator</li>
<li>AnnotationAwareAspectJAutoProxyCreator</li>
</ul>
<p><img src="/2020/10/02/AOP2/singleproxy.png" alt="autoProxy"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface Service &#123;<br>   	public void service();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class ServiceClass implements Service&#123;<br>    public void service()&#123;<br>        System.out.println(&quot;service&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyAspect implements MethodBeforeAdvice, AfterReturningAdvice &#123;<br>    @Override<br>&#x2F;&#x2F;    method是被调用的方法，objects是方法参数，o是被调用方法所属的对象<br>    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;<br>        System.out.println(method.getName()+&quot; &quot;+&quot;service&quot;);<br>        System.out.println(Arrays.toString(objects));<br>        System.out.println(o.getClass().getName());<br>        System.out.println(&quot;--------&quot;);<br>        System.out.println(&quot;before&quot;);<br>        System.out.println(&quot;--------&quot;);<br>    &#125;<br><br>    &#x2F;&#x2F;o是返回值<br>    @Override<br>    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;<br>        System.out.println(&quot;------&quot;);<br>        System.out.println(&quot;after&quot; + o);<br>        System.out.println(&quot;------&quot;);<br>    &#125;<br><br>&#125;<br><br>public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        Service service &#x3D; (Service)new ClassPathXmlApplicationContext(&quot;ApiContext.xml&quot;).getBean(&quot;proxy&quot;);<br>        service.service();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>xml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;<br>    &lt;bean id&#x3D;&quot;myAspect&quot; class&#x3D;&quot;APIAOP.MyAspect&quot;&gt;&lt;&#x2F;bean&gt;<br>    &lt;bean id&#x3D;&quot;serviceClass&quot; class&#x3D;&quot;APIAOP.ServiceClass&quot;&gt;&lt;&#x2F;bean&gt;<br>    &lt;bean id&#x3D;&quot;pointcut&quot; class&#x3D;&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot;&gt;<br>        &lt;property name&#x3D;&quot;pattern&quot; value&#x3D;&quot;.*service&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br>    &lt;bean id&#x3D;&quot;aspect&quot; class&#x3D;&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&gt;<br>        &lt;property name&#x3D;&quot;pointcut&quot; ref&#x3D;&quot;pointcut&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;property name&#x3D;&quot;advice&quot; ref&#x3D;&quot;myAspect&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;&#x2F;bean&gt;<br>    &lt;bean id&#x3D;&quot;proxy&quot; class&#x3D;&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;<br>        &lt;property name&#x3D;&quot;target&quot; ref&#x3D;&quot;serviceClass&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;property name&#x3D;&quot;interceptorNames&quot; value&#x3D;&quot;myAspect&quot;&#x2F;&gt;<br>        &lt;property name&#x3D;&quot;proxyInterfaces&quot; value&#x3D;&quot;APIAOP.Service&quot;&#x2F;&gt;<br>    &lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>

<h1 id="Spring中的AOP的实现原理"><a href="#Spring中的AOP的实现原理" class="headerlink" title="Spring中的AOP的实现原理"></a>Spring中的AOP的实现原理</h1><ul>
<li>JDK动态代理</li>
</ul>
<p>JDK动态代理通过“反射”来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</p>
<ul>
<li>Cglib动态代理</li>
</ul>
<p>JDK动态代理必须要有接口, 但如果要代理一个没有接口的类该怎么办呢? CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态地生成某个类的子类。注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。CGLIB动态代理的原理是生成目标类的子类,这个子类对象就是代理对象, 代理对象是被增强过的。</p>
<h2 id="JDK的动态代理"><a href="#JDK的动态代理" class="headerlink" title="JDK的动态代理"></a>JDK的动态代理</h2><p>JDK的动态代理需要了解一个接口和一个类，JDK动态代理的核心是InvocationHandler接口和Proxy类</p>
<h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><p>Proxy是一个代理类，其中只有一个newProxyInstance方法</p>
<pre><code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></pre>
<p>这个方法返回一个代理实例，其中的参数：</p>
<ul>
<li><p>ClassLoader loader为类加载器，加载类的字节码</p>
</li>
<li><p>Class&lt;?&gt;[] interfaces指定生成的代理对象必须实现的接口（因为被代理对象与代理对象应实现相同的接口）</p>
</li>
<li><p>InvocationHandler h </p>
</li>
</ul>
<h3 id="InvocationHandler接口"><a href="#InvocationHandler接口" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h3><p>InvocationHandler接口：代理类的方法被外界调用之后，将方法交给InvocationHandler，由它来实现对方法的增强</p>
<p>InvocationHandler接口只有一个invoke方法，由invoke方法实现对被代理方法的增强</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public Object invoke(Object proxy,Method method,Object[] args)<br></code></pre></td></tr></table></figure>
<p>其中的参数：</p>
<ul>
<li><p>Object proxy：代理对象实例</p>
</li>
<li><p>Method method：外界调用的方法</p>
</li>
<li><p>Object[] args：方法的参数</p>
</li>
</ul>
<p>我们发现，在invoke方法中没有找到我们想要的被代理对象，那我们在实现InvocationHandler接口的代理类中，一定要声明一个被代理对象的属性</p>
<p>定义一个User接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface User &#123;<br>    void use();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义接口的实现类UserImpl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class UserImpl implements User&#123;<br>    @Override<br>    public void use() &#123;<br>        System.out.println(&quot;user using&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义动态代理类MyJdkAspect：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyJdkAspect implements InvocationHandler &#123;<br>&#x2F;&#x2F;被代理对象<br>   private Object target;<br><br>   public MyJdkAspect()&#123;&#125;<br><br>   public MyJdkAspect(Object target)&#123;<br>       this.target &#x3D; target;<br>   &#125;<br><br>   @Override<br>   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;<br>        Object object &#x3D; null;<br>        System.out.println(&quot;before&quot;);<br>	&#x2F;&#x2F;        通过反射调用目标对象的方法<br>        object &#x3D; method.invoke(target,args);<br>        System.out.println(&quot;after&quot;);<br>        return object;<br>   	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>   public static void main(String[] args) &#123;<br>       User user &#x3D; new UserImpl();<br>       MyJdkAspect myJdkAspect &#x3D; new MyJdkAspect(user);<br>&#x2F;&#x2F;        创建代理实例<br>        User proxy &#x3D; (User) Proxy.newProxyInstance(user.getClass().getClassLoader(),user.getClass().getInterfaces(),myJdkAspect);<br>&#x2F;&#x2F;        代理对象proxy调用use方法时会自动调用invoke方法，实现增强<br>        proxy.use();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>before<br>user using<br>after</p>
<p><a href="https://blog.csdn.net/jiankunking/article/details/52143504?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160166897019195240408337%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160166897019195240408337&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-9-52143504.pc_first_rank_v2_rank_v28&utm_term=aop+jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86&spm=1018.2118.3001.4187#%E4%BA%8C%E3%80%81Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%C2%A0">参考链接</a></p>
<h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><p>使用cglib动态代理需要实现MethodInterceptor接口</p>
<p>MethodInterceptor接口中有一个intercept方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public Object intercept(Object object, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable;<br></code></pre></td></tr></table></figure>
<p>Object object 是代理对象</p>
<p>Method method 是拦截方法</p>
<p>Object[] args 是方法参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class NewUserImpl &#123;<br>   	public void use()&#123;<br>       	System.out.println(&quot;user using&quot;);<br>   	&#125;<br>&#125;<br><br>public class MyCglibProxy implements MethodInterceptor &#123;<br>	&#x2F;&#x2F;被代理的目标对象<br>    private Object target;<br>&#x2F;&#x2F;  生成代理类<br>    public Object creatProxyInstance(Object target)&#123;<br>        this.target &#x3D; target;<br>        Enhancer enhancer &#x3D; new Enhancer();<br>        enhancer.setSuperclass(this.target.getClass());<br>        enhancer.setCallback(this);<br>        return enhancer.create();<br>    &#125;<br><br>    &#x2F;&#x2F;重写拦截方法<br>    @Override<br>    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;<br>        Object object &#x3D; null;<br>        System.out.println(&quot;before&quot;);<br>        object &#x3D; methodProxy.invoke(target,objects);<br>        System.out.println(&quot;after&quot;);<br>        return object;<br>    &#125;<br>&#125;<br><br><br>public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        NewUserImpl newUser &#x3D; new NewUserImpl();<br>        NewUserImpl user &#x3D; (NewUserImpl) new MyCglibProxy().creatProxyInstance(newUser);<br>        user.use();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>java</tag>
        <tag>SSM框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP的两种实现方式（XML、AspectJ）</title>
    <url>/2020/09/25/AOP/</url>
    <content><![CDATA[<h1 id="基于XML配置的AOP实例"><a href="#基于XML配置的AOP实例" class="headerlink" title="基于XML配置的AOP实例"></a>基于XML配置的AOP实例</h1><p>要使用配置实现AOP编程，要在xml文件中使用<code>&lt;aop:config&gt;&lt;/aop:config&gt;</code>来声明，这种声明方式使用了大量的自动代理方式</p>
<p><strong>注：环境可能会缺少必要的包，如aopalliance.jar、aspectweaver.jar</strong></p>
<p>在<code>&lt;aop:config&gt;&lt;/aop:config&gt;</code>中使用<code>&lt;aop:aspect id=&quot;&quot; ref=&quot;&quot;&gt;&lt;/aop:aspect&gt;</code>来配置一个切面，<code>&lt;aop:pointcut id expression/&gt;</code>来配置一个切入点，<code>&lt;aop:before(or other) method=&quot;&quot; pointcut=&quot;&quot;&gt;&lt;/aop:before&gt;</code>配置一个增强，这三个就组成了一个完整的切面</p>
<p>下面介绍如何配置一个切面和切面中的几种增强</p>
<p>定义一个业务类ServiceClass：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class ServiceClass &#123;<br>    public void service()&#123;<br>        System.out.println(&quot;this is service&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义一个MyAspect切面类，生成配置文件newcontext.xml，其中，MyAspect类使用Component注解配置</p>
<h2 id="before"><a href="#before" class="headerlink" title="before"></a>before</h2><p><strong>before是业务方法执行前进行的操作</strong></p>
<p>在切面类中添加before方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class MyAspect &#123;<br>    public void before()&#123;<br>        System.out.println(&quot;MyAspect&#39;s before&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>newcontext.xml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;<br>    &lt;context:component-scan base-package&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;context:component-scan&gt;<br>    &lt;aop:config&gt;<br>        &lt;aop:aspect id&#x3D;&quot;aspect&quot; ref&#x3D;&quot;myAspect&quot;&gt;<br>            &lt;aop:pointcut id&#x3D;&quot;pointcut&quot; expression&#x3D;&quot;execution(* newdemo.ServiceClass.*(..))&quot;&#x2F;&gt;<br>            &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&gt;&lt;&#x2F;aop:before&gt;<br>        &lt;&#x2F;aop:aspect&gt;<br>    &lt;&#x2F;aop:config&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
<p>其中，切点中的expression的含义为：切点为newdemo.ServiceClass这个包中的所有方法</p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        ServiceClass serviceClass &#x3D; (ServiceClass)applicationContext.getBean(&quot;serviceClass&quot;);<br>        serviceClass.service();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>MyAspect’s before<br>this is service</p>
<h2 id="after"><a href="#after" class="headerlink" title="after"></a>after</h2><p><strong>业务方法执行完毕进行的操作，通常用于释放资源</strong></p>
<p>在切面类中添加after方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void after()&#123;<br>        System.out.println(&quot;MyAspect&#39;s after&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aop:after method&#x3D;&quot;after&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&gt;&lt;&#x2F;aop:after&gt;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>MyAspect’s before<br>this is service<br>MyAspect’s after</p>
<h2 id="after-returing"><a href="#after-returing" class="headerlink" title="after-returing"></a>after-returing</h2><p><strong>after-returing是业务方法返回前进行的操作</strong></p>
<p>在切面类中添加after-returning方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void afterReturning()&#123;<br>        System.out.println(&quot;MyAspect&#39;s afterReturning&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aop:after-returning method&#x3D;&quot;afterReturning&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&gt;&lt;&#x2F;aop:after-returning&gt;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>MyAspect’s before<br>this is service<br>MyAspect’s after<br>MyAspect’s afterReturning</p>
<h2 id="after-throwing"><a href="#after-throwing" class="headerlink" title="after-throwing"></a>after-throwing</h2><p><strong>after-throwing是业务方法抛出异常后进行的操作</strong></p>
<p>切面类添加afterthrowing方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void afterThrowing()&#123;<br>    System.out.println(&quot;MyAspect&#39;s afterThrowing&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在业务类ServiceClass的service方法中抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void service() throws Exception&#123;<br>    System.out.println(&quot;this is service&quot;);<br>    throw new Exception();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aop:after-throwing method&#x3D;&quot;afterThrowing&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&gt;&lt;&#x2F;aop:after-throwing&gt;<br></code></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        ServiceClass serviceClass &#x3D; (ServiceClass)applicationContext.getBean(&quot;serviceClass&quot;);<br>        try &#123;<br>            serviceClass.service();<br>        &#125;<br>        catch (Exception e)&#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>MyAspect’s before<br>this is service<br>MyAspect’s after<br>MyAspect’s afterThrowing</p>
<h2 id="around"><a href="#around" class="headerlink" title="around"></a>around</h2><p><strong>around：Advice最强操作，可以综合前面四种advice</strong></p>
<p>around方法必须有Object返回值，且第一个形参必须为ProceedingJoinPoint类型，around既可以在执行业务方法之前增强动作，也能在执行业务方法之后进行增强的执行，around增强可以决定业务方法在什么时候执行，在around方法体内，只有调用ProceedingJoinPoint参数的procedd()方法才会执行业务方法</p>
<p>在切面类中添加around方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public Object around(ProceedingJoinPoint pjp)&#123;<br>    Object object &#x3D; null;<br>    try&#123;<br>        object &#x3D; pjp.proceed();<br>        System.out.println(&quot;MyAspect&#39;s around&quot;);<br>    &#125;<br>    catch (Throwable throwable) &#123;<br><br>    &#125;<br>    return object;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;<br>    &lt;context:component-scan base-package&#x3D;&quot;newdemo&quot;&gt;&lt;&#x2F;context:component-scan&gt;<br>    &lt;aop:config&gt;<br>        &lt;aop:aspect id&#x3D;&quot;aspect&quot; ref&#x3D;&quot;myAspect&quot;&gt;<br>            &lt;aop:pointcut id&#x3D;&quot;pointcut&quot; expression&#x3D;&quot;execution(* newdemo.ServiceClass.*(..))&quot;&#x2F;&gt;<br>            &lt;aop:around method&#x3D;&quot;around&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&gt;&lt;&#x2F;aop:around&gt;<br>        &lt;&#x2F;aop:aspect&gt;<br>    &lt;&#x2F;aop:config&gt;<br>&lt;&#x2F;beans&gt;<br><br></code></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>public static void main(String[] args) &#123;<br>    ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>    ServiceClass serviceClass &#x3D; (ServiceClass)applicationContext.getBean(&quot;serviceClass&quot;);<br>    serviceClass.service();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>this is service<br>MyAspect’s around</p>
<p>改变around方法中两条语句的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">System.out.println(&quot;MyAspect&#39;s around&quot;);<br>   object &#x3D; pjp.proceed();<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>MyAspect’s around<br>this is service</p>
<p>说明只有在执行ProceedingJoinPoint对象的proceed方法后，才会执行业务方法</p>
<p><strong>advice-parameters：可以往增强方法中传入业务方法中的参数，在切入点配置好参数类型和属性名即可</strong></p>
<p><strong>下面用around来模拟前面的advice</strong></p>
<p>切面类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class MyAspect &#123;<br>    public Object around(ProceedingJoinPoint pjp)&#123;<br>        Object object &#x3D; null;<br>        System.out.println(&quot;before&quot;);       &#x2F;&#x2F;此时还未执行pjp的proceed方法，业务方法不会执行，所以相当于实现advice增强<br>        try&#123;<br>            object &#x3D; pjp.proceed();<br>        &#125;<br>        catch (Throwable throwable) &#123;       &#x2F;&#x2F;pjp.proceed()方法若捕捉异常，则说明业务方法会抛出一个异常<br>        &#125;<br>        finally &#123;<br>        	System.out.println(&quot;after&quot;);    &#x2F;&#x2F;此时捕捉异常，业务方法执行完毕，所以相当于实现after增强<br>        &#125;<br>        System.out.println(&quot;after throwing&quot;);   &#x2F;&#x2F;这就模拟after-throwing增强<br>        return object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;<br>    &lt;context:component-scan base-package&#x3D;&quot;newdemo&quot;&gt;&lt;&#x2F;context:component-scan&gt;<br>    &lt;aop:config&gt;<br>        &lt;aop:aspect id&#x3D;&quot;aspect&quot; ref&#x3D;&quot;myAspect&quot;&gt;<br>            &lt;aop:pointcut id&#x3D;&quot;pointcut&quot; expression&#x3D;&quot;execution(* newdemo.ServiceClass.*(..))&quot;&#x2F;&gt;<br>            &lt;aop:around method&#x3D;&quot;around&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&gt;&lt;&#x2F;aop:around&gt;<br>        &lt;&#x2F;aop:aspect&gt;<br>    &lt;&#x2F;aop:config&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        ServiceClass serviceClass &#x3D; (ServiceClass)applicationContext.getBean(&quot;serviceClass&quot;);<br>        try &#123;<br>            serviceClass.service();<br>        &#125;<br>        catch (Exception e)&#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="advice-parameters"><a href="#advice-parameters" class="headerlink" title="advice-parameters"></a>advice-parameters</h2><p>在pointcut的expression中指定方法参数，可以获取业务方法中的参数，从而使增强方法中能使用这些参数</p>
<p>ServiceClass类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class ServiceClass &#123;<br>    public void parametersService(String name,int age)&#123;<br>        System.out.println(&quot;parametersService&#39;s&quot;+name+&quot; &quot;+age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>切面类中添加ParametersMethod方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void ParametersMethod(String name,int age)&#123;<br>    System.out.println(&quot;ParametersMethod&#39;s&quot;+name+&quot; &quot;+age);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aop:before method&#x3D;&quot;ParametersMethod&quot; <br>pointcut&#x3D;&quot;execution(* newdemo.ServiceClass.parametersService(String,int)) and args(name,age)&quot;&gt;&lt;&#x2F;aop:before&gt;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        ServiceClass serviceClass &#x3D; (ServiceClass)applicationContext.getBean(&quot;serviceClass&quot;);<br>        serviceClass.parametersService(&quot;zzzz&quot;,21);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="Introduction-引入"><a href="#Introduction-引入" class="headerlink" title="Introduction 引入"></a>Introduction 引入</h2><p>Introduction允许将一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象</p>
<p>由 <code>&lt;aop: declae-parents&gt;</code>元素声明 </p>
<p>定义一个MyInterface接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface MyInterface &#123;<br>    public void show();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接口实现类MyInterfaceImpl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyInterfaceImpl implements MyInterface&#123;<br>    @Override<br>    public void show() &#123;<br>        System.out.println(&quot;this is my interface&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aop:declare-parents types-matching&#x3D;&quot;newdemo.ServiceClass&quot; implement-interface&#x3D;&quot;newdemo.MyInterface&quot; default-impl&#x3D;&quot;newdemo.MyInterfaceImpl&quot;&gt;&lt;&#x2F;aop:declare-parents&gt;<br></code></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        MyInterface myInterface &#x3D; (MyInterface)applicationContext.getBean(&quot;serviceClass&quot;);<br>        myInterface.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>introduction的作用是强行为ServiceClass添加一个父类，即MyInterface接口，由ServiceClass作为接口的实现类</p>
<h1 id="基于-AspectJ注解的AOP实例"><a href="#基于-AspectJ注解的AOP实例" class="headerlink" title="基于@AspectJ注解的AOP实例"></a><strong>基于@AspectJ注解的AOP实例</strong></h1><p>@AspectJ是预编译的AOP实现方式，@AspecJ的风格类似纯java注解的普通java类，@AspectJ是指明aspects的另一种风格，像基于注解的IOC一样，基于注解的配置能让开发变得更加方便。</p>
<p>对@AspectJ的支持可以使用XML或java注释风格的配置，两种方法的作用是一样的</p>
<ul>
<li>使用XMl，要在配置文件中加上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aop: aspectj-autoproxy&gt;&lt;&#x2F;aop: aspectj-autoproxy&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>java注释风格的配置</li>
</ul>
<p>在切面类中添加注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>@EnableAspectJAutoProxy<br></code></pre></td></tr></table></figure>

<p><strong>下面使用XML文件配置的方式。</strong></p>
<p>实现一个业务类ServiceCLass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class ServiceCLass &#123;<br>	    public void service()&#123;<br>    	System.out.println(&quot;service&quot;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>生成配置文件AspectJContext.xml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;<br>       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;<br><br>    &lt;context:component-scan base-package&#x3D;&quot;NewAspectJ&quot;&gt;&lt;&#x2F;context:component-scan&gt;<br>    &lt;aop:aspectj-autoproxy&gt;&lt;&#x2F;aop:aspectj-autoproxy&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>

<h2 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h2><p>拥有@Aspect的任何bean都会被Spring自动识别并应用</p>
<p>用@Aspect注解的类可以有字段和方法，也可以有切入点、通知、引入等</p>
<p>@Aspect要和@Component一起使用，@Component是自动配置一个bean，而@Aspect是自动将这个bean配置为切面（或者在XML中手动配置bean）</p>
<p>定义切面类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>@Aspect<br>public class MyAspect &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h2><p>@Pointcut = 表达式+签名</p>
<p><strong>@Pointcut的表达式标签有10中：</strong></p>
<ul>
<li>execution：用于匹配方法执行的连接点</li>
<li>within：用于匹配指定类型内的方法执行</li>
<li>this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配</li>
<li>target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配</li>
<li>args：用于匹配当前执行的方法传入的参数为指定类型的执行方法</li>
<li>@within：用于匹配所以持有指定注解类型内的方法</li>
<li>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解</li>
<li>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行</li>
<li>@annotation：用于匹配当前执行方法持有指定注解的方法</li>
<li>bean：SpringAOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法</li>
</ul>
<p>切入点使用@Pointcut对方法进行注解，方法返回类型必须为void，@Pointcut实际上是将方法名作为切入点的一个签名，即方法名=切入点id</p>
<p>在切面类中添加pointcut签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>@Aspect<br>public class MyAspect &#123;<br>    <br>    @Pointcut(&quot;execution(* NewAspectJ.ServiceCLass.service(..))&quot;)<br>    public void pointcut()&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>等效于在配置文件中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aop:pointcut id&#x3D;&quot;pointcut&quot; expression&#x3D;&quot;execution(* NewAspectJ.ServiceCLass.service(..))&quot;&#x2F;&gt;<br></code></pre></td></tr></table></figure>
<p>Pointcut定义时，还可以使用&amp;&amp;、||、！这三种运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Pointcut(&quot;within(NewAspectJ.ServiceCLass)&quot;)<br>public void pointcut1()&#123;&#125;<br>@Pointcut(&quot;execution(public * *(..))&quot;)<br>public void pointcut2()&#123;&#125;<br>@Pointcut(&quot;pointcut1()&amp;&amp;pointcut2()&quot;)<br>public void pointcut3()&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>pointcut3表示切点为NewAspect.ServiceClass类中的所有public方法</p>
<h2 id="Adivce"><a href="#Adivce" class="headerlink" title="@Adivce"></a>@Adivce</h2><h3 id="Before"><a href="#Before" class="headerlink" title="@Before"></a><strong>@Before</strong></h3><p>在切面类中添加before方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Before(&quot;pointcut()&quot;)<br>public void before()&#123;<br>    System.out.println(&quot;before&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>等效于在配置文件中的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&gt;&lt;&#x2F;aop:before&gt;<br></code></pre></td></tr></table></figure>

<p>其他advice同理</p>
<h3 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="@AfterReturning"></a><strong>@AfterReturning</strong></h3><p>有时候需要在通知体内得到返回的实际值，可使用@AfterReturning绑定返回值的形式</p>
<p>在业务类中添加serviceResult方法，用于返回result值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public String serviceResult()&#123;<br>    return &quot;success&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在切面类中添加新的切点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Pointcut(&quot;execution(* NewAspectJ.ServiceClass.serviceResult(..))&quot;)<br>public void pointcut4()&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>切面类中添加AfterReturning方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@AfterReturning(&quot;pointcut4(),returning &#x3D; &quot;Result&quot;&quot;)<br>public void AfterReturning(String Result)&#123;<br>    System.out.println(&quot;AfterReturning &#39;s &quot; + Result);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>AfterReturning ‘s success</p>
<h3 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="@AfterThrowing"></a><strong>@AfterThrowing</strong></h3><p>有时候需要在通知体内得到抛出的异常，可使用像@AfterReturning那样的绑定返回值的形式</p>
<p>在service方法中抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void service() throws Exception&#123;<br>        System.out.println(&quot;service&quot;);<br>        throw new Exception(&quot;failed&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>切面类添加AfterThrowing方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@AfterThrowing(value &#x3D; &quot;pointcut()&quot;,throwing &#x3D; &quot;e&quot;)<br>public void AfterThrowing(Exception e)&#123;<br>    System.out.println(e.getMessage());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果：</p>
<p>before<br>service<br>failed</p>
<h3 id="After"><a href="#After" class="headerlink" title="@After"></a><strong>@After</strong></h3><p>与aop::after相同</p>
<h3 id="Around"><a href="#Around" class="headerlink" title="@Around"></a><strong>@Around</strong></h3><p>与aop:around相同</p>
<h3 id="给advice传递参数"><a href="#给advice传递参数" class="headerlink" title="@给advice传递参数"></a><strong>@给advice传递参数</strong></h3><p>在advice中使用advice(pointcut&amp;&amp;args)的方式将参数传给advice，若有重载方法，则会自动根据参数匹配</p>
<p>也可以使用Around中的ProceedingJoinPoint对象的getArgs方法返回参数数组</p>
<p>业务类中重载service方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void service(String users,String passwords)&#123;<br>    System.out.println(&quot;service &#39;s &quot; + users + &quot; &quot;+passwords);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>切面类实现around的advice：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Around(&quot;pointcut()&amp;&amp;args(users,passwords)&quot;)<br>public Object Around(ProceedingJoinPoint pjp,String users,String passwords)&#123;<br>    Object object &#x3D; null;<br>    System.out.println(&quot;Around&#39;s &quot; + users +&quot; &quot; + passwords);<br>    try&#123;<br>        object &#x3D; pjp.proceed();<br>        Object[] objects &#x3D; pjp.getArgs();<br>        System.out.println(&quot;也可以通过pjp.getArgs()获得参数&quot;);<br>        System.out.println(Arrays.toString(objects));<br>    &#125;<br>    catch (Throwable e)&#123;<br><br>    &#125;<br>    return object;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>java</tag>
        <tag>SSM框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之控制反转（IOC）</title>
    <url>/2020/09/24/IOC/</url>
    <content><![CDATA[<h2 id="IOC控制反转："><a href="#IOC控制反转：" class="headerlink" title="IOC控制反转："></a><strong>IOC控制反转：</strong></h2><h3 id="IOC案例："><a href="#IOC案例：" class="headerlink" title="IOC案例："></a><strong>IOC案例：</strong></h3><p>接口UserInterface：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface UserInterface &#123;<br>	public void use();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接口UserInterface的实现类 UserImpl：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class UserImpl implements UserInterface&#123;<br>@Override<br>	public void use() &#123;<br>    	System.out.println(&quot;User using!&quot;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试类 TextClass：</p>
<!--     import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext; -->
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TextClass &#123;<br>	public static void main(String[] args) &#123;<br>        UserInterface userInterface &#x3D; new UserImpl();<br>        userInterface.use();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>User using！</p>
<p>在使用IOC之前，我们一直是在程序中直接使用new来生成一个对象，但在IOC中，我们不需要在程序中使用new来创建对象，而是通过配置XML文件，把所需要的类写入XML文件中，由Spring来管理和获取对象</p>
<p>将TextCLass中程序改一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>public class TextClass &#123;<br>    public static void main(String[] args) &#123;<br>        String xmlPath &#x3D; &quot;ApplicationContext.xml&quot;;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(xmlPath);<br>        UserInterface userInterface &#x3D; (UserInterface)applicationContext.getBean(&quot;UserId&quot;);<br>        userInterface.use();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同时创建ApplicationContext.XML文件，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;<br><br>    &lt;bean id&#x3D;&quot;UserId&quot; class&#x3D;&quot;UserImpl&quot;&gt;&lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
<p>运行TextCLass，输出结果为：</p>
<p>User using！</p>
<p>这时候，我们在程序中<strong>由主动创建类</strong>转变为<strong>通过Spring管理和获取类</strong>，这一转变称为控制反转</p>
<hr>
<h2 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a><strong>DI依赖注入</strong></h2><p>在IOC中，我们实现了控制反转，产生了依赖，但在程序运行过程中，我们经常需要动态地向某个对象提供它所需要的其他类，这就需要用到依赖注入DI，要想实现依赖注入，我们必须在需要其他类的某个对象中提供一种渠道（方法）来将依赖注入，最后在XML文件中进行相应的配置</p>
<p>依赖注入通常有三种方法：</p>
<ul>
<li><p>Setter方法注入</p>
</li>
<li><p>构造方法注入</p>
</li>
<li><p>接口注入</p>
</li>
</ul>
<p>下面主要介绍前两种方法</p>
<h3 id="DI案例："><a href="#DI案例：" class="headerlink" title="DI案例："></a><strong>DI案例：</strong></h3><p>添加一个MyClass类，类中有私有成员 userInterface</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyInterface &#123;<br>	private UserInterface userInterface;<br>	public void show()&#123;<br>	    userInterface.use();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Setter方法注入"><a href="#Setter方法注入" class="headerlink" title="Setter方法注入"></a><strong>Setter方法注入</strong></h4><p>在类中添加Setter方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyClass &#123;<br>    private UserInterface userInterface;<br>    public void show()&#123;<br>        userInterface.use();<br>    &#125;<br>    public void setUserInterface(UserInterface userInterface)&#123;<br>        this.userInterface &#x3D; userInterface;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置XML文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>   xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;<br>&lt;bean id&#x3D;&quot;UserId&quot; class&#x3D;&quot;UserImpl&quot;&gt;&lt;&#x2F;bean&gt;<br>&lt;bean id&#x3D;&quot;MyClassId&quot; class&#x3D;&quot;MyClass&quot;&gt;<br>    &lt;property name&#x3D;&quot;userInterface&quot; ref&#x3D;&quot;UserId&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
<p>TextClass类中进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>public class TextClass &#123;<br>    public static void main(String[] args) &#123;<br>        String xmlPath &#x3D; &quot;ApplicationContext.xml&quot;;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(xmlPath);<br>        MyInterface myInterface &#x3D; (MyInterface)applicationContext.getBean(&quot;MyInterfaceId&quot;);<br>        myInterface.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果为：</p>
<p>User using！</p>
<h4 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a><strong>构造方法注入</strong></h4><p>在MyClass类中添加构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyClass &#123;<br>    private UserInterface userInterface;<br>    public void show()&#123;<br>        userInterface.use();<br>    &#125;<br>    public MyClass()&#123;&#125;<br>&#x2F;&#x2F;    构造方法注入<br>    public MyClass(UserInterface userInterface)&#123;<br>        this.userInterface &#x3D; userInterface;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置XML文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;<br>    &lt;bean id&#x3D;&quot;UserId&quot; class&#x3D;&quot;UserImpl&quot;&gt;&lt;&#x2F;bean&gt;<br>    &lt;bean id&#x3D;&quot;MyClassId&quot; class&#x3D;&quot;MyClass&quot;&gt;<br>        &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;UserId&quot;&gt;&lt;&#x2F;constructor-arg&gt;<br>    &lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
<p>如果有多个属性，index则按照从0…n进行配置</p>
<p>运行TextCLass，输出结果：</p>
<p>User Using！</p>
<h3 id="DI中属性的依赖注入"><a href="#DI中属性的依赖注入" class="headerlink" title="DI中属性的依赖注入"></a><strong>DI中属性的依赖注入</strong></h3><p>以setter方法注入为例：</p>
<p>新建一个User类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import java.util.*;<br><br>public class User &#123;<br>    private String id;<br>    private String name;<br>    private String[] strings &#x3D; new String[10];<br>    private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();<br>    private Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();<br>    private Map&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();<br><br>    public void setId(String id) &#123;<br>        this.id &#x3D; id;<br>    &#125;<br><br>    public void setName(String name) &#123;<br>        this.name &#x3D; name;<br>    &#125;<br><br>    public void setStrings(String[] strings) &#123;<br>        this.strings &#x3D; strings;<br>    &#125;<br><br>    public void setList(List&lt;String&gt; list) &#123;<br>        this.list &#x3D; list;<br>    &#125;<br><br>    public void setSet(Set&lt;String&gt; set) &#123;<br>        this.set &#x3D; set;<br>    &#125;<br><br>    public void setMap(Map&lt;String, Integer&gt; map) &#123;<br>        this.map &#x3D; map;<br>    &#125;<br><br>    public Map&lt;String, Integer&gt; getMap() &#123;<br>        return map;<br>    &#125;<br><br>    public Set&lt;String&gt; getSet() &#123;<br>        return set;<br>    &#125;<br><br>    public List&lt;String&gt; getList() &#123;<br>        return list;<br>    &#125;<br><br>    public String[] getStrings() &#123;<br>        return strings;<br>    &#125;<br><br>    public String getName() &#123;<br>        return name;<br>    &#125;<br><br>    public String getId() &#123;<br>        return id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置XML文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>   xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;<br><br>&lt;bean id&#x3D;&quot;UserId&quot; class&#x3D;&quot;User&quot;&gt;<br>    &lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;20185625&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zl&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;strings&quot;&gt;<br>        &lt;array&gt;<br>            &lt;value&gt;&quot;11&quot;&lt;&#x2F;value&gt;<br>            &lt;value&gt;&quot;22&quot;&lt;&#x2F;value&gt;<br>            &lt;value&gt;&quot;33&quot;&lt;&#x2F;value&gt;<br>        &lt;&#x2F;array&gt;<br>    &lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;list&quot;&gt;<br>        &lt;list&gt;<br>            &lt;value&gt;&quot;44&quot;&lt;&#x2F;value&gt;<br>            &lt;value&gt;&quot;55&quot;&lt;&#x2F;value&gt;<br>            &lt;value&gt;&quot;66&quot;&lt;&#x2F;value&gt;<br>        &lt;&#x2F;list&gt;<br>    &lt;&#x2F;property&gt;<br><br>    &lt;property name&#x3D;&quot;set&quot;&gt;<br>        &lt;set&gt;<br>            &lt;value&gt;&quot;77&quot;&lt;&#x2F;value&gt;<br>            &lt;value&gt;&quot;88&quot;&lt;&#x2F;value&gt;<br>            &lt;value&gt;&quot;99&quot;&lt;&#x2F;value&gt;<br>        &lt;&#x2F;set&gt;<br>    &lt;&#x2F;property&gt;<br><br>    &lt;property name&#x3D;&quot;map&quot;&gt;<br>        &lt;map&gt;<br>            &lt;entry key&#x3D;&quot;111&quot; value&#x3D;&quot;111&quot;&gt;&lt;&#x2F;entry&gt;<br>            &lt;entry key&#x3D;&quot;222&quot; value&#x3D;&quot;222&quot;&gt;&lt;&#x2F;entry&gt;<br>        &lt;&#x2F;map&gt;<br>    &lt;&#x2F;property&gt;<br><br>&lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br><br>import java.util.Arrays;<br><br>public class TextClass &#123;<br>    public static void main(String[] args) &#123;<br>        String xmlPath &#x3D; &quot;ApplicationContext.xml&quot;;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(xmlPath);<br><br>        User user &#x3D; (User)applicationContext.getBean(&quot;UserId&quot;);<br>        System.out.println(Arrays.toString(user.getStrings()));<br>        System.out.println(user.getList());<br>        System.out.println(user.getMap());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>[“11”, “22”, “33”]<br>[“44”, “55”, “66”]<br>{111=111, 222=222}</p>
<hr>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a><strong>Bean的作用域</strong></h2><p>定义一个ScopeClass类 和 TestClass：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class ScopeClass &#123;<br><br>    public void show()&#123;<br>        System.out.println(this.hashCode());<br>    &#125;<br><br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext&quot;);<br>        ScopeClass scopeClass &#x3D; (ScopeClass)applicationContext.getBean(&quot;ScopeClassId&quot;);<br>        scopeClass.show();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton:"></a><strong>singleton:</strong></h3><p>在XML文件中配置:    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;ScopeClassId&quot; class&#x3D;&quot;com.newdemo.ScopeClass&quot; scope&#x3D;&quot;singleton&quot;&gt;&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
<p>在TestClass进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>public static void main(String[] args) &#123;<br>    ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>    ScopeClass scopeClass &#x3D; (ScopeClass)applicationContext.getBean(&quot;ScopeClassId&quot;);<br>    scopeClass.show();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>346224929<br>346224929</p>
<p>说明bean中配置singleton单例，一个bean容器（同一个上下文）中只存在一份</p>
<hr>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype:"></a><strong>prototype:</strong></h3><p>在xml文件中将singleton改为prototype</p>
<p>输出结果：</p>
<p>550752602<br>680779399</p>
<p>说明每次使用都会创建新的实例</p>
<hr>
<h3 id="request和session"><a href="#request和session" class="headerlink" title="request和session"></a><strong>request和session</strong></h3><ul>
<li>request：每次http请求都会创建一个实例且仅在当前request有效</li>
<li>session：同上，每次http请求创建，当前session有效</li>
</ul>
<hr>
<h2 id="Bean的生命周期之初始化和销毁"><a href="#Bean的生命周期之初始化和销毁" class="headerlink" title="Bean的生命周期之初始化和销毁"></a><strong>Bean的生命周期之初始化和销毁</strong></h2><p>完整的Bean的生命周期包括：实例化、属性赋值、初始化、销毁，下面介绍初始化和销毁两部分</p>
<p>Bean的初始化和销毁方式有三种：</p>
<ul>
<li>自定义初始化和销毁方法</li>
<li>实现InitializingBean和DisposableBean接口</li>
<li>在xml头中为所有Bean定义默认的初始化和销毁方法</li>
</ul>
<p>定义一个LifeCircleClass类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class LifeCircleClass &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="自定义初始化和销毁方法"><a href="#自定义初始化和销毁方法" class="headerlink" title="自定义初始化和销毁方法"></a><strong>自定义初始化和销毁方法</strong></h3><p>在类中定义初始化和销毁方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class LifeCircleClass &#123;<br>	public void init()&#123;<br>    	System.out.println(&quot;init&quot;);<br>	&#125;<br>	public void destroy()&#123;<br>    	System.out.println(&quot;destroy&quot;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在xml文件中配置bean：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;LifeCircleClassId&quot; class&#x3D;&quot;com.newdemo.LifeCircleClass&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destroy&quot;&gt;&lt;&#x2F;bean&gt;<br><br></code></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>LifeCircleClass lifeCircleClass &#x3D; (LifeCircleClass)applicationContext.getBean(&quot;LifeCircleClassId&quot;);<br>((AbstractApplicationContext) applicationContext).close();  &#x2F;&#x2F;关闭容器<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>init<br>destroy</p>
<hr>
<h3 id="实现InitializingBean和DisposableBean接口"><a href="#实现InitializingBean和DisposableBean接口" class="headerlink" title="实现InitializingBean和DisposableBean接口"></a><strong>实现InitializingBean和DisposableBean接口</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class LifeCircleClass implements InitializingBean, DisposableBean &#123;<br><br>	@Override<br>	public void afterPropertiesSet() throws Exception &#123;<br>    	System.out.println(&quot;init&quot;);<br>	&#125;<br><br>	@Override<br>	public void destroy() throws Exception &#123;<br>    	System.out.println(&quot;destroy&quot;);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时可以不在xml文件中配置，测试结果相同</p>
<hr>
<h3 id="在xml文件头中配置默认的初始化和销毁方法"><a href="#在xml文件头中配置默认的初始化和销毁方法" class="headerlink" title="在xml文件头中配置默认的初始化和销毁方法"></a><strong>在xml文件头中配置默认的初始化和销毁方法</strong></h3><p>default-init-method 顶级 <beans> 元素属性上存在属性会导致Spring IoC容器 init 将bean类上调用的方法识别为初始化方法回调。当bean被创建和组装时，如果bean类具有这样的方法，则在适当的时候调用它。</beans></p>
<p>如：在LifeCircleClass中自定义init()和destroy()方法，在xml头中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;<br>   xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;<br>default-init-method&#x3D;&quot;init&quot; default-destroy-method&#x3D;&quot;destroy&quot;&gt;<br><br>	&lt;bean id&#x3D;&quot;ScopeClassId&quot; class&#x3D;&quot;com.newdemo.ScopeClass&quot; scope&#x3D;&quot;prototype&quot;&gt;&lt;&#x2F;bean&gt;<br><br>	&lt;bean id&#x3D;&quot;LifeCircleClassId&quot; class&#x3D;&quot;com.newdemo.LifeCircleClass&quot; &gt;&lt;&#x2F;bean&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
<p>新建一个InitClass类并在xml文件中配置，测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        InitClass initClass &#x3D; (InitClass) applicationContext.getBean(&quot;InitClassId&quot;);<br>        ((AbstractApplicationContext) applicationContext).close();  &#x2F;&#x2F;关闭容器<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试结果相同</p>
<hr>
<h2 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a><strong>Aware接口</strong></h2><p>Spring中有很多继承于Aware接口的字接口，如：</p>
<p><img src="/2020/09/24/IOC/3397380-6ef519bbc705ce28.png" alt="Aware"></p>
<p>aware翻译为感知的，根据字面意思Aware接口应该是具有某些感知的功能</p>
<p>下面介绍一下ApplicationContextAware接口和BeanNameAware接口</p>
<p>新建一个AwareClass类，继承BeanNameAware接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class AwareClass implements BeanNameAware &#123;<br>    private String BeanName;<br>    @Override<br>    public void setBeanName(String s) &#123;<br>        this.BeanName &#x3D; s;<br>    &#125;<br><br>    public String getBeanName() &#123;<br>        return BeanName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置bean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;AwareClassId&quot; class&#x3D;&quot;com.newdemo.AwareClass&quot;&gt;&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        AwareClass awareClass &#x3D; (AwareClass)applicationContext.getBean(&quot;AwareClassId&quot;);<br>        System.out.println(awareClass.getBeanName());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果</p>
<p>AwareClassId</p>
<p>实现BeanNameAware接口的类通过setter方法可以自动获取配置文件中的beanid</p>
<p>现在让Aware类继承ApplicationContextAware类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class AwareClass implements BeanNameAware, ApplicationContextAware &#123;<br>    private String BeanName;<br>    private ApplicationContext applicationContext;<br>    @Override<br>    public void setBeanName(String s) &#123;<br>        this.BeanName &#x3D; s;<br>    &#125;<br><br>    public String getBeanName() &#123;<br>        return BeanName;<br>    &#125;<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) &#123;<br>        this.applicationContext &#x3D; applicationContext;<br>    &#125;<br><br>    public ApplicationContext getApplicationContext() &#123;<br>        return applicationContext;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        AwareClass awareClass &#x3D; (AwareClass)applicationContext.getBean(&quot;AwareClassId&quot;);<br>        ApplicationContext applicationContext1 &#x3D; awareClass.getApplicationContext();<br>        System.out.println(applicationContext&#x3D;&#x3D;applicationContext1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时输出true，说明ApplicationContext接口中的setter方法可以自动获取该实现类所在的容器（上下文）</p>
<p>同理，其他Aware的子接口也同样具有感知功能</p>
<hr>
<h2 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a><strong>Bean的自动装配</strong></h2><p>对于Bean的属性的自动装配，此时不再需要在xml文件中手动对属性注入，主要有三种方式实现属性的自动装配：</p>
<ul>
<li>byname id==name</li>
<li>bytype 属性type == xml文件中的type</li>
<li>byconstructor 构造器列表参数type==属性类型</li>
</ul>
<p>定义一个Person类、PersonalInfo类、AddressInfo类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Person &#123;<br>    private PersonalInfo personalInfo;<br>    private AddressInfo addressInfo;<br><br>    public void setPersonalInfo(PersonalInfo personalInfo) &#123;<br>        this.personalInfo &#x3D; personalInfo;<br>    &#125;<br><br>    public void setAddressInfo(AddressInfo addressInfo) &#123;<br>        this.addressInfo &#x3D; addressInfo;<br>    &#125;<br><br>    public void show()&#123;<br>        System.out.println(personalInfo.getName()+&quot; &quot;+personalInfo.getAge());<br>        System.out.println(addressInfo.getProvince()+&quot; &quot;+addressInfo.getCity());<br>    &#125;<br>&#125;<br><br>public class PersonalInfo &#123;<br>    private String name;<br>    private int age;<br>    public void setName(String name) &#123;<br>        this.name &#x3D; name;<br>    &#125;<br>    public void setAge(int age) &#123;<br>        this.age &#x3D; age;<br>    &#125;<br><br>    public String getName() &#123;<br>        return name;<br>    &#125;<br><br>    public int getAge() &#123;<br>        return age;<br>    &#125;<br><br>    public int getAge() &#123;<br>        return age;<br>    &#125;<br>&#125;	<br><br>public class AddressInfo &#123;<br><br>    private String Province;<br>    private String city;<br><br>    public void setProvince(String province) &#123;<br>        Province &#x3D; province;<br>    &#125;<br><br>    public void setCity(String city) &#123;<br>        this.city &#x3D; city;<br>    &#125;<br><br>    public String getProvince() &#123;<br>        return Province;<br>    &#125;<br><br>    public String getCity() &#123;<br>        return city;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="byname"><a href="#byname" class="headerlink" title="byname"></a><strong>byname</strong></h3><p>使用byname自动装配，要求被装配的属性名要与xml文件中某个Bean的beanId相同，否则不进行装配</p>
<p>在xml中配置bean </p>
<p><strong><em>注：在配置id的时候尽量配置小写，不然有时候会出错，原因不清楚</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;personalInfo&quot; class&#x3D;&quot;com.newdemo.PersonalInfo&quot;&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zll&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br><br>&lt;bean id&#x3D;&quot;addressInfo&quot; class&#x3D;&quot;com.newdemo.AddressInfo&quot;&gt;<br>    &lt;property name&#x3D;&quot;province&quot; value&#x3D;&quot;GuangDong&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;city&quot; value&#x3D;&quot;GuangZhou&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br><br>&lt;bean id&#x3D;&quot;PersonId&quot; class&#x3D;&quot;com.newdemo.Person&quot; autowire&#x3D;&quot;byName&quot;&gt;&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        Person person &#x3D; (Person)applicationContext.getBean(&quot;PersonId&quot;);<br>        person.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果为：</p>
<p>zll 21<br>GuangDong GuangZhou</p>
<hr>
<h3 id="bytype"><a href="#bytype" class="headerlink" title="bytype"></a><strong>bytype</strong></h3><p>bytype要求属性的类型与xml文件中的类型相同时才自动装配</p>
<p>在xml文件中的autowire改为bytype，输出结果相同</p>
<hr>
<h3 id="byConstructor"><a href="#byConstructor" class="headerlink" title="byConstructor"></a><strong>byConstructor</strong></h3><p>在Person类中添加构造方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public Person(PersonalInfo personalInfo,AddressInfo addressInfo) &#123;<br>	this.personalInfo &#x3D; personalInfo;<br>	this.addressInfo &#x3D; addressInfo;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在xml文件中的autowire改为bytype，输出结果相同</p>
<hr>
<h2 id="注解实现Bean的自动配置"><a href="#注解实现Bean的自动配置" class="headerlink" title="注解实现Bean的自动配置"></a><strong>注解实现Bean的自动配置</strong></h2><p>Spring2.5引入了通过注解来配置bean及注入依赖的方法，使用注解配置时，不再需要通过xml文件配置bean类，简化了配置工作</p>
<h3 id="Component、-Service、-Controller、-Repository"><a href="#Component、-Service、-Controller、-Repository" class="headerlink" title="@Component、@Service、@Controller、@Repository"></a><strong>@Component、@Service、@Controller、@Repository</strong></h3><p>@Component是一个通用的Bean注解，通常用于注解业务中功能不清楚的Bean</p>
<p>@Service、@Controller、@Repository则是根据不同场景所采取的特定注解，在Spring的三层架构中，@Service对应业务层、@Controller对应控制层、@Repository对应持久层</p>
<p>以上四个注解能够自动装配某个类，相当于在xml文件中手动配置bean，默认的id为类名首字母小写</p>
<p>@Component的类中属性也会被自动装配（按构造器type自动装配）</p>
<p><strong><em>注：实现自动配置前，要在xml文件中加上：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;context:component-scan base-package&#x3D;&quot;packageName&quot;&#x2F;&gt;<br></code></pre></td></tr></table></figure>
<p>否则会出现找不到beanid的异常</p>
<p>还是上面的Person类，删除Person类在xml中的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class Person &#123;<br>    private PersonalInfo personalInfo;<br>    private AddressInfo addressInfo;<br><br>&#x2F;&#x2F;    public void setPersonalInfo(PersonalInfo personalInfo) &#123;<br>&#x2F;&#x2F;        this.personalInfo &#x3D; personalInfo;<br>&#x2F;&#x2F;    &#125;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    public void setAddressInfo(AddressInfo addressInfo) &#123;<br>&#x2F;&#x2F;        this.addressInfo &#x3D; addressInfo;<br>&#x2F;&#x2F;    &#125;<br><br><br>    public Person(PersonalInfo personalInfo,AddressInfo addressInfo) &#123;<br>        this.personalInfo &#x3D; personalInfo;<br>        this.addressInfo &#x3D; addressInfo;<br>    &#125;<br><br>    public void show()&#123;<br>        System.out.println(personalInfo.getName()+&quot; &quot;+personalInfo.getAge());<br>        System.out.println(addressInfo.getProvince()+&quot; &quot;+addressInfo.getCity());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        Person person &#x3D; (Person)applicationContext.getBean(&quot;person&quot;);<br>        person.show();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果</p>
<p>zll 21<br>GuangDong GuangZhou</p>
<p>完成Person的自动配置，且Person中的属性也自动装配</p>
<hr>
<h3 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h3><p>@Required作用于属性的setter方法，表明该属性必须在xml文件中进行配置，否则抛出异常</p>
<p>在Person类中添加属性String name、setter和getter方法，并添加@Required注解</p>
<p>若不进行配置，则会提示错误：</p>
<p><img src="/2020/09/24/IOC/1601282519408.jpg" alt="error"></p>
<p>添加配置即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;RequiredName&quot;&gt;&lt;&#x2F;property&gt;<br></code></pre></td></tr></table></figure>


<hr>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired注解的功能是为属性进行自动注入，@Autowired可作用于属性、setter、构造方法，@Autowired通过bytype方法查找上下文中与属性type相同的bean进行配置，@Autowired中默认为Required=true 即强制上下文必须要存在与属性type相同的bean，否则抛出异常，可用required=false消除这种强制性</p>
<p><strong>作用于属性</strong></p>
<p>当@Autowired作用于属性时，可以不用在类中添加该属性的setter方法或构造器，也不用在该类的bean中配置属性</p>
<p>将Person类中的PersonalInfo和AddressInfo都加上@Autowired注解，删除构造方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class Person &#123;<br>    @Autowired<br>    private PersonalInfo personalInfo;<br>    @Autowired<br>    private AddressInfo addressInfo;<br>&#x2F;&#x2F;    public void setPersonalInfo(PersonalInfo personalInfo) &#123;<br>&#x2F;&#x2F;        this.personalInfo &#x3D; personalInfo;<br>&#x2F;&#x2F;    &#125;<br>&#x2F;&#x2F;    public void setAddressInfo(AddressInfo addressInfo) &#123;<br>&#x2F;&#x2F;        this.addressInfo &#x3D; addressInfo;<br>&#x2F;&#x2F;    &#125;<br>&#x2F;&#x2F;    public Person(PersonalInfo personalInfo, AddressInfo addressInfo) &#123;<br>&#x2F;&#x2F;        this.personalInfo &#x3D; personalInfo;<br>&#x2F;&#x2F;        this.addressInfo &#x3D; addressInfo;<br>&#x2F;&#x2F;    &#125;<br><br>    public void show()&#123;<br>        System.out.println(personalInfo.getName()+&quot; &quot;+personalInfo.getAge());<br>        System.out.println(addressInfo.getProvince()+&quot; &quot;+addressInfo.getCity());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        Person person &#x3D; (Person)applicationContext.getBean(&quot;person&quot;);<br>        person.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果</p>
<p>zll 21<br>GuangDong GuangZhou</p>
<p>此时，如果把xml文件中PersonalInfo的bean配置删除，则会抛出异常， 因为使用@Autowired注解的属性，默认xml文件中必须存在与属性相同类型的bean</p>
<p>将PersonalInfo的@Autowired注解改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Autowired(required &#x3D; false)<br>private PersonalInfo personalInfo;<br></code></pre></td></tr></table></figure>
<p>此时通过编译，不过会抛出空指针异常，因为上下文无法匹配PersonalInfo这一属性，将Person类中的show函数注释PersonalInfo的输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void show()&#123;<br>&#x2F;&#x2F;        System.out.println(personalInfo.getName()+&quot; &quot;+personalInfo.getAge());<br>    System.out.println(addressInfo.getProvince()+&quot; &quot;+addressInfo.getCity());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果</p>
<p>GuangDong GuangZhou</p>
<hr>
<p><strong>作用于setter方法</strong></p>
<p>@Autowired作用于setter方法时，不需要在类的bean中配置属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Person &#123;<br>    private PersonalInfo personalInfo;<br>    private AddressInfo addressInfo;<br>    @Autowired<br>    public void setPersonalInfo(PersonalInfo personalInfo) &#123;<br>        this.personalInfo &#x3D; personalInfo;<br>    &#125;<br>    @Autowired<br>    public void setAddressInfo(AddressInfo addressInfo) &#123;<br>        this.addressInfo &#x3D; addressInfo;<br>    &#125;<br>&#x2F;&#x2F;    public Person(PersonalInfo personalInfo, AddressInfo addressInfo) &#123;<br>&#x2F;&#x2F;        this.personalInfo &#x3D; personalInfo;<br>&#x2F;&#x2F;        this.addressInfo &#x3D; addressInfo;<br>&#x2F;&#x2F;    &#125;<br><br>    public void show()&#123;<br>        System.out.println(personalInfo.getName()+&quot; &quot;+personalInfo.getAge());<br>        System.out.println(addressInfo.getProvince()+&quot; &quot;+addressInfo.getCity());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果相同，相当于bean中配置autowire=bytype</p>
<hr>
<p><strong>作用于构造方法</strong></p>
<p>与作用于setter方法同理</p>
<hr>
<p><strong>集合的注入</strong></p>
<p>Person类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Component<br>public class Person &#123;<br>    private PersonalInfo personalInfo;<br>    private AddressInfo addressInfo;<br>    private List&lt;PersonalInfo&gt; list;<br><br>    @Autowired<br>    public void setPersonalInfo(PersonalInfo personalInfo) &#123;<br>        this.personalInfo &#x3D; personalInfo;<br>    &#125;<br>    @Autowired<br>    public void setAddressInfo(AddressInfo addressInfo) &#123;<br>        this.addressInfo &#x3D; addressInfo;<br>    &#125;<br><br>    @Autowired<br>    public void setList(List&lt;PersonalInfo&gt; list) &#123;<br>        this.list &#x3D; list;<br>    &#125;<br><br>    public void show()&#123;<br>		list.forEach(v-&gt; System.out.println(v.getName()+&quot; &quot;+v.getAge()));<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<p>并在xml文件中再添加一个PersonalInfo的Bean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;personalInfo&quot; class&#x3D;&quot;com.newdemo.PersonalInfo&quot;&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zll&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br><br>&lt;bean id&#x3D;&quot;personalInfo1&quot; class&#x3D;&quot;com.newdemo.PersonalInfo&quot;&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zlll&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;211&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
<p>测试输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        Person person &#x3D; (Person)applicationContext.getBean(&quot;person&quot;);<br>        person.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出</p>
<p>zll 21<br>zlll 211</p>
<p>说明集合的自动装配中，会自动搜索上下文中与属性类型相同的bean，并把这些所有的bean同时注入集合中</p>
<p>将属性改为map映射      private Map&lt;String,PersonalInfo&gt; map;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public void show()&#123;<br>&#x2F;&#x2F;        System.out.println(personalInfo.getName()+&quot; &quot;+personalInfo.getAge());<br>&#x2F;&#x2F;        System.out.println(addressInfo.getProvince()+&quot; &quot;+addressInfo.getCity());<br>&#x2F;&#x2F;        System.out.println(list);<br>    map.forEach((k,v)-&gt; System.out.println(map.get(k).getName()+&quot; &quot;+map.get(k).getAge()));<br>    System.out.println();<br>    map.forEach((k,v)-&gt; System.out.println(k+&quot; &quot; +v));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出</p>
<p>zll 21<br>zlll 211</p>
<p>personalInfo com.newdemo.PersonalInfo@1eb5174b<br>personalInfo1 com.newdemo.PersonalInfo@67080771</p>
<p>说明是将bean的id作为键，对象作为值</p>
<hr>
<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a><strong>@Qualifier</strong></h3><p>当xml文件中存在多个type相同类型的bean时，若使用自动配置，编译器不知道该匹配哪个则会抛出异常，使用@Qualifier来制定匹配哪个bean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;personalInfo&quot; class&#x3D;&quot;com.newdemo.PersonalInfo&quot;&gt;<br>&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zll&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br>&lt;bean id&#x3D;&quot;personalInfo_Id&quot; class&#x3D;&quot;com.newdemo.PersonalInfo&quot;&gt;<br>&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zllll&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;2111&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br><br>@Autowired<br>@Qualifier(&quot;personalInfo_Id&quot;)<br>public void setPersonalInfo(PersonalInfo personalInfo) &#123;<br>this.personalInfo &#x3D; personalInfo;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出</p>
<p>zllll 2111</p>
<hr>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a><strong>@Bean</strong></h3><p>用@Bean注解的方法会配置、实例化一个新的对象，这个对象由IOC容器管理，bean_id为方法名，相当于 <bean id="method-name" class="..."></bean></p>
<p>新建一个CharacterInfo类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class CharacterInfo &#123;<br>    public void show()&#123;<br>        System.out.println(&quot;Character&#39;show&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Person类中添加CharacterInfo类属性，并添加getCharacterInfo()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public CharacterInfo getCharacterInfo()&#123;<br>    return new CharacterInfo();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在testClass中测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        CharacterInfo characterInfo &#x3D; (CharacterInfo)applicationContext.getBean(&quot;getCharacterInfo&quot;);<br>        characterInfo.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出</p>
<p>Character’show</p>
<hr>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a><strong>@Configuration</strong></h3><p>@Configuration用于定义配置类，相当于<beans>…</beans>，被注解的类内部包含一个或多个被@Bean注解的方法</p>
<p>将Person类的注解改为@Configuration，可得到相同的结果</p>
<ul>
<li>@Scope</li>
</ul>
<p>@Scope用来定义bean的作用域，默认单例，相当于<bean id class scope="singleton"></bean></p>
<p>将@Scope作用在Person类上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        Person person &#x3D; (Person)applicationContext.getBean(&quot;person&quot;);<br>        Person person1 &#x3D; (Person)applicationContext.getBean(&quot;person&quot;);<br>        System.out.println(person);<br>        System.out.println(person1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出</p>
<p>com.newdemo.Person$$EnhancerBySpringCGLIB$$5578c3b8@6f10d5b6<br>com.newdemo.Person$$EnhancerBySpringCGLIB$$5578c3b8@6f10d5b6</p>
<hr>
<h2 id="自定义命名策略"><a href="#自定义命名策略" class="headerlink" title="自定义命名策略"></a><strong>自定义命名策略</strong></h2><p>在Spring中，我们可以实现通过实现BeanNameGenerator接口，然后在xml文件中配置自定义命名类，来完成对bean的自定义命名策略    </p>
<p>定义MyBeanNameGenerator类，实现BeanNameGenerator接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class MyBeanNameGenerator implements BeanNameGenerator &#123;<br>    @Override<br>    public String generateBeanName(BeanDefinition beanDefinition, BeanDefinitionRegistry beanDefinitionRegistry) &#123;<br>        return beanDefinition.getBeanClassName()+&quot;Id&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class TestClass &#123;<br>    public static void main(String[] args) &#123;<br>        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;newcontext.xml&quot;);<br>        Person person &#x3D; (Person)applicationContext.getBean(&quot;com.newdemo.PersonId&quot;);<br>        person.show();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<p>zllll 2111</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>java</tag>
        <tag>SSM框架</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring简介</title>
    <url>/2020/09/22/Spring/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<h2 id="一-什么是Spring"><a href="#一-什么是Spring" class="headerlink" title="一.什么是Spring"></a><strong>一.什么是Spring</strong></h2><p>Spring轻量级的java开发框架，它是为了解决企业应用开发的复杂性而创建的，Spring的核心是控制反转(IOC)和面向切面(AOP)。</p>
<p>一句话概括就是 Spring是一个轻量级的、具有控制反转和面向切面的容器（框架）。</p>
<h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a><strong>什么是IOC</strong></h3><p>IOC的定义：所谓IOC，就是由Spring IOC容器来负责对象的生命周期和对象之间的关系。<br>在传统的开发模式下，我们在项目中都是使用new直接生成一个对象，也就是说我所需要的对象是由自己并控制的，但是有了IOC容器后我们所需要的对象由IOC容器负责管理，由原来的主动生成对象 -&gt; 由IOC容器生成对象 ，获得依赖对象的方式改变了，这就是控制反转。<br>在IOC中，通过以配置xml文件或是注解的方式将我们所需要的类和类的路径进行说明，然后在项目中通过<strong>上下文模块</strong>获取xml文件的路径，由IOC容器提供所需要的类<br><a href="https://zhuanlan.zhihu.com/p/64001753">IOC参考链接</a></p>
<h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a><strong>什么是AOP</strong></h3><p>AOP：Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护和处理的一种技术。但如果我们在开发过程中多个模块间有某些功能相同的代码，但是模块间又不存在一种层次间的关系，这时候功能如果需要改变，那么需要对每个类进行改动，这是一个很大的工程，这时候怎么解决代码重复这样的问题呢？答案就是使用AOP，AOP技术利用一种称为“横切”的技术，解剖封装的对象内部，并将类间共同的行为封装到一个新的可重用模块中，减少重复代码，降低模块间的耦合度。</p>
<h3 id="AOP的实现方式有："><a href="#AOP的实现方式有：" class="headerlink" title="AOP的实现方式有："></a>AOP的实现方式有：</h3><ul>
<li>预编译：AspectJ</li>
<li>运行期动态代理（JDK动态代理、CGLib动态代理）：SpringAOP、JbossAOP</li>
</ul>
<h3 id="AOP的主要功能："><a href="#AOP的主要功能：" class="headerlink" title="AOP的主要功能："></a>AOP的主要功能：</h3><ul>
<li>日志记录</li>
<li>性能统计</li>
<li>安全控制</li>
<li>事务处理</li>
<li>异常处理</li>
</ul>
<h3 id="AOP的主要意图："><a href="#AOP的主要意图：" class="headerlink" title="AOP的主要意图："></a>AOP的主要意图：</h3><p>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码，使业务逻辑更加纯粹</p>
<h3 id="AOP中专业的概念定义："><a href="#AOP中专业的概念定义：" class="headerlink" title="AOP中专业的概念定义："></a><strong>AOP中专业的概念定义：</strong></h3><ul>
<li><p>Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。 基于配置的切面只支持singleton模式</p>
</li>
<li><p>Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</p>
</li>
<li><p>Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</p>
</li>
<li><p>Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，有before、after、after-returing、after-throwing、around五种增强。</p>
</li>
<li><p>Introduction（引入）：在不修改类代码的前提下，为类添加新的方法和属性。<br>允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象</p>
</li>
<li><p>Target（目标对象）：织入 Advice 的目标对象。</p>
</li>
<li><p>AOP Proxy（AOP代理） AOP框架创建的对象，用来实现切面契约</p>
</li>
<li><p>Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</p>
</li>
</ul>
<h3 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a><strong>个人理解：</strong></h3><ul>
<li><p>Joint point：是所有可能被织入到Advice中的点,一个类中所有的方法都是连接点</p>
</li>
<li><p>Pointcut：提供一组规则，将符合规则的一组Joint point织入到Advice中</p>
</li>
<li><p>Advice：Advice说明了Pointcut中Joint Point上将要执行的一些动作，即一串代码</p>
</li>
<li><p>Aspect：切面是Advice和Pointcut的组合，描述了切点的行为</p>
</li>
</ul>
<h2 id="二-Spring的组成"><a href="#二-Spring的组成" class="headerlink" title="二.Spring的组成"></a><strong><em>二.Spring的组成</em></strong></h2><p><img src="/2020/09/22/Spring/SpringFramworkRuntime.png" alt="framework"></p>
<p><a href="https://www.cnblogs.com/jpwz/p/10556012.html">参考链接</a></p>
<p>spring由多个模块组成，下面介绍spring每个模块及其功能</p>
<h3 id="Core-Container-核心容器"><a href="#Core-Container-核心容器" class="headerlink" title="Core Container 核心容器"></a><strong>Core Container 核心容器</strong></h3><p>Spring核心容器建立在Beans、Core、Context、SpEl模块之上</p>
<p>Beans模块提供了BeanFactory，是工厂模式的一个经典体现，所有被Spring管理的对象都称为Beans</p>
<p>Core模块提供了框架的基本组成部分，包括IOC和、DI（依赖注入）功能</p>
<p>Context上下文模块建立在Beans和Core模块基础之上，提供了一个框架式的对象访问方式，是访问定义和配置中Beans对象的媒介，ApplicationContext接口通过xml文本的路径访问配置中的beans对象。</p>
<p>SpEl是Spring表达式语言，它提供了强大的表达式语言去支持运行时查询和操作对象</p>
<h3 id="面向切面编程模块"><a href="#面向切面编程模块" class="headerlink" title="面向切面编程模块"></a><strong>面向切面编程模块</strong></h3><p>AOP模块提供了符合AOP要求的面向切面编程的实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，是纯Java实现</p>
<p>Aspects模块提供了AspectJ的集成功能，AspectJ是一个基于Java语言的AOP框架</p>
<p>Instrument模块提供了类植入支持和类加载器的实现，可在特定的应用服务器中使用</p>
<h3 id="数据访问模块"><a href="#数据访问模块" class="headerlink" title="数据访问模块"></a><strong>数据访问模块</strong></h3><p>JDBC、DAO模块：JDBC模块是对JDBC的抽象，减少JDBC编程的代码量</p>
<p>ORM模块：封装了大量的对象关系映射的API</p>
<h3 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a><strong>Web模块</strong></h3><p>WebSocket模块：提供WebScoket、SockJS的实现，以及对STOMP的支持</p>
<p>Servlet模块：也称为Spring-webmvc模块，包含了Spring的MVC。</p>
<p>Web模块：提供基本的Web开发集成特性，比如多文件上传功能、使用Servlet监听器来初始化Ioc容器以及Web应用上下文。</p>
<p>Portlet模块：提供了对在Portlet环境中使用MVC的支持。</p>
<!-- 底层是Spring的核心容器，包括Beans容器、上下文、Spring表达式和核心工具，是Spring框架最基本的支撑
中间层是Spring的功能组件
上层是Spring的具体使用 -->]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>java</tag>
        <tag>SSM框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之Stream流</title>
    <url>/2020/09/22/JavaStream/</url>
    <content><![CDATA[<p>今天在写java实验的过程中，想用Stream流省事时，却发现自己对Stream流有点生疏了，所以特地翻开以前写的Stream流的demo记录下来，以便加深印象。</p>
<blockquote>
</blockquote>
<h2 id="一-什么是Java-Stream流"><a href="#一-什么是Java-Stream流" class="headerlink" title="一.什么是Java Stream流"></a><strong><em>一.什么是Java Stream流</em></strong></h2><p>Stream流是java8 API中添加的一个新的抽象，它使用一种类似SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的抽象。</p>
<p>它将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道上进行对集合的处理，比如对集合就行筛选过滤、排序（自定义或是默认）、聚合等操作。</p>
<p>Stream流的处理中，元素在管道中经过中间操作的处理，最后由最终操作得到前面处理的结果。</p>
<blockquote>
</blockquote>
<h2 id="二-Stream流的特点"><a href="#二-Stream流的特点" class="headerlink" title="二.Stream流的特点"></a><strong><em>二.Stream流的特点</em></strong></h2><p>1.Stream流不是数据结构，它不会保存数据，流可以是一个泛型。</p>
<p>2.可以对集合、数组进行连续的操作。</p>
<p>3.Stream流的数据源可以有集合、数组等。</p>
<p>4.它不会修改原来的数据源，它会将操作后的数据保存到另外一个对象中。</p>
<p>5.Stream是惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。</p>
<blockquote>
</blockquote>
<h2 id="三-为什么要使用Stream流"><a href="#三-为什么要使用Stream流" class="headerlink" title="三.为什么要使用Stream流"></a><strong><em>三.为什么要使用Stream流</em></strong></h2><p>Stream API 可以极大提高程序员的生产力，让程序员以一种声明的方式处理数据，一行代码对集合进行多种操作，让我们写出更高效、简洁、有效率的代码。</p>
<blockquote>
</blockquote>
<h2 id="四-Stream流的用法"><a href="#四-Stream流的用法" class="headerlink" title="四.Stream流的用法"></a><strong><em>四.Stream流的用法</em></strong></h2><p><strong>另外，在使用流的时候，先不要重复使用同一个流，后面会讲到原因</strong></p>
<h3 id="1-流的创建"><a href="#1-流的创建" class="headerlink" title="1.流的创建"></a><strong>1.流的创建</strong></h3><p>对于集合，流的创建通常使用 集合.stream() 来创建一个流，如：</p>
<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();
Stream&lt;String&gt; stream = list.stream();</code></pre>
<p>对于数组，通常使用集合的工具类 Arrays.stream() 、将数组转换为集合List 又或是Stream.of(array) 来创建一个流，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">String[] strs &#x3D; new String[10];<br>Stream&lt;String&gt; stream &#x3D; Arrays.stream(strs);<br><br>Stream&lt;String&gt; stream &#x3D; Arrays.asList(strs).stream();<br><br>Stream&lt;String&gt; stream &#x3D; Stream.of(1,2,3,4,6);<br></code></pre></td></tr></table></figure>
<p>将字符串分隔成流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">String newstr &#x3D; &quot;123,456,789&quot;;<br>   Pattern pattern &#x3D; Pattern.compile(&quot;,&quot;);<br>   Stream&lt;String&gt; spiltStream &#x3D; pattern.splitAsStream(newstr);<br>   splitStream.sorted.forEach(v-&gt;System.out.println(v));			&#x2F;&#x2F; 输出：123 456 789 <br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-流的中间操作"><a href="#2-流的中间操作" class="headerlink" title="2.流的中间操作"></a><strong>2.流的中间操作</strong></h3><p>定义一个整形数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Integer[] integers &#x3D; &#123;1,23,4,5,6,7,3,3,23,6,8,93,2,4,5&#125;;<br></code></pre></td></tr></table></figure>
<p>以下流的操作均以此数组为例</p>
<p><strong>forEach循环：</strong></p>
<p>使用forEach()方法可以循环输出流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream.of(integers).forEach(v-&gt;System.out.println(v)); &#x2F;&#x2F; 循环输出整形数组<br></code></pre></td></tr></table></figure>
<p><strong>筛选：</strong></p>
<p>使用Stream流中的filter()方法可以过滤某些元素，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream&lt;Integer&gt; stream1 &#x3D; Stream.of(integers);<br>stream1.filter(v-&gt;v&gt;20).forEach(v-&gt;System.out.println(v));	&#x2F;&#x2F;23,23,93<br></code></pre></td></tr></table></figure>
<p><strong>获取n个元素：</strong></p>
<p>使用limit(n)方法可以获取流中n个元素，顺序为从 0 – n-1，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream.of(integers).limit(5).forEach(v-&gt;System.out.println(v));	&#x2F;&#x2F;1,23,4,5,6<br></code></pre></td></tr></table></figure>
<p><strong>跳过前n个元素</strong></p>
<p>使用skip(n)方法可以跳过流中前n个元素，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream.of(integers).skip(7).forEach(v-&gt;System.out.println(v));	&#x2F;&#x2F;8,93,2,4,5<br></code></pre></td></tr></table></figure>
<p><strong>去除重复元素</strong></p>
<p>使用distinct()方法可以去除流中重复元素（使用hashcode（）和equals（）实现）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream.of(integers).distinct().forEach(v-&gt;System.out.println(v));	&#x2F;&#x2F;1,23,4,5,6,7,3,8,93,2<br></code></pre></td></tr></table></figure>
<p><strong>生成映射</strong></p>
<p>map()方法接受一个lambda表达式，该函数会被应用到每个元素上，并映射成一个新的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream.of(integers).filter(i-&gt;i&gt;20).distinct().map(v-&gt;v*&#x3D;2).forEach(v-&gt;System.out.println(v));		&#x2F;&#x2F;46,186<br></code></pre></td></tr></table></figure>
<p><strong>排序</strong></p>
<p>sorted()方法可以进行默认排序，流中元素需要实s现Comparable接口</p>
<p>sorted(Comparator cmp) 方法中传入一个实现Comparator接口的实现类，可以实现自定义排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream.of(integers).sorted().filter(i-&gt;i&gt;20).forEach(v-&gt;System.out.println(v)) 		&#x2F;&#x2F; 23,23,93<br><br>Stream.of(integers).sorted(<br>		new Comparator&lt;Integer&gt;() &#123;<br>           public int compare(Integer o1, Integer o2) &#123;<br>               return o2-o1;<br>           &#125;<br>       &#125;<br>	).filter(i-&gt;i&gt;20).forEach(v-&gt;System.out.println(v))	&#x2F;&#x2F; 93,23,23<br></code></pre></td></tr></table></figure>

<p><strong>消费方法</strong></p>
<p><del>待续</del></p>
<hr>
<h3 id="3-流的终止操作"><a href="#3-流的终止操作" class="headerlink" title="3.流的终止操作"></a><strong>3.流的终止操作</strong></h3><p><strong>前面说过不要重复使用一个流，因为流的终止操作会将流关闭，关闭流后就不能继续使用这个流，如果继续使用流则会出现异常</strong></p>
<p>流的终止操作有：匹配、聚合、收集</p>
<hr>
<p><strong>匹配</strong></p>
<p>匹配操作是判断元素在流中的存在关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream&lt;Integer&gt; stream &#x3D; Stream.of(integers);<br>boolean bool1 &#x3D; stream.allMatch(v-&gt;v&gt;5);	&#x2F;&#x2F;false<br>boolean bool2 &#x3D; stream.allMatch(v-&gt;v&gt;10);	&#x2F;&#x2F;此时会出现异常，因为执行了流的终止操作。<br><br>boolean allMatch &#x3D; Stream.of(integers).allMatch(v-&gt;v&gt;5);<br>   System.out.println(allMatch);	&#x2F;&#x2F;判断流中所有元素是否符合某种关系<br><br>   boolean nonMatch &#x3D; Stream.of(integers).noneMatch(v-&gt;v&gt;100);<br>   System.out.println(nonMatch);	&#x2F;&#x2F;判断流中所有元素是否不符合某种关系<br><br>   boolean anyMatch &#x3D; Stream.of(integers).anyMatch(v-&gt;v&gt;90);<br>   System.out.println(anyMatch);	&#x2F;&#x2F;判断是否有元素符合<br><br>   int res &#x3D; Stream.of(integers).findFirst().get();<br>   System.out.println(res);		&#x2F;&#x2F;返回流中第一个元素<br><br>   int any &#x3D; Stream.of(integers).findAny().get();<br>   System.out.println(any);		&#x2F;&#x2F;随机返回一个元素<br></code></pre></td></tr></table></figure>

<hr>
<p><strong>聚合</strong></p>
<p>聚合操作有：返回流中元素个数、最大值、最小值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">long count &#x3D; Stream.of(integers).count();	&#x2F;&#x2F;返回long型<br><br>int maxElement &#x3D; Stream.of(integers).max(Integer::compareTo).get();<br><br>int minElement &#x3D; Stream.of(integers).min(Integer::compareTo).get();<br><br></code></pre></td></tr></table></figure>
<hr>
<p><strong>收集</strong></p>
<p>收集操作可以将流中的元素包装成一个最终结果集：List、map、set等，如：</p>
<p>其中 collect 接受一个Collector实例，可将元素收集成另外一个数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Set&lt;Integer&gt; set &#x3D; Stream.of(integers).collect(Collectors.toSet());	&#x2F;&#x2F;[1, 2, 3, 4, 5, 6, 23, 7, 8, 93]<br><br>List&lt;Integer&gt; list &#x3D; Stream.of(integers).collect(Collectors.toList());		&#x2F;&#x2F;[1, 23, 4, 5, 6, 7, 3, 3, 23, 6, 8, 93, 2, 4, 5]<br><br>Map&lt;Integer,Integer&gt; map &#x3D; Stream.of(integers).distinct().filter(v-&gt;v&gt;20).collect(Collectors.toMap(Integer::intValue,Integer::intValue));	&#x2F;&#x2F;&#123;23&#x3D;23, 93&#x3D;93&#125;<br></code></pre></td></tr></table></figure>
<p>收集操作中求最大、最小、求和、平均值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">int max &#x3D; Stream.of(integers).collect(Collectors.maxBy(Integer::compare)).get();<br><br>int min &#x3D; Stream.of(integers).collect(Collectors.minBy(Integer::compare)).get();<br><br>double average &#x3D; Stream.of(integers).collect(Collectors.averagingDouble(Integer::intValue));<br><br>int sum &#x3D; Stream.of(integers).collect(Collectors.summingInt(Integer::intValue));<br></code></pre></td></tr></table></figure>
<p>以下方法可以集以上四种操作于一身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">IntSummaryStatistics sta &#x3D; Stream.of(integers).collect(Collectors.summarizingInt(Integer::intValue));<br>int max &#x3D; sta.getMax();<br>int min &#x3D; sta.getMin();<br>double average &#x3D; sta.getAverage();<br>long count &#x3D; sta.getCount();<br>long sum &#x3D; sta.getSum();<br></code></pre></td></tr></table></figure>


<hr>
<p><strong>分组</strong></p>
<p>分组操作将流中相同元素归为一组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Map&lt;Integer,List&lt;Integer&gt;&gt; map &#x3D; Stream.of(integers).distinct().collect(Collectors.groupingBy(Integer::intValue));		&#x2F;&#x2F;&#123;1&#x3D;[1], 2&#x3D;[2], 3&#x3D;[3], 4&#x3D;[4], 5&#x3D;[5], 6&#x3D;[6], 7&#x3D;[7], 23&#x3D;[23], 8&#x3D;[8], 93&#x3D;[93]&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p><strong>分区</strong></p>
<p>分区操作中，设置条件将流中元素分成两组，满足条件的为true，不满足的为false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Map&lt;Boolean,List&lt;Integer&gt;&gt; newmap &#x3D; Stream.of(integers).distinct().collect(Collectors.partitioningBy(v-&gt;v&gt;20));<br><br>       System.out.println(newmap);<br><br>       System.out.println(newmap.get(true));<br></code></pre></td></tr></table></figure>
<p>使用newmap.get(true)访问满足条件的元素。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>JavaStream流</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown入门</title>
    <url>/2020/09/21/MarkDown/</url>
    <content><![CDATA[<p>MarkDown 是一种轻量级标记语言，它允许我们使用易读易写的纯文本格式编写文档，目前许多网站都在广泛使用MarkDown来撰写文章或是在论坛发表文章，当然个人博客中也支持使用MarkDown来撰写文章，为了更好地搭建个人博客，我们有必要使用MarkDown来帮助我们来编写格式更好的文章。</p>
<hr>
<h3 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a><strong><em>一.标题</em></strong></h3><p>标题使用#号标记</p>
<p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><p><strong>注：#后面要有空格，不然无法正确显示</strong></p>
<hr>
<h3 id="二-段落格式"><a href="#二-段落格式" class="headerlink" title="二.段落格式"></a><strong><em>二.段落格式</em></strong></h3><p>MarkDown可以使用三种字体：斜体、加粗、斜体加粗。</p>
<p>斜体：在文字两端各加一个*</p>
<p><em>这是斜体</em></p>
<p>粗体：在文字两端各加两个*</p>
<p><strong>这是粗体</strong></p>
<p>斜体加粗：在文字两端各加三个***</p>
<p><strong><em>这是斜体加粗</em></strong></p>
<hr>
<p>分割线使用 — 来建立分割线</p>
<hr>
<p>文字两端使用 ～～ 来使文字变成删除格式</p>
<p><del>这是文字的删除格式</del></p>
<p><strong>注：～～必须是英文的～</strong></p>
<hr>
<p>下划线是通过html的 u 标签来实现的，在文字两端加上即可</p>
<p><u>这是下划线</u></p>
<hr>
<h3 id="三-列表"><a href="#三-列表" class="headerlink" title="三.列表"></a><strong><em>三.列表</em></strong></h3><p>列表分为 <u>有序列表</u> 和 <u>无序列表</u></p>
<p><strong>无序列表</strong>使用 *、+、- 作为列表标记</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p><strong>有序列表</strong>使用 1. 2. 3.标记</p>
<p>1.第一项<br>2.第二项<br>3.第三项</p>
<p><strong><em>列表嵌套</em></strong></p>
<p>第二层为第一层换行后加一个tab</p>
<ul>
<li>第一层<ul>
<li>第二层<ul>
<li>第三层 <ul>
<li>第四层</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong><em>区块引用和嵌套</em></strong></p>
<p>区块引用：在段落开头使用 &gt; 符号，后面跟一个空格</p>
<blockquote>
<p>这是区块一</p>
</blockquote>
<blockquote>
<p>这是区块二</p>
</blockquote>
<p>区块嵌套：一个&gt;是最外层，两个是第一层嵌套，以此类推</p>
<blockquote>
<p>父亲</p>
<blockquote>
<p>儿子</p>
<blockquote>
<p>孙子</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong><em>注：区块嵌套中&gt;也要隔一个空格</em></strong></p>
<hr>
<h3 id="四-链接和图片"><a href="#四-链接和图片" class="headerlink" title="四.链接和图片"></a><strong><em>四.链接和图片</em></strong></h3><p>链接使用：<a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p>
<p>如：<a href="https://zleo-bug.github.io/">zleo的博客</a>    </p>
<p>图片使用：图片的使用和链接使用一样</p>
<p>如：<a href="http://static.runoob.com/images/runoob-logo.png">菜鸟教程</a></p>
<p>若使用本地图片，则链接为 在与本md文件同名的文件夹中的图片名称，本文的文件名为MarkDown，则链接为MarkDown图片的名称</p>
<p><img src="/2020/09/21/MarkDown/f4131bc77889e084f2b3648261cc43df.jpg" alt="图片"></p>
<p>MarkDown还不支持指定图片的高度和大小，若有需要可以使用html的img标签</p>
<hr>
<h3 id="五-表格"><a href="#五-表格" class="headerlink" title="五.表格"></a><strong><em>五.表格</em></strong></h3><p>MarkDown中用|分隔不同单元格，用-来分隔表头和其他行</p>
<p>如：</p>
<table>
<thead>
<tr>
<th>表头&emsp;</th>
<th>表头&emsp;</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>内容</td>
<td>内容</td>
</tr>
</tbody></table>
<br>
表格中默认为向左看齐

<p>向右看齐：右边加 :</p>
<p>文字居中：两边加 :</p>
<p><strong><em>注：&amp;emsp; 表示两个空格</em></strong></p>
<hr>
<h3 id="六-代码块"><a href="#六-代码块" class="headerlink" title="六.代码块"></a><strong><em>六.代码块</em></strong></h3><p>如果是段落上的一个函数或者是片段代码可以用反引号包起来</p>
<p>如：<code>printf()</code> 函数</p>
<p>如果是一个代码块，则在代码块前后加反引号即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#include&lt;stdio.h&gt;<br>#include&lt;iostream&gt;<br>using namespace std;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="以上就是MarkDown的基本语法。"><a href="#以上就是MarkDown的基本语法。" class="headerlink" title="以上就是MarkDown的基本语法。"></a>以上就是MarkDown的基本语法。</h3>]]></content>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门学习</title>
    <url>/2020/09/21/Python/</url>
    <content><![CDATA[<p>这学期选修了信息检索（python基础入门），所以有必要将python的基础markdown，便于以后学习。语言都具有相似性，下面列举出python与其他语言不同的地方</p>
<h1 id="一-什么是python："><a href="#一-什么是python：" class="headerlink" title="一.什么是python："></a>一.什么是python：</h1><p>python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</p>
<p>python语言是一种解释性语言：这意味着在代码编写、执行过程中没有了编译这个环节</p>
<h1 id="二-python基础："><a href="#二-python基础：" class="headerlink" title="二.python基础："></a>二.python基础：</h1><h2 id="语句结束符："><a href="#语句结束符：" class="headerlink" title="语句结束符："></a>语句结束符：</h2><p>python中可以不写结束符； 如：print(val)    </p>
<h2 id="变量定义与删除："><a href="#变量定义与删除：" class="headerlink" title="变量定义与删除："></a>变量定义与删除：</h2><p>python中变量类型是弱类型，定义变量时不用声明数据类型，可以用del删除变量</p>
<h2 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h2><h2 id="行与缩进："><a href="#行与缩进：" class="headerlink" title="行与缩进："></a>行与缩进：</h2><p>行与缩进是python语言最具特色的一个地方，python不像其他语言一样使用大括号来包含一个代码块，而是使用：来包含代码块，缩进相同的代码块为同一层次。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if True:<br>		print(&quot;True&quot;);<br>	else:<br>		print(&quot;False&quot;);<br></code></pre></td></tr></table></figure>

<h2 id="多行语句："><a href="#多行语句：" class="headerlink" title="多行语句："></a>多行语句：</h2><p>如果一行代码很长，可以用 \ 来将代码分行<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">total &#x3D; item_one + \<br>      item_two + \<br>      item_three<br></code></pre></td></tr></table></figure>
<h2 id="导入模块："><a href="#导入模块：" class="headerlink" title="导入模块："></a>导入模块：</h2><p>python中导入模块使用 import [somemoudle] 和 from [somemoudle] import [moudle1],[moudle2]…导入模块，使用import可以导入其他python文件，作用类似于java中的包，导入其他文件后会自动运行文件中的代码，解决方法是在主文件中将代码块放入 <strong>name</strong> == <strong>main</strong> </p>
<h2 id="输入与输出："><a href="#输入与输出：" class="headerlink" title="输入与输出："></a>输入与输出：</h2><p>python中用 input(“”)语句输入，输入默认为字符串，若想将输入转换为其他类型的值可用强制转换。如 val = int(input(“enter a val:”))</p>
<p>python中用 print()语句输出，输出默认换行，若想取消换行，可以使用这种形式：print(“”,end=” “) 但end这个语法只有最新版本的python3才支持。</p>
<p>也可以使用str.format()来格式化输出</p>
<p>条件控制：</p>
<p>python中没有switch case表达式，elif代替了else，还添加了for else、while else的表达式</p>
<h2 id="错误和异常："><a href="#错误和异常：" class="headerlink" title="错误和异常："></a>错误和异常：</h2><p>python中使用 try-expect-finally 代替 try-catch-else-finally，其中else是没有异常执行的代码</p>
<p>用raise代替throw抛出异常</p>
<h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><p>python支持多继承</p>
<h2 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h2><p>python中运算符除了 比较运算符、位运算符、赋值运算符 外 其他运算符和其他语言有所不同。</p>
<h3 id="算数运算符："><a href="#算数运算符：" class="headerlink" title="算数运算符："></a>算数运算符：</h3><p>x/y 的运算结果为浮点数 </p>
<p>x//y 的结果为向下取整的整数</p>
<p>x/<em>/</em>(val) 表示x的val次幂</p>
<h3 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h3><p>与运算符为：and</p>
<p>或运算符为：or</p>
<p>非运算符为：not</p>
<h3 id="成员运算符：在python循环中经常被用来判断指定元素是否在某序列中"><a href="#成员运算符：在python循环中经常被用来判断指定元素是否在某序列中" class="headerlink" title="成员运算符：在python循环中经常被用来判断指定元素是否在某序列中"></a>成员运算符：在python循环中经常被用来判断指定元素是否在某序列中</h3><p>in：表示某元素在指定的序列中 </p>
<p>not in：表示某元素不在指定序列中</p>
<h3 id="Python循环："><a href="#Python循环：" class="headerlink" title="Python循环："></a>Python循环：</h3><p>Python循环中通常使用range(i,j)来指定遍历的范围，range为左闭右开原则，如for(i in range(0,5)) 遍历下标为0-4</p>
<h3 id="身份运算符："><a href="#身份运算符：" class="headerlink" title="身份运算符："></a>身份运算符：</h3><p>is 或 id() ：用来表示某变量的地址，通常用来判断序列</p>
<p>== ：用来判断变量值是否相等，通常用来判断变量</p>
<p>类似于在java中，String str1 = “123”;String str2 = “123”; String str3 = new String(“123”);<br>str1 == str2 /true<br>str1 == str3 /false<br>之间的区别</p>
<h2 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h2><p>python中使用type()返回变量的类型，使用isinstance方法来判断变量是否与指定类型相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">a &#x3D; 10;<br>print(type(a))	#	&lt;class &#39;int&#39;&gt;<br>print(isinstance(a,int))	#True<br></code></pre></td></tr></table></figure>
<ul>
<li><h3 id="Number-数字类型-："><a href="#Number-数字类型-：" class="headerlink" title="Number (数字类型)："></a>Number (数字类型)：</h3></li>
</ul>
<p>python中数字类型只有int、bool、float、complex四种</p>
<p>强制转换：int（）、bool（）、float（）、complex（x,y）</p>
<ul>
<li><h3 id="String-字符串-："><a href="#String-字符串-：" class="headerlink" title="String (字符串)："></a>String (字符串)：</h3></li>
</ul>
<p>python中字符串用‘’或“”指定一个字符串，可用下标访问字符串，有正序访问和逆序访问两种方式</p>
<p>字符串运算符：</p>
<ul>
<li>运算符：重复输出<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">str &#x3D; &quot;123&quot;<br>print(str * 3) #123123123<br></code></pre></td></tr></table></figure>
[]运算符：通过索引截取字符串的子串(左闭右开)<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">str &#x3D; &quot;12312312412412&quot;<br>print(str[0:4]);<br></code></pre></td></tr></table></figure>
Python中字符串下标有两种格式，一种是常规的：0…n-1，另一种是从后面索引：-n…-1</li>
</ul>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">	str &#x3D; &quot;123456789&quot;<br>	print(str[0:9])		#123456789<br>	print(str[-9:0]) 	#123456789<br>&#96;&#96;&#96;	<br>in 和 not in 成员运算符：判断字符是否存在字符串中<br></code></pre></td></tr></table></figure>
<pre><code>str = &quot;12312312412412&quot;
print(&#39;0&#39; in str);        #False</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">r&#x2F;R运算符：将字符串中的字符转义，变成普通字符<br></code></pre></td></tr></table></figure>
<pre><code>str = r&quot;12\n312312412412&quot;
print(str)            #12\n312312412412</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">%字符串格式化运算符：<br>&#96;&#96;&#96;	<br>	str &#x3D; &quot;12312312412412&quot;<br>	print(&quot;string is %s&quot; %str)		#string is 12312312412412<br></code></pre></td></tr></table></figure>
<p>f-string 字面量格式化字符串：</p>
<p>f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号{} 包起来，它会将变量或表达式计算后的值替换进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">	name&#x3D;&quot;十二点前要睡觉&quot;<br>	print(f&quot;我&#123;name&#125;&quot;)		#我十二点前要睡觉<br><br>	print(f&quot;&#123;1+2&#125;&quot;) 	# 3<br>&#96;&#96;&#96;	<br>str.format()格式化：<br>&#96;&#96;&#96;	<br>	print(&#39;&#123;0&#125; 和 &#123;1&#125;&#39;.format(&#39;Google&#39;, &#39;Runoob&#39;))	#Google 和 Runoob<br><br>	print(&#39;&#123;name&#125;网址： &#123;site&#125;&#39;.format(name&#x3D;&#39;菜鸟教程&#39;, site&#x3D;&#39;www.runoob.com&#39;))	#菜鸟教程网址： www.runoob.com<br><br>	import math<br>	print(&#39;常量 PI 的值近似为 &#123;0:.3f&#125;。&#39;.format(math.pi))<br><br>	table &#x3D; &#123;&#39;Google&#39;: 1, &#39;Runoob&#39;: 2, &#39;Taobao&#39;: 3&#125;<br>	print(&#39;Runoob: &#123;0[Runoob]&#125;; Google: &#123;0[Google]&#125;; Taobao: &#123;0[Taobao]&#125;&#39;.format(table))<br></code></pre></td></tr></table></figure>
<ul>
<li><h3 id="List-列表-："><a href="#List-列表-：" class="headerlink" title="List (列表)："></a>List (列表)：</h3></li>
</ul>
<p>列表是python中最基本的数据类型，基本和数组相似，不过列表允许存在不同类型的值，列表用[]将元素包装，列表是可变的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">list &#x3D; [1,2,3,4,]<br>list &#x3D; [&quot;abc&quot;,&quot;def&quot;]<br>list &#x3D; [1,2,3,&quot;abc&quot;,&quot;def&quot;]<br></code></pre></td></tr></table></figure>
<p>列表也可以像字符串类型一样从尾部开始遍历，最后一个元素下标为-1<br>列表的截取也是[]运算符，左闭右开原则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">print(list[-1])	# def<br></code></pre></td></tr></table></figure>
<p><strong>列表增加元素：</strong></p>
<p>列表中用append增加元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">list.append(1)<br>print(list)	#	[1, 2, 3, &#39;abc&#39;, &#39;def&#39;, 1]<br></code></pre></td></tr></table></figure>
<p>或者使用+运算符往列表中增加列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">print(list+[1,2,3])		#[2, 3, &#39;abc&#39;, &#39;def&#39;, 1, 2, 3]<br></code></pre></td></tr></table></figure>
<p>也可以使用insert(i,x)往下标i插入元素x</p>
<p><strong>列表删除元素</strong></p>
<p>用del或删除元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">del list[0]<br>print(list)	#	[2, 3, &#39;abc&#39;, &#39;def&#39;, 1]<br></code></pre></td></tr></table></figure>
<p>用pop删除元素，默认删除并最后一个元素，也可以在pop方法中限定下标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">x &#x3D; list.pop()	#def<br>print(x)	#[2, 3, &#39;abc&#39;]<br><br>list.pop(0)<br>print(list)	#[3, &#39;abc&#39;]<br></code></pre></td></tr></table></figure>


<ul>
<li><h3 id="Tuple-元组-："><a href="#Tuple-元组-：" class="headerlink" title="Tuple (元组)："></a>Tuple (元组)：</h3></li>
</ul>
<p>元组与列表类似，元组不可修改，元组用()来声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">tuple &#x3D; (1,2,3,4,5)<br>print(tuple)	#(1, 2, 3, 4, 5)<br></code></pre></td></tr></table></figure>
<p>元组与列表很相似，不过元组中没有append添加元素方法，不过可以用+运算进行组合<br>可以用list(tuple)将元组转换为列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">print(tuple+(9,8,7))	#(1, 2, 3, 4, 5, 9, 8, 7)<br></code></pre></td></tr></table></figure>

<ul>
<li><h3 id="列表推导式："><a href="#列表推导式：" class="headerlink" title="列表推导式："></a>列表推导式：</h3></li>
</ul>
<p>列表推导式很大简便了python的编程，列表推导式有那么一点像Java中的 集合.foreach(lambda) 方法，使用列表推导式可以实现一行代码实现多个操作的功能</p>
<p>生成新的列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vec &#x3D; [1,3,5]<br>print([x*3 for x in vec])	#[3,9,15]<br>print(vec)	#[1,3,5]<br></code></pre></td></tr></table></figure>
<p>使用推导式进行筛选：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">print([x for x in vec if x&gt;&#x3D;3])	#[3,5]<br></code></pre></td></tr></table></figure>
<p>推导式中使用if-else：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">print([x if x%2&#x3D;&#x3D;0 else -x for x in range(1,10)])	#[-1, 2, -3, 4, -5, 6, -7, 8, -9]<br></code></pre></td></tr></table></figure>

<p>生成集合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vec &#x3D; [1,3,5,4,4,4,4,4]<br>print(&#123;x for x in vec&#125;)	#&#123;1, 3, 4, 5&#125;<br></code></pre></td></tr></table></figure>
<p>生成嵌套列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">print([[x,x**2] for x in vec])	#[[1, 1], [3, 9], [5, 25]]<br></code></pre></td></tr></table></figure>
<p>生成字典：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">print(&#123;x:x**2 for x in vec&#125;)    #&#123;1, 3, 4, 5&#125;<br></code></pre></td></tr></table></figure>
<p>推导式也可以进行对列表的反转、正序、逆序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vec &#x3D; [1,3,5,4,4,4,4,4]<br>print([x for x in reversed(vec)])	#[4, 4, 4, 4, 4, 5, 3, 1]<br>print([x for x in sorted(vec)]) #[1, 3, 4, 4, 4, 4, 4, 5]<br>print([x for x in reversed(sorted(vec))]) #[5, 4, 4, 4, 4, 4, 3, 1]<br></code></pre></td></tr></table></figure>



<ul>
<li><h3 id="set-集合-："><a href="#set-集合-：" class="headerlink" title="set (集合)："></a>set (集合)：</h3></li>
</ul>
<p>集合是无序的，集合使用{}或set()函数创建集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">set &#x3D; &#123;1,2,3,4,5,6&#125;<br>print(set)		#&#123;1, 2, 3, 4, 5, 6&#125;<br>print(set(&quot;123321&quot;))	#&#123;&#39;1&#39;, &#39;3&#39;, &#39;2&#39;&#125;<br></code></pre></td></tr></table></figure>
<p>添加元素：</p>
<p>用add方法往集合添加一个元素，也可以用update添加集合、元组、列表等    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">set.add(4)<br>print(set)	#&#123;&#39;3&#39;, &#39;2&#39;, 4, &#39;1&#39;&#125;<br><br>set.update(&#123;5&#125;)	#&#123;&#39;2&#39;, 4, 5, &#39;3&#39;, &#39;1&#39;&#125;<br>print(set)<br></code></pre></td></tr></table></figure>
<p>删除元素：</p>
<p>用remove方法删除元素，但是如果集合中不存在元素会报错</p>
<p>用discard方法删除元素，如果集合不存在元素也不会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">set.discard(5)<br>print(set)		#&#123;4, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;&#125;<br></code></pre></td></tr></table></figure>
<p>集合并交差补运算</p>
<p>set1|set2: 并集<br>set1&amp;set2: 交集<br>set1-set2: 差集<br>set1^set2: 不同时属于set1和set2的</p>
<ul>
<li><h3 id="Dictionary-字典-："><a href="#Dictionary-字典-：" class="headerlink" title="Dictionary (字典)："></a>Dictionary (字典)：</h3></li>
</ul>
<p>python中字典用{}声明，键值对用:分隔，用{}声明空字典，字典值可修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dict &#x3D; &#123;&quot;1&quot;:1,&quot;2&quot;:2&#125;<br>print(dict)	&#123;&#39;1&#39;: 1, &#39;2&#39;: 2&#125;<br>print(dict[&quot;1&quot;])	# 1<br><br>dict[&quot;1&quot;] &#x3D; 100<br>print(dict)	#&#123;&#39;1&#39;: 100, &#39;2&#39;: 2&#125;<br></code></pre></td></tr></table></figure>
<p>字典中用update增加一个键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dict.update(&#123;&quot;3&quot;:3&#125;)<br>print(dict)<br></code></pre></td></tr></table></figure>
<p>pop(key)删除键为key的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">val &#x3D; dict.pop(&quot;1&quot;)<br>print(val)	#100<br></code></pre></td></tr></table></figure>
<p>用popitem删除并返回最后一个键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">d &#x3D; dict.popitem();<br>print(d)	#(&#39;3&#39;, 3)<br></code></pre></td></tr></table></figure>
<h2 id="python函数"><a href="#python函数" class="headerlink" title="python函数"></a>python函数</h2><p>python中用def定义一个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">def Method():<br>   print(&quot;难顶&quot;)<br>Method()	#难顶<br></code></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<p>函数参数中值得注意的是 <strong>关键字参数</strong> 、<strong>默认参数</strong> 、<strong>不定长参数</strong>、<strong>匿名函数</strong></p>
<p><strong>关键字参数</strong><br>函数调用可以使用关键字参数来确定传入的参数值，使用关键字参数时允许参数顺序的不一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">def Method(name, age):<br>   print(name, age)<br><br>Method(age&#x3D;21, name&#x3D;&quot;zl&quot;)		#zl 21<br></code></pre></td></tr></table></figure>
<p><strong>默认参数</strong><br>函数中可以对参数设置默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">def Method(name,age,address&#x3D;&quot;guangdong&quot;):<br>   print(name, age,address)	#zl 21 guangdong<br>Method(age&#x3D;21, name&#x3D;&quot;zl&quot;)<br></code></pre></td></tr></table></figure>
<p><strong>不定长参数</strong><br>不定长参数中，用*导入一个元组，**导入一个字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">def Method(*tuple):<br>   print(tuple)<br>Method(1,2,3,4,5,6,7)	#(1, 2, 3, 4, 5, 6, 7)<br><br>def Method(**dict):<br>   print(dict)<br>Method(a&#x3D;1,b&#x3D;2,c&#x3D;3,d&#x3D;4);	#&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;<br></code></pre></td></tr></table></figure>
<p>不定长参数后的参数要以关键字参数的形式传入</p>
<p><strong>匿名函数</strong><br>匿名函数中用lambda表达式创建一个匿名函数，表达式中会提供返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Method &#x3D; lambda val1&#x3D;1,val2&#x3D;2:val1+val2<br>print(Method())<br></code></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>python类中不用像c++、java中声明属性，可以直接在构造方法def <strong>init</strong>(self)使用，属性或方法前加__代表私有，另外，在类中的任何方法都要在参数列表第一个加上self，类似c++、java的this关键字，在方法中调用属性时要使用self.的方式，而且新建对象不用使用new关键字，Aclass=Myclass()即可，继承则使用Aclass(Bclass)声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">class person:<br>    name &#x3D; &quot; &quot;<br>    age &#x3D; 0<br>    sex &#x3D; &quot; &quot;<br><br>   def __init__(self, name, age, sex):<br>       self.name &#x3D; name<br>       self.age &#x3D; age<br>       self.sex &#x3D; sex<br><br>   def show(self):<br>       return (&quot;&#123;0&#125; is a &#123;1&#125; years old &#123;2&#125;&quot;.format(self.name, self.age, self.sex))<br><br>class student(person):<br>   grade &#x3D; &quot; &quot;<br><br>   def __init__(self, name, age, sex, grade):<br>       person.__init__(self, name, age, sex)<br>       self.grade &#x3D; grade<br><br>   def show(self):<br>       return person.show(self) + &quot; 大学 &#123;&#125; 年级&quot;.format(self.grade)<br><br>   def print(self):<br>       print(person.show(self))<br>       print(super().show())<br><br><br>class graduate(student, person):<br>   	salary &#x3D; 0<br><br>   def __init__(self, name, age, sex, grade, salary):<br>       student.__init__(self, name, age, sex, grade)<br>       self.salary &#x3D; salary<br></code></pre></td></tr></table></figure>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul>
<li>内置命名</li>
<li>全局命名</li>
<li>局部命名</li>
</ul>
<p>若要在方法或类中使用全局变量，使用global关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">count &#x3D; 1<br>def change():<br>    global count<br>    print(count)<br>    count &#x3D; 100<br><br>change()<br>print(count)	#100<br></code></pre></td></tr></table></figure>
<p>若要在嵌套方法中使用外层方法的局部变量，使用nonlocal关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">def outer():<br>    num &#x3D; 10<br>    def inner():<br>        nonlocal num<br>        print(num)	#10<br>        num &#x3D; &quot;str&quot;<br>    inner()<br>    print(num)	#str<br>outer()<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript入门</title>
    <url>/2020/09/16/js/</url>
    <content><![CDATA[<p>JavaScript（js）是目前web开发中不可缺少的脚本语言，js不需要编译即可运行，运行在客户端，需要通过浏览器来解析执行JavaScript代码。</p>
<p>js文档工具：<a href="https://jquery.cuishifeng.cn/index.html">https://jquery.cuishifeng.cn/index.html</a></p>
<p>js是一门很随意的语言</p>
<p>下面介绍js的基本语法</p>
<h1 id="引入javascript"><a href="#引入javascript" class="headerlink" title="引入javascript"></a><strong>引入javascript</strong></h1><ol>
<li>内部标签</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;script&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>外部引入</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;script src&#x3D;&quot;xxx.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<p>js标签可以放在 head部分 或者 body部分 </p>
<h1 id="js输出"><a href="#js输出" class="headerlink" title="js输出"></a><strong>js输出</strong></h1><ul>
<li><p>使用 window.alert() 弹出警告框。</p>
</li>
<li><p>使用 document.write() 方法将内容写到 HTML 文档中。</p>
</li>
<li><p>使用 innerHTML 写入到 HTML 元素。</p>
</li>
<li><p>使用 console.log() 写入到浏览器的控制台。</p>
</li>
</ul>
<h1 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a><strong>js基本语法</strong></h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h2><p>在了解基本数据类型之前，有必要了解一下js的严格检查模式</p>
<p>严格检查模式用来预防js的随意性导致产生的一些问题，使用了严格检查模式，就不能不通过var 声明变量了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">’use strict&#39;<br></code></pre></td></tr></table></figure>

<hr>
<p>在js中，基本数据类型用 var 进行定义，js拥有动态类型，这意味着相同的变量可用作不同的类型：</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">var x;     <br>var x &#x3D; 1000;        <br>var x &#x3D; &quot;abc&quot;;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>Number</li>
</ul>
<p>Number类型可以是整数、小数或者是科学计数</p>
<ul>
<li>String</li>
</ul>
<p>单引号或者双引号包围字符</p>
<ul>
<li>布尔值</li>
</ul>
<p>true or false</p>
<ul>
<li>数组</li>
</ul>
<p>定义数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">var arr &#x3D; new Array();<br><br>var arr &#x3D; [&quot;123&quot;,&quot;456&quot;,789]<br></code></pre></td></tr></table></figure>
<p>js的数组可以包含不同的数据类型</p>
<ul>
<li>Undefined 和 Null</li>
</ul>
<p>Undefined表示未定义</p>
<p>Null表示值为空</p>
<ul>
<li>NaN</li>
</ul>
<p>表示变量不是数字类型</p>
<ul>
<li>JavaScript对象</li>
</ul>
<p>在js中，js的对象为一个键值对的集合，所有的键都为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">var person &#x3D; &#123;<br>	name:&quot;zl&quot;,<br>	age:21,<br>	sex:&quot;boy&quot;,<br>	getprofession:function(profession)&#123;<br>		document.write(profession + &quot;&lt;br &#x2F;&gt;&quot;)<br>	&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>js的对象可以进行对属性的动态添加和删除，可以用xx in xx的方法判断某属性是否在对象中</p>
<p>在js的对象中，this关键字默认指向调用它的那个对象</p>
<h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a><strong>JavaScript函数</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>function functionName()&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>var functionName &#x3D; function()&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>两种方式等效</p>
<p>其中，在函数的参数中，有一个关键词 arguments ，表示传入函数的参数的集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>for(var i&#x3D;0;i&lt;arguments.length;i++)&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>另外，在参数中，可以使用 …rest 来获取除了已声明的参数之外的所有参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">function exp(a,b,c,...rest)<br></code></pre></td></tr></table></figure>


<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><strong>变量作用域</strong></h2><ul>
<li>全局变量</li>
</ul>
<p>其中，window.xxx 会自动绑定 全局变量</p>
<ul>
<li>局部变量</li>
</ul>
<p>let关键字：</p>
<p>let关键字的作用是解决局部作用域的冲突问题</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">for(var i&#x3D;0;i&lt;100;i++)&#123;<br>&#125;<br>console.log(i+1)<br></code></pre></td></tr></table></figure>
<p>此时输出101</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">for(let i&#x3D;0;i&lt;100;i++)&#123;<br>&#125;<br>console.log(i+1)<br></code></pre></td></tr></table></figure>
<p>此时不能输出</p>
<ul>
<li>块级作用域</li>
</ul>
<h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a><strong>JavaScript事件</strong></h2><h1 id="json"><a href="#json" class="headerlink" title="json"></a><strong>json</strong></h1><p>json是一种轻量级的数据交换格式</p>
<p>在js中，任何js支持的类型都可以用json来表示</p>
<p>格式：</p>
<ul>
<li><p>对象用{}</p>
</li>
<li><p>数组用[]</p>
</li>
<li><p>键值对用key：value</p>
</li>
</ul>
<h2 id="对象与字符串的相互转换"><a href="#对象与字符串的相互转换" class="headerlink" title="对象与字符串的相互转换"></a><strong>对象与字符串的相互转换</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">var person &#x3D; &#123;<br>	name:&quot;zl&quot;,<br>	age:21,<br>	sex:&quot;boy&quot;,<br>	getprofession:function(profession)&#123;<br>		document.write(profession + &quot;&lt;br &#x2F;&gt;&quot;)<br>	&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>对象转换为字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">JSON.stringify()<br></code></pre></td></tr></table></figure>

<ul>
<li>字符串转换为对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">JSON.parse(object)<br></code></pre></td></tr></table></figure>

<h1 id="操作Bom元素"><a href="#操作Bom元素" class="headerlink" title="操作Bom元素"></a><strong>操作Bom元素</strong></h1><p>Bom：浏览器对象模型</p>
<p>可以通过操作Bom来获取浏览器的一些重要信息</p>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a><strong>window</strong></h2><p>window代表当前浏览器窗口</p>
<p>可以通过window对象，获取浏览器的一些重要信息</p>
<p><img src="/2020/09/16/js/window.jpg" alt="window"></p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a><strong>location</strong></h2><p>location代表当前页面的url信息</p>
<p><img src="/2020/09/16/js/location.jpg" alt="location"></p>
<h2 id="document"><a href="#document" class="headerlink" title="document"></a><strong>document</strong></h2><p>document代表当前页面的文档信息(html 文档数)</p>
<p><img src="/2020/09/16/js/document.jpg" alt="document"></p>
<p><img src="/2020/09/16/js/documentcookie.jpg" alt="documentcookie"></p>
<h1 id="操作Dom元素"><a href="#操作Dom元素" class="headerlink" title="操作Dom元素"></a><strong>操作Dom元素</strong></h1><p>DOM：文档对象模型</p>
<p>整个浏览器网页就是一个DOM树形节点，通过操作DOM元素，可以对浏览器的DOM进行增删查改操作</p>
<p><img src="/2020/09/16/js/domtree.jpg" alt="domtree"></p>
<p>其中每个节点都表示一个dom节点</p>
<p>在js中，document对象表示一个文档树</p>
<h2 id="获得dom节点"><a href="#获得dom节点" class="headerlink" title="获得dom节点"></a><strong>获得dom节点</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;&#123;CHARSET&#125;&quot;&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		&lt;h1&gt;h1&lt;&#x2F;h1&gt;<br>		&lt;p id&#x3D;&quot;p1&quot;&gt;p1&lt;&#x2F;p&gt;<br>		&lt;p id&#x3D;&quot;p2&quot;&gt;p2&lt;&#x2F;p&gt;<br>		&lt;p class&#x3D;&quot;p3&quot;&gt;p3&lt;&#x2F;p&gt;<br>		&lt;script&gt;<br>			document.getElementsByTagName(&quot;h1&quot;)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">document.getElementsByTagName(&quot;h1&quot;)<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">document.getElementById(&quot;p1&quot;)<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">document.getElementsByClassName(&quot;p3&quot;)<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;&#123;CHARSET&#125;&quot;&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		&lt;h1&gt;h1&lt;&#x2F;h1&gt;<br>		&lt;form&gt;<br>			&lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;input&quot;&#x2F;&gt;<br>		&lt;&#x2F;form&gt;<br>		&lt;script&gt;<br>			var val &#x3D; document.getElementById(&quot;input&quot;).value;<br>			document.write(val)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<h2 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a><strong>更新节点</strong></h2><p>修改文本值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">document.getElementById(&quot;p1&quot;).innerText &#x3D; &quot;123&quot;<br></code></pre></td></tr></table></figure>

<p>解析html文本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">document.getElementById(&quot;p1&quot;).innerHTML &#x3D; &quot;&lt;strong&gt;123&lt;&#x2F;strong&gt;&quot;<br></code></pre></td></tr></table></figure>

<p>也可以操作css样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">document.getElementById(&quot;p1&quot;).style.color &#x3D; &quot;red&quot;<br></code></pre></td></tr></table></figure>

<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><strong>删除节点</strong></h2><p>步骤：先获取父节点，再删除节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;&#123;CHARSET&#125;&quot;&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		&lt;div id&#x3D;&quot;div1&quot;&gt;<br>			&lt;p id&#x3D;&quot;p1&quot;&gt;&lt;&#x2F;p&gt;<br>			&lt;p id&#x3D;&quot;p2&quot;&gt;&lt;&#x2F;p&gt;<br>		&lt;&#x2F;div&gt;<br>		&lt;script&gt;<br>			var div &#x3D; document.getElementById(&quot;div1&quot;);<br>			var p &#x3D; document.getElementById(&quot;p1&quot;);<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">div.removeChild(p1)<br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">var self &#x3D; document.getElementById(&quot;p1&quot;);<br>var father &#x3D; p1.parentElement;<br>father.removeChild(p1);<br><br></code></pre></td></tr></table></figure>

<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a><strong>插入节点</strong></h2><p>在获取某个dom节点时，假如节点是空的，就可以通过innerHTML增加一个节点，否则则会产生覆盖</p>
<p>通常采用追加append操作进行插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;&#123;CHARSET&#125;&quot;&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		&lt;p id&#x3D;&quot;js&quot;&gt;javascript&lt;&#x2F;p&gt;<br>		&lt;div id&#x3D;&quot;div1&quot;&gt;<br>			&lt;p id&#x3D;&quot;se&quot;&gt;javase&lt;&#x2F;p&gt;<br>			&lt;p id&#x3D;&quot;ee&quot;&gt;javaee&lt;&#x2F;p&gt;<br>			&lt;p id&#x3D;&quot;me&quot;&gt;javame&lt;&#x2F;p&gt;<br>		&lt;&#x2F;div&gt;<br>		&lt;script&gt;<br>			var p &#x3D; document.getElementById(&quot;js&quot;);<br>			var div &#x3D; document.getElementById(&quot;div1&quot;);	<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">div.appendChild(js);<br><br></code></pre></td></tr></table></figure>

<p>创建新节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">var newp &#x3D; document.createElement(&quot;p&quot;);<br>newp.id &#x3D; &quot;hh&quot;;<br>newp.innerText &#x3D; &quot;hh&quot;;<br>div.appendChild(newp);<br></code></pre></td></tr></table></figure>

<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a><strong>JQuery</strong></h1><p>JQuery是js的一个库，里面存在大量的js函数</p>
<p>使用jQuery前，要引入JQuery的cdn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;1.10.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<h2 id="jquery的使用"><a href="#jquery的使用" class="headerlink" title="jquery的使用"></a><strong>jquery的使用</strong></h2><p>jquery的使用非常简单，只要使用<code>$(&quot;#id).action()</code>公式就行，不用再使用document</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;1.10.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		&lt;button id&#x3D;&quot;button&quot;&gt;点我&lt;&#x2F;button&gt;<br>		&lt;script&gt;<br>			$(&quot;#button&quot;).click(<br>				function()&#123;<br>					alert(&quot;hello&quot;);<br>				&#125;<br>			)<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<h2 id="jquery操作dom元素"><a href="#jquery操作dom元素" class="headerlink" title="jquery操作dom元素"></a><strong>jquery操作dom元素</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;1.10.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		&lt;ul id&#x3D;&quot;ul&quot;&gt;<br>			&lt;li name&#x3D;&quot;java&quot;&gt;java&lt;&#x2F;li&gt;<br>			&lt;li name&#x3D;&quot;js&quot;&gt;js&lt;&#x2F;li&gt;<br>		&lt;&#x2F;ul&gt;<br>		&lt;script&gt;<br>			var val &#x3D; $(&quot;#ul li[name&#x3D;java]&quot;).text();<br>			document.write(val)<br>			$(&quot;#ul li[name&#x3D;js]&quot;).text(&quot;123&quot;);<br>		&lt;&#x2F;script&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<p>显示和隐藏dom元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$(&quot;#ul li[name&#x3D;js]&quot;).hide();<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$(&quot;#ul li[name&#x3D;js]&quot;).show();<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>html常用标签</title>
    <url>/2020/09/15/htmllabel/</url>
    <content><![CDATA[<h2 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a><strong>结构标签</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>	&lt;head&gt;<br>		&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;<br>		&lt;title&gt;&lt;&#x2F;title&gt;<br>	&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br><br></code></pre></td></tr></table></figure>

<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;h1&gt;&lt;&#x2F;h1&gt;<br>...<br>&lt;h6&gt;&lt;&#x2F;h6&gt;<br></code></pre></td></tr></table></figure>


<h2 id="容器标签"><a href="#容器标签" class="headerlink" title="容器标签"></a><strong>容器标签</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;div&gt;&lt;&#x2F;div&gt;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;span&gt;&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure>

<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a><strong>列表标签</strong></h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a><strong>有序列表</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;ul&gt;<br>	&lt;li&gt;...&lt;&#x2F;li&gt;<br>	...<br>	&lt;li&gt;...&lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure>

<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a><strong>无序列表</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;ol type&#x3D;&quot;&quot;&gt;<br>	&lt;li&gt;...&lt;&#x2F;li&gt;<br>	...<br>	&lt;li&gt;...&lt;&#x2F;li&gt;<br>&lt;&#x2F;ol&gt;<br></code></pre></td></tr></table></figure>

<h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a><strong>自定义列表</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dl&gt;<br>	&lt;dt&gt;1&lt;&#x2F;dt&gt;<br>	&lt;dd&gt;1.1&lt;&#x2F;dd&gt;<br>	&lt;dt&gt;2&lt;&#x2F;dt&gt;<br>	&lt;dd&gt;2.1&lt;&#x2F;dd&gt;<br>&lt;&#x2F;dl&gt;<br></code></pre></td></tr></table></figure>

<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a><strong>图片标签</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;img properties&#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p>常用属性：</p>
<p>src：图片地址</p>
<p>width:宽度</p>
<p>height:高度</p>
<p>border:边框</p>
<p>align:对齐方式，代表图片与相邻的文本的相当位置（有三个属性值：top middle bottom）</p>
<p>alt:图片的文字说明</p>
<h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a><strong>链接标签</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;a href&#x3D;&quot;&quot;&gt; &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure>

<h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a><strong>表格标签</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;table&gt;<br>	<br>	&lt;tr&gt;<br>		&lt;th&gt;&lt;&#x2F;th&gt;		&#x2F;&#x2F;表头<br>		&lt;th&gt;&lt;&#x2F;th&gt;<br>	&lt;tr&gt;<br>		&lt;td&gt;&lt;&#x2F;td&gt;<br>		...<br>		&lt;td&gt;&lt;&#x2F;td&gt;<br>	&lt;&#x2F;tr&gt;<br><br>	...<br><br>&lt;&#x2F;table&gt;<br><br></code></pre></td></tr></table></figure>

<p>分列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;td colspan&#x3D;&quot;&quot;&gt;&lt;&#x2F;td&gt;<br><br></code></pre></td></tr></table></figure>

<p>分行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;th rowspan&#x3D;&quot;&quot;&gt;&lt;&#x2F;th&gt;<br></code></pre></td></tr></table></figure>

<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a><strong>表单</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;form properties&#x3D;&quot;&quot;&gt;<br><br>&lt;&#x2F;form&gt;<br><br></code></pre></td></tr></table></figure>

<p>常用属性：</p>
<p>action：表示动作，把表单的数据提交到该地址上处理</p>
<p>method:请求方式：get、post</p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a><strong>input</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;input type&#x3D;&quot;&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; value&#x3D;&quot;&quot; &#x2F;&gt;<br><br></code></pre></td></tr></table></figure>

<p>name属性：表单元素名字，只有name属性才能提交给服务器。</p>
<p>常用的type：</p>
<p>text 文本框</p>
<p>password  密码框 </p>
<p>radio 表示是单选，name必须一致；value：提交给服务器的数据</p>
<p>checkbox  表示多选 ，name必须一致</p>
<p>file ：表示上传控件</p>
<p>以上具有输入性质的必须要有name属性,一开始写value表示是默认值(以后获取输入框的内容要根据name来取)<br>以下按钮不具有输入性质，不需要name属性，但是按钮上的文字提示使用value属性</p>
<p>submit   提交</p>
<p>reset   重置</p>
<p>button 普通按钮</p>
<p>hidden  表示隐藏域，该框的内容服务器需要，但是不想让用户知道(不想清楚的显示在界面上)</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select name&#x3D;&quot;&quot;&gt;<br>	&lt;optgroup label&#x3D;&quot;&quot;&gt;<br>		&lt;option value&#x3D;&quot;&quot;&gt;&lt;&#x2F;option&gt;<br>		&lt;option value&#x3D;&quot;&quot;selected&#x3D;&quot;selected&quot;&gt;&lt;&#x2F;option&gt;<br>		....<br>	&lt;&#x2F;optgroup&gt;<br>	...<br><br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a><strong>textarea</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;textarea cols&#x3D;&quot;100&quot; rows&#x3D;&quot;5&quot;&gt;  表示5行100列的区域可以输入内容<br></code></pre></td></tr></table></figure>

<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a><strong>特殊字符</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt; 小于号  <br>&gt; 大于号<br>&amp; 与字符<br>&quot; 引号 <br>&amp;reg; 己注册<br>&amp;copy; 版权<br>&amp;trade; 商标<br>&amp;nbsp; 空格   <br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>html</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>java网络编程基础</title>
    <url>/2020/09/13/internetprogram/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><strong>计算机网络</strong></h1><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<h1 id="实现网络通信的要素"><a href="#实现网络通信的要素" class="headerlink" title="实现网络通信的要素"></a><strong>实现网络通信的要素</strong></h1><h2 id="通信双方地址"><a href="#通信双方地址" class="headerlink" title="通信双方地址"></a><strong>通信双方地址</strong></h2><h3 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a><strong>ip地址</strong></h3><p>ip：唯一定义一台网络上的计算机</p>
<p>如：127.0.0.1表示 本机 localhost</p>
<p>ip地址的分类：</p>
<ul>
<li><p>ipv4/ipv6：</p>
<ul>
<li><p>ipv4：4个字节组成</p>
</li>
<li><p>ipv6：8个无符号整数表示 </p>
</li>
</ul>
</li>
<li><p>公网/私网</p>
<ul>
<li><p>公网：互联网</p>
</li>
<li><p>私网：局域网 192.168.xx.xx</p>
</li>
</ul>
</li>
<li><p>域名</p>
</li>
</ul>
<p>在java中，InetAddress是一个表示ip的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">try &#123;<br>&#x2F;&#x2F;            获取本机ip地址<br>    InetAddress inetAddress1 &#x3D; InetAddress.getByName(&quot;127.0.0.1&quot;);<br>    InetAddress inetAddress2 &#x3D; InetAddress.getByName(&quot;localhost&quot;);<br>    InetAddress inetAddress3 &#x3D; InetAddress.getLocalHost();<br><br>    System.out.println(inetAddress1);<br>    System.out.println(inetAddress2);<br>    System.out.println(inetAddress3);<br><br>&#125; catch (UnknownHostException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a><strong>端口</strong></h3><p>端口表示计算机上的一个程序的进程，不同的进程有不同的端口号，端口被规定0～65535，同一个协议下端口不能相同</p>
<p>端口分类：</p>
<ul>
<li><p>公有端口 0～1023</p>
<ul>
<li><p>http：80</p>
</li>
<li><p>https：443</p>
</li>
<li><p>ftp：21</p>
</li>
<li><p>telent：23</p>
</li>
</ul>
</li>
<li><p>程序注册端口：1024-49151，分配用户或程序</p>
<ul>
<li><p>tomcat：8080</p>
</li>
<li><p>mysql：3306</p>
</li>
<li><p>oracle：1521</p>
</li>
</ul>
</li>
<li><p>动态/私有端口：49152～65535</p>
</li>
</ul>
<p>win下查看所有端口<code>netstat -ano</code> </p>
<p>查看指定端口：<code>netstat -ano|findstr &quot;端口号&quot;</code></p>
<p>查看指定进程：<code>tasklist | findstr &quot;端口号&quot;</code></p>
<p>mac下查看所有端口</p>
<p><img src="/2020/09/13/internetprogram/macport.jpg" alt="macport"></p>
<p>查看指定端口<code>lsof -i tcp:端口号</code></p>
<p>杀死端口<code>kill java后的那串端口号</code></p>
<p>在java中，InetSocketAddress对象表示一个套接字（ip+端口）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">InetAddress inetAddress1 &#x3D; InetAddress.getByName(&quot;127.0.0.1&quot;);<br>InetSocketAddress inetSocketAddress &#x3D; new InetSocketAddress(inetAddress1,4000);<br>System.out.println(inetSocketAddress);<br>System.out.println(inetSocketAddress);<br>System.out.println(inetSocketAddress.getAddress());<br>System.out.println(inetSocketAddress.getHostName());<br>System.out.println(inetSocketAddress.getPort());<br></code></pre></td></tr></table></figure>

<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a><strong>通信协议</strong></h2><p><img src="/2020/09/13/internetprogram/depth.png" alt="depth"></p>
<p>在网络编程中，主要是针对传输层中的TCP/UDP进行编程</p>
<p>通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。</p>
<p>TCP：用户传输协议</p>
<p>通信前需要进行连接（三次握手，四次挥手），连接稳定，用于客户端和服务端间的连接</p>
<p>UDP：用户数据报协议</p>
<p>通信前不需要连接，连接不稳定，不需明确通讯双方</p>
<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a><strong>socket</strong></h1><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。在网络编程中，都是通过socket这一核心来进行网络的通信</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h1><h2 id="TCP实现通信"><a href="#TCP实现通信" class="headerlink" title="TCP实现通信"></a><strong>TCP实现通信</strong></h2><p>使用TCP模拟客户端与服务端的通信，核心是通过serverSocket和socket进行连接</p>
<p>serverSocket建立端口服务，通过socket进行通讯</p>
<p>服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">try &#123;<br>    while(true)&#123;<br>&#x2F;&#x2F;                提供进程（端口）服务<br>        ServerSocket serverSocket &#x3D; new ServerSocket(9999);<br>&#x2F;&#x2F;                接受客户端消息<br>        Socket socket &#x3D; serverSocket.accept();<br>        InputStream is &#x3D; socket.getInputStream();<br>&#x2F;&#x2F;                流接口<br>        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();<br>        byte[] buffer &#x3D; new byte[1024];<br>        int len;<br>        while((len&#x3D;is.read(buffer))!&#x3D;-1)&#123;<br>            baos.write(buffer,0,len);<br>        &#125;<br>        System.out.println(baos.toString());<br>        baos.close();<br>        is.close();<br>        socket.close();<br>        serverSocket.close();<br>    &#125;<br><br>&#125; catch (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">try &#123;<br>&#x2F;&#x2F;            获取主机地址<br>    InetAddress inetAddress &#x3D; InetAddress.getByName(&quot;127.0.0.1&quot;);<br>&#x2F;&#x2F;            端口号<br>    int port &#x3D; 9999;<br>&#x2F;&#x2F;            通信机制<br>    Socket socket &#x3D; new Socket(inetAddress,port);<br>&#x2F;&#x2F;            发送消息<br>    OutputStream os &#x3D; socket.getOutputStream();<br>    os.write(&quot;测试测试123&quot;.getBytes());<br>    os.close();<br>    socket.close();<br><br>&#125; catch (UnknownHostException e) &#123;<br>    e.printStackTrace();<br>&#125; catch (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h1><p>在UDP中，双方进行通信的核心是DatagramSocket和DatagramPacket</p>
<p>其中DatagramPacket中封装了消息、ip和端口号</p>
<p>客户端服务端通过DatagramSocket发送和接受DatagramPacket对象</p>
<h2 id="UDP实现通信"><a href="#UDP实现通信" class="headerlink" title="UDP实现通信"></a><strong>UDP实现通信</strong></h2><p>服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">try &#123;<br>    DatagramSocket socket &#x3D; new DatagramSocket(9999);<br>    byte[] buffer &#x3D; new byte[1024];<br>    DatagramPacket packet &#x3D; new DatagramPacket(buffer,0,buffer.length);<br>    socket.receive(packet);<br><br>    System.out.println(packet.getAddress());<br>    System.out.println(new String(packet.getData()));<br><br>    socket.close();<br><br>&#125; catch (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">try &#123;<br><br>    DatagramSocket socket &#x3D; new DatagramSocket();<br>    InetAddress inetAddress &#x3D; InetAddress.getByName(&quot;127.0.0.1&quot;);<br>    int port &#x3D; 9999;<br>    String msg &#x3D; &quot;hello!&quot;;<br>    DatagramPacket packet &#x3D; new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,inetAddress,port);<br>    socket.send(packet);<br><br>    socket.close();<br><br>&#125; catch (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="聊天功能实现"><a href="#聊天功能实现" class="headerlink" title="聊天功能实现"></a><strong>聊天功能实现</strong></h2><p>在聊天功能中，需要用线程实现，因为每个参与聊天的人都有 发送、接受 两个线程</p>
<p>sender：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class sender implements Runnable &#123;<br><br>    private int fromPort;<br><br>    private String local;<br><br>    private int toPort;<br><br>    private DatagramSocket socket &#x3D; null;<br><br>    private DatagramPacket packet &#x3D; null;<br><br>    public sender(int fromPort, String local, int toPort) &#123;<br>        this.fromPort &#x3D; fromPort;<br>        this.local &#x3D; local;<br>        this.toPort &#x3D; toPort;<br><br>        try &#123;<br><br>            socket &#x3D; new DatagramSocket(fromPort);<br><br>        &#125; catch (SocketException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    @Override<br>    public void run() &#123;<br><br>        BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in));<br><br>        while(true)&#123;<br><br>            try &#123;<br><br>                String msg &#x3D; reader.readLine();<br><br>                packet &#x3D; new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,new InetSocketAddress(local,toPort));<br><br>                socket.send(packet);<br><br>                if(msg.equals(&quot;bye&quot;))&#123;<br>                    break;<br>                &#125;<br><br><br>            &#125; catch (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br><br>        try &#123;<br><br>            reader.close();<br>            socket.close();<br><br>        &#125; catch (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>receiver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class receiver implements Runnable&#123;<br><br><br>    private int fromPort;<br><br>    private DatagramSocket socket &#x3D; null;<br><br>    public receiver(int fromPort) &#123;<br>        this.fromPort &#x3D; fromPort;<br><br>        try &#123;<br><br>            socket &#x3D; new DatagramSocket(fromPort);<br><br>        &#125; catch (SocketException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    @Override<br>    public void run() &#123;<br><br><br>        while(true)&#123;<br><br>            byte[] bytes &#x3D; new byte[1024];<br><br>            DatagramPacket packet &#x3D; new DatagramPacket(bytes,0,bytes.length);<br><br>            try &#123;<br><br>                socket.receive(packet);<br><br>                byte[] receiveData &#x3D; packet.getData();<br><br>                String receiveMsg &#x3D; new String(receiveData,0,receiveData.length);<br><br>                System.out.println(receiveMsg);<br>                if(receiveMsg.contains(&quot;bye&quot;))  break;<br><br>            &#125; catch (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br><br>        &#125;<br><br>        socket.close();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>聊天参与者person1、person2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class person1 &#123;<br>    public static void main(String[] args) &#123;<br>        new Thread(new sender(8888,&quot;localhost&quot;,7777)).start();<br>        new Thread(new receiver(9999)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class person2 &#123;<br>    public static void main(String[] args) &#123;<br>        new Thread(new sender(5555,&quot;localhost&quot;,9999)).start();<br>        new Thread(new receiver(7777)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java之I/O流</title>
    <url>/2020/09/10/IOstream/</url>
    <content><![CDATA[<h1 id="流的概念和作用"><a href="#流的概念和作用" class="headerlink" title="流的概念和作用"></a><strong>流的概念和作用</strong></h1><p>流代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象，通过流为数据源和目的地建立一个输送通道</p>
<h1 id="I-O流的分类"><a href="#I-O流的分类" class="headerlink" title="I/O流的分类"></a><strong>I/O流的分类</strong></h1><ul>
<li><p>按数据流的方向分为</p>
<ul>
<li><p>输入流：指由程序外输入到程序中</p>
</li>
<li><p>输出流：指由程序输出到程序外</p>
</li>
</ul>
</li>
<li><p>按处理数据的单位分为</p>
<ul>
<li><p>字符流</p>
</li>
<li><p>字节流</p>
</li>
</ul>
</li>
<li><p>按功能不同分为</p>
<ul>
<li><p>节点流</p>
</li>
<li><p>处理流</p>
</li>
</ul>
</li>
</ul>
<h1 id="常用的I-O流"><a href="#常用的I-O流" class="headerlink" title="常用的I/O流"></a><strong>常用的I/O流</strong></h1><p>四个基本抽象类：</p>
<p>输入流：InputStream（字节流）、Reader（字符流）</p>
<p>输出流：OutputStream（字节流）、Writer（字符流）</p>
<p>InputStream的继承关系如下：</p>
<p><img src="/2020/09/10/IOstream/inputstream.jpg" alt="inputstream"></p>
<p>其中最常用的是FileInputStream</p>
<p>OutputStream的继承关系如下：</p>
<p><img src="/2020/09/10/IOstream/outputstream.jpg" alt="outputstream"></p>
<p>其中最常用的是FileOutputStream</p>
<p>Reader的继承关系：</p>
<p><img src="/2020/09/10/IOstream/reader.jpg" alt="reader"></p>
<p>其中常用的是InputStreamReader 和 BufferedReader</p>
<p>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">BufferedReader &#x3D; new BufferedReader(FileReader)<br><br>或<br><br>BufferedReader &#x3D; new BufferedReader(InputStreamReader) <br></code></pre></td></tr></table></figure>

<p>Writer的继承关系</p>
<p><img src="/2020/09/10/IOstream/writer.jpg" alt="writer"></p>
<p>其中常用的是OutputStreamWriter 和 BufferedWriter</p>
<p>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">BufferedWriter &#x3D; new BufferedReader(FileWriter)<br><br>或<br><br>BufferedWriter &#x3D; new BufferedReader(FileOutputStream)<br></code></pre></td></tr></table></figure>


<h1 id="流的选择和区别"><a href="#流的选择和区别" class="headerlink" title="流的选择和区别"></a><strong>流的选择和区别</strong></h1><h2 id="流的选择"><a href="#流的选择" class="headerlink" title="流的选择"></a><strong>流的选择</strong></h2><p>字符流：</p>
<ul>
<li>处理纯文本</li>
</ul>
<p>字节流：</p>
<ul>
<li>图像、视频、ppt</li>
</ul>
<h2 id="字符流与字节流的区别"><a href="#字符流与字节流的区别" class="headerlink" title="字符流与字节流的区别"></a><strong>字符流与字节流的区别</strong></h2><ol>
<li>字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法。</li>
</ol>
<ol start="2">
<li>字节流以字节为单位，字符流以字符为单位</li>
</ol>
<h2 id="字符流与字节流的转换"><a href="#字符流与字节流的转换" class="headerlink" title="字符流与字节流的转换"></a><strong>字符流与字节流的转换</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">InputStreamReader isr &#x3D; new InputStreamReader(InputStream);<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">OutputStreamWriter osw &#x3D; new OutputStreamWriter(OutputStream);<br></code></pre></td></tr></table></figure>



<h1 id="io流对文件的操作"><a href="#io流对文件的操作" class="headerlink" title="io流对文件的操作"></a><strong>io流对文件的操作</strong></h1><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a><strong>创建文件</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;filetest.txt&quot;);<br><br>String name &#x3D; file.getName();<br><br>System.out.println(name);<br><br>try&#123;<br>    file.createNewFile();<br>    System.out.println(&quot;Success!!!&quot;);<br>&#125;<br>catch (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a><strong>创建文件夹</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;newfile1&#x2F;subfile1&#x2F;subfile2&quot;);<br>if(!file.exists())&#123;<br>    file.mkdirs();<br>    System.out.println(&quot;success!&quot;);<br>&#125;<br>else &#123;<br>    System.out.println(&quot;exists!&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="读取文件数据"><a href="#读取文件数据" class="headerlink" title="读取文件数据"></a><strong>读取文件数据</strong></h2><p>字节流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FileInputStream fis &#x3D; new FileInputStream(file);<br><br>&#x2F;&#x2F;接口<br>ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();<br><br>int len;<br><br>byte[] buffer &#x3D; new byte[1024];<br><br>while((len&#x3D;fis.read(buffer))!&#x3D;-1)&#123;<br><br>    baos.write(buffer,0,len);<br><br>&#125;<br><br>System.out.println(baos.toString());<br></code></pre></td></tr></table></figure>

<p>字符流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FileReader fr &#x3D; new FileReader(file);<br><br>char[] buffer &#x3D; new char[1024];<br><br>while(fr.read()!&#x3D;-1)&#123;<br><br>    fr.read(buffer);<br><br>&#125;<br><br>System.out.println(new String(buffer));<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FileReader fr &#x3D; new FileReader(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;filetest.txt&quot;);<br><br>BufferedReader bufferedReader &#x3D; new BufferedReader(fr);<br><br>char[] buffer &#x3D; new char[1024];<br><br>while(bufferedReader.read()!&#x3D;-1)&#123;<br><br>    bufferedReader.read(buffer);<br><br>&#125;<br><br>System.out.println(new String(buffer));<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FileInputStream fis &#x3D; new FileInputStream(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;filetest.txt&quot;);<br><br>InputStreamReader isr &#x3D; new InputStreamReader(fis);<br><br>BufferedReader bufferedReader &#x3D; new BufferedReader(isr);<br><br>char[] buffer &#x3D; new char[1024];<br><br>while(bufferedReader.read()!&#x3D;-1)&#123;<br><br>    bufferedReader.read(buffer);<br><br>&#125;<br><br>System.out.println(new String(buffer));<br><br></code></pre></td></tr></table></figure>

<h2 id="向文件写入数据"><a href="#向文件写入数据" class="headerlink" title="向文件写入数据"></a><strong>向文件写入数据</strong></h2><p>字节流：</p>
<p>在FileOutputStream的构造方法中，有一个布尔值类型的参数，true代表追加内容，false代表覆盖原文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FileOutputStream fileOutputStream &#x3D; new FileOutputStream(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;filetest.txt&quot;,true);<br><br>String msg &#x3D; &quot; hello&quot;;<br><br>fileOutputStream.write(msg.getBytes(),0,msg.getBytes().length);<br><br></code></pre></td></tr></table></figure>

<p>字符流：</p>
<p>在使用字符流写入数据时，要将字符流关闭才可以写入数据（此时数据在缓冲区中），或者使用flush方法在字符流关闭前写入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>FileWriter fileWriter &#x3D; new FileWriter(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;filetest.txt&quot;,true);<br><br>String msg &#x3D; &quot; hello&quot;;<br><br>fileWriter.write(msg);<br><br>fileWriter.flush();<br><br>&#x2F;&#x2F;fileWriter.close();<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FileOutputStream fos &#x3D; new FileOutputStream(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;filetest.txt&quot;,true);<br><br>OutputStreamWriter osw &#x3D; new OutputStreamWriter(fos);<br><br>FileWriter fileWriter &#x3D; new FileWriter(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;filetest.txt&quot;,true);<br><br>&#x2F;&#x2F;            BufferedWriter bw &#x3D; new BufferedWriter(fileWriter);<br><br>BufferedWriter bw &#x3D; new BufferedWriter(osw);<br><br>String msg &#x3D; &quot; hello&quot;;<br><br>bw.write(msg);<br><br>bw.flush();<br><br></code></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>java</tag>
        <tag>javaIO流</tag>
      </tags>
  </entry>
</search>
